<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java面向对象高级</title>
      <link href="/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
      <url>/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>有时候我们需要这样一个类，它不需要被实例化，也不需要实现完整的方法，它只是用来被继承的，用来限制子类的一个“规范”。这样的类我们就可以将它定义为<strong>抽象类</strong>，抽象类内的方法可以定义为<strong>抽象方法</strong>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">抽象类必须使用<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>声明</span></span><br><span class="line"><span class="class">一个抽象类中可以没有抽象方法。抽象方法必须写在抽象类或者接口中</span></span><br><span class="line"><span class="class">只声明而未实现的方法称为抽象方法（未实现是指：没有“</span>&#123;&#125;“方法体），抽象方法必须使用<span class="keyword">abstract</span>关键字声明。</span><br><span class="line">    </span><br><span class="line">格式：</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名();<span class="comment">//抽象方法，只声明而未实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>在抽象类的使用中有几个原则： </p><ul><li>抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字new完成。</li><li>一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则<strong>必须覆写(重写)</strong>抽象类中的全部抽象方法。</li></ul><p>常见的问题：</p><ul><li>抽象类不能使用final声明，因为final修饰的类是不能有子类的 ，而抽象类必须有子类才有意义。</li><li>抽象类能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的构造方法（默 认是无参的），之后再调用子类自己的构造方法。</li></ul></blockquote><h3 id="抽象类与普通类的区别"><a href="#抽象类与普通类的区别" class="headerlink" title="抽象类与普通类的区别"></a>抽象类与普通类的区别</h3><ol><li>抽象类必须用public或protected修饰(如果为private修饰，那么子类则无法继承，也就无法实现其抽象方法）。默认缺省为 public </li><li>抽象类不可以使用new关键字创建对象，但是在子类创建对象时，抽象父类也会被JVM实例化。 </li><li>如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为abstract类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;<span class="comment">//抽象类可以有构造方法</span></span><br><span class="line">        System.out.println(<span class="string">"抽象类的构造方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以定义Person对象变量，但它只能引用非抽象子类的对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以上代码的运行结果为：</span><br><span class="line">抽象类的构造方法执行了</span><br><span class="line">Student.run</span><br><span class="line">说明抽象类可以有构造方法，在new一个抽象类的非子类对象时，JVM会默认先执行抽象</span><br><span class="line">类的构造方法。虽然我们不能new抽象类对象，但我们可以通过子类来操作抽象类中的资源。</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的概念及定义"><a href="#接口的概念及定义" class="headerlink" title="接口的概念及定义"></a>接口的概念及定义</h3><p>如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接 口。 定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123; </span><br><span class="line">    全局常量 ; </span><br><span class="line">    抽象方法 ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>面向接口编程思想</strong></p><p>接口是定义（规范，约束）与实现（名实分离的原则）的分离的思想。 </p><p>优点：</p><ol><li>降低程序的耦合性 </li><li>易于程序的扩展 </li><li>有利于程序的维护</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因为接口本身都是由全局常量和抽象方法组成，所以接口中的成员定义可以简写： </span><br><span class="line"><span class="number">1</span>.全局常量编写时，可以省略 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 关键字，例如： </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">"内容"</span> ; </span><br><span class="line">简写后：</span><br><span class="line">String INFO = <span class="string">"内容"</span> ; </span><br><span class="line"><span class="number">2</span>.抽象方法编写时，可以省略 <span class="keyword">public</span> <span class="keyword">abstract</span> 关键字，例如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>; </span><br><span class="line">简写后：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><p>接口可以多实现，格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码称为接口的实现。那么如果一个类即要实现接口，又要继承抽象类的话，则按照以下的格式编写 即可： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">如果一个接口要想使用，必须依靠子类。 子类（如果不是抽象类的话）要实现接口中的所有抽象方法。</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int  AGE = 10; //简写全局常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;     <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口因为都是抽象部分， 不存在具体的实现， 所以允许多继承,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承相当于扩展了接口的方法</p><h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>JDK1.8之后规定，在接口中，可以定义default方法。例如，把Person中的say()方法改为default方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Li Ming"</span>);<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><ol><li>抽象类要被子类继承，接口要被类实现。 </li><li>接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。 </li><li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 </li><li>抽象类使用继承来使用， 无法多继承。 接口使用实现来使用， 可以多实现 </li><li>抽象类中可以包含static方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法） </li><li>接口不能有构造方法，但是抽象类可以有</li></ol><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Object类是所有类的父类（基类），如果一个类没有明确的继承某一个具体的类，则将默认继承Object类。例如我们定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>其实它被使用时 是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用Object可以接收任意的引用数据类型</strong></p></blockquote><h3 id="Object类中常用的方法"><a href="#Object类中常用的方法" class="headerlink" title="Object类中常用的方法"></a>Object类中常用的方法</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>建议重写Object中的toString方法。 此方法的作用：返回对象的字符串表示形式。</p><p>Object的toString方法， 返回对象的内存地址</p><p>类<code>Object</code>的<code>toString</code>方法返回一个字符串，该字符串由对象为实例的类的名称，字符“  <code>@</code> ”以及对象的哈希码的无符号十六进制表示形式组成。 换句话说，此方法返回一个等于值的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// getter和setter方法省略，若想放入ide中测试，请自行添加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p.toString());  <span class="comment">//top.oop.demo09.Person@27f674d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果不重写toString()，那打印的结果明显不能体现出我们所创建的对象的特征。所以建议在类中去重写toString()方法。</p><p>我们可以在Person中重写toString()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"这是一个人，他叫"</span> + <span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.age + <span class="string">"岁了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java  看上面toString中的Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出p1和p2的内容信息是完全一样的，但我们用 <code>==</code>比较时，会返回false。其实这也很好理解，每当我们new一个对象时就会在内存中开辟一块空间，也就是说p1和p2指向的是不同的内存地址，程序当然会判定他们不等。</p><p>但我们总需要对对象的信息进行比较，这时我们可以重写Object中的equals()方法来解决。不能直接用，直接用相当于还是在用<code>==</code> 比较。可以看Object中equals方法的源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议重写Object中的equals(Object obj)方法，此方法的作用：指示某个其他对象是否“等于”此对象。 </p><p>Object的equals方法：实现了对象上最具区别的可能等价关系; 也就是说，对于任何<strong>非空引用</strong>值x和y，当且仅当 x和y引用同一对象（ x == y具有值true ）时，此方法返回true 。 </p><blockquote><p>equals方法重写时的五个特性： </p><ul><li>自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 </li><li>对称性 ：对于任何非空引用值x和y，x.equals(y)应该返回true当且仅当y.equals(x)回报true 。</li><li>传递性 ：对于任何非空引用值x ，y和z ，如果x.equals(y)返回true且y.equals(z)返回true ，那么 x.equals(z)应该返回true 。 </li><li>一致性 ：对于任何非空引用值x和y ，多次调用x.equals(y)始终返回true或始终返回false ，前提是未修改对象上的equals比较中使用的信息。 </li><li>非空性 ：对于任何非空的参考值x ， x.equals(null)应该返回false 。</li></ul></blockquote><p>equals一般根据我们的业务进行重写，举个例子,我们可以在Person类中重写equals方法，当唯一标识符id相等时，我们就认为这两个对象相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;<span class="comment">//如果传入的对象为空，根据非空性，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;<span class="comment">//如果传入的对象与当前对像类型相同</span></span><br><span class="line">        Person p2 = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.id == p2.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以进行简化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传入的对象为空或与当前对象类型不同，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.id == p.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA 快捷键 <code>Alt+Inster</code>可以自动重写equals方法和toString方法</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 </p><p>广泛意义上的内部类一般来说包括这四种：</p><ol><li>成员内部类</li><li>局部内部类 </li><li>匿名内部类 </li><li>静态内部类</li></ol><p>###成员内部类</p><p><strong>定义：</strong>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">200</span>;<span class="comment">//与外部类同名的变量</span></span><br><span class="line">System.out.println(<span class="string">"x="</span>+ x);<span class="comment">// x = 200.0</span></span><br><span class="line">            System.out.println(<span class="string">"x="</span> + Outer.<span class="keyword">this</span>.x); <span class="comment">//访问外部类的同名成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure><p><strong>成员内部类的使用：</strong></p><p>以上面定义的Outer类为例，来看如何让使用它里面的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="number">100</span>);</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.say();    </span><br><span class="line">        <span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">         *x = 200.0</span></span><br><span class="line"><span class="comment">         *  x = 100.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###局部内部类 </p><p>局部内部类是<strong>定义在一个方法或者一个作用域里面的类</strong>，它和成员内部类的区别在于<strong>局部内部类的访问仅限</strong><br><strong>于方法内或者该作用域内</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> People <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123; <span class="comment">//局部内部类 定义在了getPerson方法内</span></span><br><span class="line"><span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及<br>static修饰符的。</p></blockquote><p>下面我们使用系统的某个API，来演示局部内部类的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Frame;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">"登录"</span>);<span class="comment">//新建一个窗体</span></span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);     <span class="comment">//设置是否显示</span></span><br><span class="line">        f.setSize(<span class="number">300</span>,<span class="number">200</span>); <span class="comment">//设置大小</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyWindowListener</span> <span class="keyword">implements</span> <span class="title">WindowListener</span> </span>&#123;  <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关闭窗口"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);<span class="comment">//关闭窗口操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MyWindowListener l = <span class="keyword">new</span> MyWindowListener();</span><br><span class="line">        f.addWindowListener(l);      <span class="comment">//窗口监听器,需要传入一个实现WindowListener接口的类类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类由于没有名字，只能使用一次。创建格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//匿名内部类的类体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。这个引用是隐式的。</p><blockquote><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><ol><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能<br> 继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li><strong>匿名内部类为局部内部类</strong>，所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li><li>和局部内部类一样，只能访问final型的局部变量，因为内部类会被单独编译成一个字节码文件，为了保障这个单独的文件中用到的内部类外部的变量与内部类外部的变量的值绝对一致，系统从规则上限制这个值不可以被更改。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//jdk1.8以后可以省略final</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;<span class="comment">//明显b不是final型的</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;   <span class="comment">//匿名内部类实现了Person接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的say方法"</span> + a);</span><br><span class="line">                <span class="comment">//System.out.println(b); //报错，局部内部类和匿名内部类不能访问非final型的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ha(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ha</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p><p>静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它<strong>不能使用外部类的非</strong><br><strong>static成员变量或者方法.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticInnerClass.y = <span class="number">100</span>;</span><br><span class="line">Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        inner.say();<span class="comment">//100.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//System.out.println(x); //报错,静态内部类不能访问外部类的非静态成员和方法</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在Java中有一个设计的原则“一切皆对象”，那么这样一来Java中的一些基本的数据类型，就完全不符合于这种设计思想，因为Java中的八种基本数据类型并不是引用数据类型，所以Java中为了解决这样的问题，引入了八种基本数据类型的包装类。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr></tbody></table><p>以上的八种包装类，可以将基本数据类型按照类的形式进行操作。</p><p>以上的八种包装类也分为两种大的类型：</p><ul><li>Number：Integer、Short、Long、Double、Float、Byte都是Number的子类表示是一个<br>  数字。</li><li>Object：Character、Boolean都是Object的直接子类。</li></ul><h3 id="装箱和拆箱操作"><a href="#装箱和拆箱操作" class="headerlink" title="装箱和拆箱操作"></a>装箱和拆箱操作</h3><p>以下以<code>Integer</code>和<code>Float</code>为例进行操作</p><p>将一个<strong>基本数据类型变为包装类，那么这样的操作称为装箱操作</strong>。</p><p>将一个<strong>包装类变为一个基本数据类型，这样的操作称为拆箱操作</strong>，</p><p>因为所有的数值型的包装类都是Number的子类，Number的类中定义了如下的操作方法，以下的全部方法都<br>是进行拆箱的操作。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public byte byteValue()</td><td>用于Byte-&gt;byte</td></tr><tr><td>public abstract double doubleValue()</td><td>用于Double-&gt;double</td></tr><tr><td>public abstract float floatValue()</td><td>用于Float-&gt;float</td></tr><tr><td>public abstract int intValue()</td><td>用于Integer-&gt;int</td></tr><tr><td>public abstract long longValue()</td><td>用于Long-&gt;long</td></tr><tr><td>public short shortValue()</td><td>用于Short-&gt;short</td></tr></tbody></table><p><strong>装箱操作：</strong></p><p>在JDK1.4之前 ，如果要想装箱，直接使用各个包装类的构造方法即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span> ; <span class="comment">// 基本数据类型</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Integer(temp) ; <span class="comment">// 将基本数据类型变为包装类</span></span><br></pre></td></tr></table></figure><p>在JDK1.5，Java新增了自动装箱和自动拆箱，而且可以直接通过包装类进行四则运算和自增自减操作。例<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Float f = <span class="number">10.3f</span> ; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">float</span> x = f ; <span class="comment">// 自动拆箱</span></span><br><span class="line">System.out.println(f * f) ; <span class="comment">// 直接利用包装类完成</span></span><br><span class="line">System.out.println(x * x) ; <span class="comment">// 直接利用包装类完成</span></span><br></pre></td></tr></table></figure><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>使用包装类还有一个很优秀的地方在于：可以将一个字符串变为指定的基本数据类型，此点一般在接收输入<br>数据上使用较多。<br>在<code>Integer</code>类中提供了以下的操作方法：<br>        <code>public static int parseInt(String s)</code> ：将String变为int型数据<br>在<code>Float</code>类中提供了以下的操作方法：<br>        <code>public static float parseFloat(String s)</code>：将String变为Float<br>在<code>Boolean</code> 类中提供了以下操作方法：<br>        <code>public static boolean parseBoolean(String s)</code>：将String变为boolean<br>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String text = input.nextLine();</span><br><span class="line">        <span class="keyword">int</span> x = Integer.parseInt(text);     <span class="comment">//转为int类型,便于运算</span></span><br><span class="line">        System.out.println(x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象进阶</title>
      <link href="/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
      <url>/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>static关键字</strong></p><p>static表示“静态”的意思，可以用来修饰成员变量和成员方法。</p><p>static的主要作用在于创建独立于具体对象的域变量或者方法 </p><p>简单理解： </p><p>​        被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 并且不会因为对象的多次创建而在内存中建立多份数据</p><a id="more"></a><p><strong>注意</strong></p><ol><li><span style="color:red">静态成员在类加载时加载并初始化。</span> </li><li><span style="color:red">无论一个类存在多少个对象 , 静态的属性, 永远在内存中只有一份(可以理解为所有对象公用 ) </span></li><li><span style="color:red">在访问时：静态不能访问非静态 , 非静态可以访问静态 ! 静态资源的执行时机可能早于非静态资源,一定不会晚于非静态资源</span> </li></ol></blockquote><blockquote><p><strong>final关键字</strong></p><p>final表示“最终”的意思，可以用来修饰属性、变量、类和方法</p><p>final修饰的属性、变量就成为了常量，无法对其再次进行赋值。final 修饰的局部变量，只能赋值一次（可以先声明后赋值）；final修饰的成员属性，必须在声明时赋值！</p><p>全局常量：<code>public static final 数据类型 变量名</code></p><p>final修饰的类不可以被继承</p><p>final修饰的方法不能被子类重写</p></blockquote><blockquote><p><strong>代码块</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通代码块 </span><br><span class="line">在执行的流程中出现的代码块，我们称其为普通代码块。 </span><br><span class="line">构造代码块 </span><br><span class="line">在类中的成员代码块，我们称其为构造代码块，在每次对象创建时执行，执行在构造方法之前。 </span><br><span class="line">静态代码块</span><br><span class="line">在类中使用<span class="keyword">static</span>修饰的成员代码块，我们称其为静态代码块，在类加载时执行。 每次程序启动到关闭，只会执行一次的代码块。 </span><br><span class="line">同步代码块 </span><br><span class="line">在后续多线程技术中学习。 </span><br><span class="line"></span><br><span class="line">面试题： </span><br><span class="line">构造方法与构造代码块以及静态代码块的执行顺序：</span><br><span class="line">静态代码块 --&gt; 构造代码块 --&gt; 构造方法</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>mian()方法详解</strong></p><p><code>public static void main(String args[])</code> </p><p>以上的各个参数的含义如下： </p><p>​        public：表示公共的内容，可以被所有操作所调用 </p><p>​        static：表示方法是静态的，可以由类名称直接调用。</p><p>​        void：表示没有任何的返回值操作 </p><p>​        main：系统规定好的方法名称。如果main写错了或没有，会报错：NoSuchMethodError: main </p><p>​        String[] args：字符串数组，接收参数的</p></blockquote><h2 id="面向对象的三大特征（抽象）"><a href="#面向对象的三大特征（抽象）" class="headerlink" title="面向对象的三大特征（抽象）"></a>面向对象的三大特征（抽象）</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>该露的露，该藏的藏。我们程序设计要追求<span style="color:red">“高内聚，低耦合”</span>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉，低耦合就是仅暴漏少量的方法给外部使用。</p><p>封装(数据的隐藏)。通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称之为信息隐藏。</p><p>总之就是：<span style="color:red"><strong>属性私有，get/set</strong></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性：私有 private</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idNum;<span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些可以操纵私有属性的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set 设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//this关键字：this指当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNum</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idNum = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.idNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;<span class="number">120</span> || age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        stu1.setName(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(stu1.getName());</span><br><span class="line">        stu1.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Idea快捷方式   <kbd>Alt</kbd>+<kbd>Insert</kbd> : 自动生成get/set方法</p></blockquote><blockquote><p>在Java基础中，this关键字是一个最重要的概念。使用this关键字可以完成以下的操作：</p><ul><li>调用类中的属性 </li><li>调用类中的方法或构造方法</li><li>表示当前对象</li></ul></blockquote><blockquote><p><strong>权限修饰符</strong></p><table><thead><tr><th>修饰符</th><th>类</th><th>包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>如上表所示，public修饰的资源可以被其所在类，所在包，所在类的子类和其他包访问，protecte修饰的资源不可以被其他包访问，default修饰的资源只能被其所在类，所在包访问，而private修饰的资源只能被其所在类访问</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p><p><span style="color:red">Java中类只有单继承，多重继承，没有多继承！</span></p><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</p><p>private 类型的属性和方法不可被继承，也就是说子类不能调用父类私有的属性和方法。</p><p><strong>object</strong>类：在Java类，所有的类都默认直接或者间接继承Object类</p><p><strong>super</strong>：类似this,this指示的是当前对象，super指示的是其父类对象。通过supe，可以访问父类的构造方法、父类的属性和父类的方法。<span style="color:red">使用super调用了父类构造方法时，必须要在子类构造器的第一行</span></p><p>在我们创建子类对象时，内存中会先创建父类对象，再创建子类对象，子类会通过super关键字拥有父类的地址，来调用父类中可使用的属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">"Brian"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person父类的无参构造执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//隐藏代码：调用了父类的无参构造。若要写，必须要在子类构造器的第一行。如果父类没有无参构造，则super(参数...)不可被省略。</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Student子类的无参构造执行了"</span>);</span><br><span class="line">        <span class="comment">//super(); 错误。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ZhangSan"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//ZhangSan</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);<span class="comment">//Brian</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Person父类的无参构造执行了</span></span><br><span class="line"><span class="comment">Student子类的无参构造执行了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        张三</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">Brian</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test1();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Student</span></span><br><span class="line"><span class="comment">Student</span></span><br><span class="line"><span class="comment">Person</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">注意：</span></p><ol><li>super调用父类的构造方法，必须在子类构造方法的第一个！</li><li>super必须只能出现在子类的方法或者构造方法中！</li><li>super和this不能同时调用构造方法！</li></ol><p>super VS this</p><ul><li>代表的对象不同：<ul><li>this : 本身调用者这个对象</li><li>super : 代表父类对象的应用</li></ul></li><li>前提：<ul><li>this 没有继承也可以使用</li><li>super : 只能在继承条件下才能使用</li></ul></li><li>构造方法：<ul><li>this() : 本类的构造</li><li>super() :  父类的构造</li></ul></li></ul></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写:"></a>方法重写:</h4><p>规则：</p><ul><li><strong>参数列表必须完全与被重写方法的相同。</strong></li><li>一般情况下，<strong>返回值类型必须完全与被重写方法的返回值类型相同</strong>；当返回值为<strong>类类型</strong>时，重写的方法返回值可以不同，但<strong>必须是父类方法返回值的子类</strong>。</li><li><strong>访问权限不能比父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 和 private 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.A;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法:方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">    <span class="comment">//非静态方法:重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//结果：A-&gt;test()</span></span><br><span class="line">        <span class="comment">//父类的引用指向子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test(); <span class="comment">//子类重写了父类的方法结果：A-&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么需要重写？</strong></p><ol><li>父类的功能，子类不一定需要，或者不一定满足。</li></ol></blockquote><blockquote><p>Idea快捷方式   <kbd>Ctrl</kbd>+<kbd>H</kbd> : 显示继承关系</p></blockquote><blockquote><p><strong>重写（override）与重载（overload）的区别</strong></p><ol><li>重载发生在一个类中，重写发送在子父类中</li><li>重载参数列表必须不同，重写的参数列表必须相同</li><li>重载与返回值类型无关，重写的返回值类型必须一致或是父类的子类</li><li>重载与访问权限无关，重写中，子类的方法的访问权限不能小于父类中被重写方法的权限</li><li>重载与异常无关，重写的方法不能抛出新的异常，或者比被重写方法声明的更广泛的异常</li></ol></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式。一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p><p>多态存在的条件：</p><ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象  <code>Father f1 = new Son();</code></li></ul><blockquote><p><strong>注意：</strong></p><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系，若无，则会报异常(类型转换异常:ClassCastException)</li></ol></blockquote><blockquote><p>有些方法无法重写：</p><ol><li>static 方法  属于类，不属于实例对象</li><li>final </li><li>private 方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 父类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Person;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象的实际类型是确定的，可以指向的引用类型就不确定了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Person 父类，可以指向子类，但不能调用子类独有的方法</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();<span class="comment">//Person对象 </span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();  <span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        <span class="comment">// Student 能调用的方法都是自己的或者继承父类的！</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();<span class="comment">//Student对象</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">p1.run();<span class="comment">//run 执行Person类的方法</span></span><br><span class="line">        s2.run();<span class="comment">//son  子类重写了父类的方法，执行子类Student类的方法</span></span><br><span class="line">        s1.run();<span class="comment">//son</span></span><br><span class="line">        <span class="comment">//s2.eat(); 错误:s2的引用类型为Person类型 它不能调用子类独有的方法</span></span><br><span class="line">        s1.eat();<span class="comment">//eat 执行Student类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>#####扩展： <code>instanceof</code>和类型转换</p><h6 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a><code>instanceof</code></h6><p>关键字  <code>instanceof</code> ： Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><p><strong>1. obj必须为引用类型，不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p>instanceof运算符只能用作对象的判断。</p><p><strong>2. obj 为 null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>关于 null 类型的描述在官方文档：<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1</a> 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte short int long float double char boolean,一种是引用类型，包括类、接口、数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的<strong>特殊符号</strong>。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2" target="_blank" rel="noopener">JavaSE规范</a> 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</p><p><strong>3. obj为class类的实例对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>4. obj为class接口的实现类</strong></p><p>集合中有个上层接口 List，其有个典型实现类 ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;    </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>或者反过来也是返回 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>5. obj为class类的直接或间接子类</strong></p><p>新建一个父类 Person，然后在创建它的一个子类 Man</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Man m1 = <span class="keyword">new</span> Man();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);<span class="comment">//false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意第一种情况， <code>p1 instanceof Man</code> ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。</p><h6 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h6><p>java的引用类型转换分为两种：</p><ol><li><p>向上类型转换，是小类型到大类型的转换 ，子类转换为父类，可能会丢失自己本来的一些方法</p></li><li><p>向下类型转换，是大类型到小类型的转换 (强制转换)  父类转化为子类</p><p> <strong>引用类型的强转条件</strong> : 把父类类型(直接父类+间接父类)  —&gt; 子类类型</p><p>  A x = (A)B;  只要B是A的父类,此句代码编译通过</p><p> <strong>强转的意义</strong>：把父类类型强转为子类类型，在编译期可以调用子类的字段与方法(父类的字段与方法子类都能直接继承，但是子类有的父类有可能没有)==&gt;强转之后，父类与子类的字段与方法都可以使用</p></li></ol><p>现存在一个Person类，Student子类和Teacher子类继承于Person父类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father class:run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son Student class:go"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个student对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();   <span class="comment">//使用子类引用实例化子类对象</span></span><br><span class="line"><span class="comment">//Teacher t = (Teacher)s;//不能转，因为Student 与 Teacher没有继承关系</span></span><br><span class="line">Person p = s; <span class="comment">//此时为向上引用转换，小类型转换为大类型，自动转换，并没有风险</span></span><br><span class="line"><span class="comment">//p.go(); //错误，Person引用类型不能调用子类独有的方法</span></span><br><span class="line">Person ps = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//Student s2 = (Student)ps;//引用类型的大转小，强制转换.</span></span><br></pre></td></tr></table></figure><p>向下引用转换应该先判断类型是否一致，利用java的instanceof关键字判断。instanceof运算符用法：判断是一个实例对象是否属于一个类，是返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Teacher) &#123;<span class="comment">//判断p2是否是Teacher类型的对象</span></span><br><span class="line">    Teacher tea = (Teacher)p2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Student) &#123;<span class="comment">//判断p2是否是Student类型的对象</span></span><br><span class="line">    Student stu = (Student)p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在实际项目中,p2的值可能是new Student()|new Teacher()|new Person(). 如果值是new Teacher()则把该对象p2强转为Teacher类型</span></span><br><span class="line"><span class="comment">问题：如何判断p2的值到底是new的哪个类对象？</span></span><br><span class="line"><span class="comment">方案：使用instanceof.       instanceof:判断指定变量是否是指定类型的对象。</span></span><br><span class="line"><span class="comment">当前场景：判断 p2 是否是 Teacher类型 的对象。</span></span><br><span class="line"><span class="comment">语法：指定变量 instanceof 指定类型。   返回false:不是指定类型的对象 ， 反之则反</span></span><br><span class="line"><span class="comment">在运行期有效。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是当子类实例对象统一放进父类引用对象数组时，若要使用子类中的方法，必须先向下转换类型为子类引用，不然编译器会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = &#123;</span><br><span class="line">    <span class="keyword">new</span> Student(),</span><br><span class="line">    <span class="keyword">new</span> Teacher()</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//people[0].go();   //报错</span></span><br><span class="line"><span class="keyword">if</span>(people[<span class="number">0</span>] <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    ((Student)people[<span class="number">0</span>]).go();<span class="comment">//son Student class:go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java面向对象基础</title>
      <link href="/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h2><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p><strong>面向过程思想：</strong></p><ul><li>是把模型分解成一步一步的过程。步骤清晰简单，第一步做什么，第二步做什么……</li><li>面向过程适合处理一些较为简单的问题</li></ul><a id="more"></a><p><strong>面向对象思想：</strong></p><ul><li>物以类聚，<span style="color:red">分类</span>的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul><p><span style="color:red">对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路、来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</span></p><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向对象编程(Object-Oriented Progrsmming,OOP)是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p><strong>面向对象编程的本质就是：</strong><span style="color:red">以类的方式组织代码，以对象的形式封装数据。</span></p><p><strong>面向对象的核心思想：</strong></p><ul><li><p><strong>三大思想：</strong>面向对象思想从概念上讲分为以下三种OOA、OOD、OOP</p><ul><li>OOA：面向对象分析（Object Oriented Analysis） </li><li>OOD：面向对象设计（Object Oriented Design） </li><li>OOP：面向对象程序（Object Oriented Programming）</li></ul></li><li><p><strong>抽象</strong></p></li><li><p><strong>三大特性</strong></p><ul><li>封装性：所有的内容对外部不可见</li><li>继承性：将其他的功能继承下来继续发展</li><li>多态性：方法的重载本身就是一个多态性的体现</li></ul></li></ul><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>具体可参考 <a href="http://pengspace.top/2020/05/30/Java方法/#more">java方法</a>，此处只做一些补充说明</p><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><h5 id="break和return的区别"><a href="#break和return的区别" class="headerlink" title="break和return的区别"></a>break和return的区别</h5><p><code>break</code>:结束整个循环</p><p><code>continue</code>:结束本次循环</p><p><code>return</code>: 结束方法，返回一个结果</p><h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h5><p>注意规范，首字母小写和驼峰原则。见名知意</p><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>（参数类型，参数名）…</p><h5 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) <span class="keyword">throws</span> 异常类型(如 IOException) &#123;  </span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><h5 id="静态方法和非静态方法"><a href="#静态方法和非静态方法" class="headerlink" title="静态方法和非静态方法"></a>静态方法和非静态方法</h5><p><span style="color:red">非静态方法不能通过类名直接调用，若要调用非静态方法，必须先实例化该方法所在类的对象，通过对象来调用。</span></p><p><span style="color:red">静态方法可以通过类名直接调用，也可以通过对象调用。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student.say1();</span><br><span class="line">        <span class="comment">//Student.say2();错误，非静态方法不能通过类名直接调用</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();<span class="comment">//实例化对象</span></span><br><span class="line">        stu.say1();</span><br><span class="line">        stu.say2();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"非静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">静态方法是和类一起加载的，而非静态方法是在类实例化后才会起作用的</span>，所以在类中，也不能在静态方法中去调用非静态方法</p><h5 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h5><blockquote><p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。</p><p>实际参数：在调用有参函数时，主调函数和被调函数有数据传递关系。在主调函数中调用一个函数时，函数后面括号中的参数称为“实际参数”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//实际参数和形式参数的类型要对应</span></span><br><span class="line">        <span class="keyword">int</span> add = demo.add(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//1和2是实参</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    <span class="comment">//a和b是形参</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际参数是调用有参方法时真正传递的内容，而形式参数是用于接收实参内容的参数。</p><h5 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h5><p><span style="color:red">Java中都是值传递。</span></p><p>后续会专门写一篇来讲述Java为什么都是值传递。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><span style="color:red">类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</span>比如Person类、Pet类、Car类等，这些类都是<span style="color:red">用来描述/定义某一类具体事物应该具备的特点和行为。</span></p><p><span style="color:red">对象是抽象概念的具体实例。</span>比如 你就是个人的具体实例，你家的旺财就是狗的一个具体实例。<span style="color:red">能够体现出特点、展现出功能的是具体的实例，而不是一个抽象的概念。</span></p><h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">成员属性</span><br><span class="line">成员方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">属性定义格式：</span><br><span class="line">数据类型 属性名;</span><br><span class="line">属性定义并赋值的格式：</span><br><span class="line">数据类型 属性名 = 初始化值;</span><br><span class="line">方法定义格式：</span><br><span class="line">权限修饰符 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用<code>new</code>关键字创建对象。</p><p>使用<code>new</code>关键字创建对象的时候，除了为对象分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个类要想真正的进行操作，则必须依靠对象，对象的定义格式如下:</span><br><span class="line">类名称 对象名称 = <span class="keyword">new</span> 类名称();</span><br><span class="line"></span><br><span class="line">如果要想访问类中的属性或方法（方法的定义），则可以依靠以下的语法形式：</span><br><span class="line">访问类中的属性： 对象.属性 ;</span><br><span class="line">调用类中的方法： 对象.方法(实际参数列表) ;</span><br></pre></td></tr></table></figure><h3 id="构造方法（构造器）详解"><a href="#构造方法（构造器）详解" class="headerlink" title="构造方法（构造器）详解"></a>构造方法（构造器）详解</h3><p>一个类中即使什么都不写，也可以实例化该类的对象，那是因为，类中默认存在一个方法，就是<span style="color:red"><strong>构造器</strong></span>。</p><p>类中的<span style="color:red"><strong>构造器</strong></span>也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：</p><ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写void</li></ul><p>我们在使用<code>new</code>关键字实例化对象时,本质是在调用构造器,来初始化值。</p><p>构造器可以重载，但注意，<span style="color:red">一旦你定义了有参构造器，如果还想使用无参构造，无参构造器就必须也显式定义。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个类即使什么都不写，它也会存在一个方法</span></span><br><span class="line">    <span class="comment">//默认构造器 public  Person()&#123;&#125;</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造器 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造器：一旦定义了有参构造，无参构造器就必须显式定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new 实例化对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(person.name);    <span class="comment">//null</span></span><br><span class="line">        System.out.println(person1.name);   <span class="comment">//brian</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有对象名称的对象 就是匿名对象。 </span><br><span class="line">匿名对象只能使用一次，因为没有任何的对象引用，所以将称为垃圾，等待被GC回收。 </span><br><span class="line">只使用一次的对象可以通过匿名对象的方式完成，这一点在以后的开发中将经常使用到。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Math().sum(<span class="number">100</span>,<span class="number">20</span>);<span class="comment">//匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>Java栈的区域很小 , 大概2m左右 , 特点是存取的速度特别快 </p><p>栈存储的特点是, 先进后出</p><p>存储速度快的原因: </p><p>栈内存, 通过 ‘栈指针’ 来创建空间与释放空间 ! </p><p>指针向下移动, 会创建新的内存, 向上移动, 会释放这些内存 ! </p><p>这种方式速度特别快 , 仅次于PC寄存器 ! </p><p>但是这种移动的方式, 必须要明确移动的大小与范围 , 明确大小与范围是为了方便指针的移动 , 这是一个对于数据存储的限制, 存储的数据大小是固定的 , 影响了程序 的灵活性 ~</p><p>所以我们把更大部分的数据 存储到了堆内存中 </p><p>存储的是: </p><p>​        基本数据类型的数据 以及 引用数据类型的引用! </p><p>​        例如: </p><p>​        int a =10;</p><p>​        Person p = new Person(); </p><p>​        10存储在栈内存中 , 第二句代码创建的对象的引用(p)存在栈内存中</p></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>存放的是类的对象 . </p><p>Java是一个纯面向对象语言, 限制了对象的创建方式: </p><p>​        <span style="color:red">所有类的对象都是通过new关键字创建 </span></p><p>new关键字, 是指告诉JVM , 需要明确的去创建一个新的对象 , 去开辟一块新的堆内存空间: </p><p>堆内存与栈内存不同, 优点在于我们创建对象时 , 不必关注堆内存中需要开辟多少存储空间 , 也不需要关注内存占用 时长 ! </p><p>堆内存中内存的释放是由GC(垃圾回收器)完成的 </p><p>垃圾回收器 回收堆内存的规则: </p><p>​        当栈内存中不存在此对象的引用时,则视其为垃圾 , 等待垃圾回收器回收 !</p></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>存放的是 </p><ul><li>类信息 </li><li>静态的变量 </li><li>常量</li><li>成员方法 </li></ul><p>方法区中包含了一个特殊的区域 ( 常量池 )(存储的是使用static修饰的成员)</p></blockquote><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><blockquote><p>PC寄存器保存的是 当前正在执行的 JVM指令的 地址 ! </p><p>在Java程序中, 每个线程启动时, 都会创建一个PC寄存器 !</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>保存本地(native)方法的地址 !</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单的Java加减乘除计算器(适合新手)</title>
      <link href="/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/"/>
      <url>/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<p>本人Java新手一枚，刚学完Java数据类型、流程控制、数组、方法等基础语法知识。</p><p>尝试写了一个简单的计算器，实现了加减乘除功能，并可以循环接收数据。</p><p>代码有待改进，希望各位大佬多多指点 :beers:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第一个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> a = in.nextDouble();</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第二个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> b = in.nextDouble();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入运算方式(+ - * /)"</span>);</span><br><span class="line">                String operation = in.next();</span><br><span class="line">                <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                        System.out.println(add(a,b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                        System.out.println(subtraction(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                        System.out.println(multiply(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                        System.out.println(division(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"是否继续使用? "</span> + <span class="string">"YES/NO"</span>);</span><br><span class="line">                String choose = in.next();</span><br><span class="line">                <span class="keyword">if</span> (choose.equals(<span class="string">"YES"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose.equals(<span class="string">"NO"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"欢迎下次使用，再见"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">subtraction</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">multiply</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"被除数不能为0"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java方法</title>
      <link href="/2020/05/30/Java%E6%96%B9%E6%B3%95/"/>
      <url>/2020/05/30/Java%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><a id="more"></a><p><strong>设计方法的原则：</strong></p><p>方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的<span style="color:red">原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展</span>。</p><p><strong>方法的命名规范：</strong></p><p>首字母小写和驼峰原则：run()，runRun()。</p><h2 id="方法的定义及调用"><a href="#方法的定义及调用" class="headerlink" title="方法的定义及调用"></a>方法的定义及调用</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>Java的方法类似于其它语言函数是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：</p><p><span style="color:red">方法包含一个方法头和一个方法体。</span>下面是一个方法的所有部分：</p><ul><li><span style="color:red">修饰符</span>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><span style="color:red">返回值类型</span>：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li><li><span style="color:red">方法名</span>：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><span style="color:red">参数类型</span>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul><li>形式参数：在方法被调用时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul></li><li><span style="color:red">方法体</span>：方法体包含具体的语句，定义该方法的功能。</li><li><span style="color:red">返回值</span>：如果返回值类型不为void，那么需要在方法体的最后return返回值，遇到return即结束方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方法：对象名.方法名（实参列表）</p><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p><ul><li><p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> larger = max(<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果方法返回值是void，方法调用一定是一条语句。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p><p><strong>方法的重载的规则：</strong></p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。·仅仅返回类型不同不足以成为方法的重载。</li></ul><p><strong>实现理论：</strong></p><p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> staticvoid) main(String args[])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"args["</span>+ i +<span class="string">"]:"</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/30/ZSfx6b4NPU8Xdhe.png" alt=""></p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK 1.5开始，Java支持传递同类型的可变参数给一个方法。</p><p>在方法声明中，在指定参数类型后加一个省略号（…）。</p><p>一个方法中只能指定<strong>一个</strong>可变参数，它必须是方法的<strong>最后一个参数</strong>。任何普通的参数必须在它之前声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"No argument passed"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result=numbers[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//排序！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numbers.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(numbers[i]&gt;result)&#123;</span><br><span class="line">result=numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">"The max value is "</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><span style="color:red">递归</span></h2><p>A方法调用B方法，我们很容易理解</p><p><strong>递归就是：</strong>A方法调用A方法！就是自己调用自己</p><p>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><strong>递归结构包括两个部分：</strong></p><ul><li><span style="color:red">边界(递归头)</span>：什么时候不调用自身方法。如果没有头，将陷入死循环。</li><li><span style="color:red">递归体</span>：什么时候需要调用自身方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        n = n*factorial(n-<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java数组</title>
      <link href="/2020/05/24/Java%E6%95%B0%E7%BB%84/"/>
      <url>/2020/05/24/Java%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h2><p><strong><code>数组的定义:</code></strong></p><ul><li><p>数组是<span style="color:red">相同类型数据</span>的有序集合。</p></li><li><p>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</p></li><li><p>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</p></li></ul><h3 id="数组的声明创建"><a href="#数组的声明创建" class="headerlink" title="数组的声明创建"></a>数组的声明创建</h3><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;<span class="comment">//首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];<span class="comment">//效果相同，但不是首选方法，不推荐使用</span></span><br></pre></td></tr></table></figure><p>Java语言使用<code>new</code> 操作符来创建数组，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure><p>数组的元素是通过索引访问的，<span style="color:red">数组索引从<strong>0</strong>开始</span>。</p><p>获取数组长度：<code>arrays.length</code></p><p>声明时数组在内存中并不存在，只有在创建数组时，才会在内存中为数组分配指定的空间。</p><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><p><img src="https://i.loli.net/2020/05/23/pEowZelcCNFGzQ3.png" alt="java内存"></p><p><code>数组在内存中的创建过程:</code></p><ol><li>在声明数组时会在栈中压入数组名</li><li>创建数组时会在堆中开辟指定的空间用来存放数组</li><li>给数组赋值，将值存放在堆中数组对应的空间里</li></ol><p><img src="https://i.loli.net/2020/05/23/QGIF8zbnEcasDvg.png" alt="数组在内存中的创建过程"></p><h3 id="数组的三种初始化"><a href="#数组的三种初始化" class="headerlink" title="数组的三种初始化"></a>数组的三种初始化</h3><ul><li><p><strong>静态初始化</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans =&#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>动态初始化</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//创建数组 默认初始化</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>数组的默认初始化</strong></p><p>  数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p></li></ul><h3 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h3><ul><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是<span style="color:red">相同类型</span>，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li><li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<span style="color:red">数组对象本身是在堆中的</span>。</li></ul><h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><p>下标的合法区间：[0,length-1]，如果越界就会报错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(a[<span class="number">2</span>]);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">ArraylndexOutOfBoundsException：数组下标越界异常！</span></p><blockquote><p><strong><code>小结</code></strong></p><ul><li>数组是相同数据类型（数据类型可以为任意类型）的有序集合</li><li>数组也是对象。数组元素相当于对象的成员变量</li><li>数组长度的确定的，不可变的。如果越界，则报：ArraylndexOutofBounds</li></ul></blockquote><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><p>数组一般可以配合循环来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//打印全部的数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            System.out.println(arrays[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印所有元素的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; ++i) &#123;</span><br><span class="line">            sum += arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum);</span><br><span class="line">        <span class="comment">//查找最大最小元素</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];<span class="comment">//创建变量，存储遍历数组时发现的最大值，</span></span><br><span class="line">        <span class="comment">//初始值赋为数组中第一个元素而不赋为0，是为了避免数组中没有比0大的值，这样就会输出错误的值</span></span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            max = max &gt; arrays[i] ? max : arrays[i];</span><br><span class="line">            min = min &lt; arrays[i] ? min : arrays[i]</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"max="</span>+max+<span class="string">"\nmin="</span>+<span class="string">"min"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each循环-增强型for循环"><a href="#for-each循环-增强型for循环" class="headerlink" title="for-each循环(增强型for循环)"></a>for-each循环(增强型for循环)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> array : arrays)&#123;<span class="comment">//这种方式没有下标，适合打印输出</span></span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组作方法入参和作返回值"><a href="#数组作方法入参和作返回值" class="headerlink" title="数组作方法入参和作返回值"></a>数组作方法入参和作返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arraysReverse = reverse(arrays);</span><br><span class="line">        printArray(arraysReverse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123; <span class="comment">//数组作为方法的传入参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            System.out.print(arrays[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] arrays)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            result[result.length-i-<span class="number">1</span>] = arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//数组作为返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的常用算法"><a href="#数组的常用算法" class="headerlink" title="数组的常用算法"></a>数组的常用算法</h3><p>####冒泡排序</p><p><img src="https://i.loli.net/2020/05/24/QoRPrY2VfzcnhwE.gif" alt="冒泡排序"></p><p>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</p><p>原理：比较两个相邻的元素，将值大的元素交换到右边</p><p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p><p>算法分析：</p><p>N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p><p>时间复杂度</p><p>1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：$C_{min}=n-1$；$M_{min}=0$;所以，冒泡排序最好的时间复杂度为O(n)。</p><p>2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p><p>$$C_{max} =\cfrac{n(n-1)}{2} = O(n^2)$$</p><p>$M_{max} =\cfrac{3n(n-1)}{2} = O(n^2)$</p><p>综上所述：冒泡排序总的平均时间复杂度为：$O(n^2)$ ,时间复杂度和数据状况无关。</p><blockquote><p>Java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//外层循环控制比较的轮次 : length-1轮</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">     <span class="comment">//内层循环控制每轮比较的次数</span></span><br><span class="line">     <span class="comment">//第i轮（i从0开始计算），比较次数为length-i-1</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (array[j+<span class="number">1</span>]&lt;array[j])&#123;</span><br><span class="line">             temp = array[j];</span><br><span class="line">             array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">             array[j+<span class="number">1</span>] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="二分查找（折半查找）"><a href="#二分查找（折半查找）" class="headerlink" title="二分查找（折半查找）"></a>二分查找（折半查找）</h4><p><strong>概述</strong></p><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求数组数据必须采用顺序存储结构有序排列。</p><p>*<em>原理 *</em></p><p>首先，假设数组中元素是按升序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功；否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数组，否则进一步查 找后子数组。</p><p> 重复以上过程，直到找到满足条件的数据，则表示查找成功， 直到子数组不存在为止，表示查找不成功。</p><blockquote><p>Java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找（折半查找）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个有序数组</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br><span class="line"><span class="comment">//要查找的数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">bubbleSort(nums,num);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"位置："</span>+centerIndex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array，<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.最小范围下标</span></span><br><span class="line"><span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2.最大范围下标</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = array.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.中间数据下标</span></span><br><span class="line"><span class="keyword">int</span> centerIndex = (minIndex+maxIndex)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"循环了一次"</span>);</span><br><span class="line"><span class="keyword">if</span>(array[centerIndex]&gt;num) &#123;</span><br><span class="line"><span class="comment">//中间数据较大</span></span><br><span class="line">maxIndex = centerIndex-<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[centerIndex]&lt;num) &#123;</span><br><span class="line"><span class="comment">//中间数据较小</span></span><br><span class="line">minIndex = centerIndex+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//找到了数据  数据位置：centerIndex</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(minIndex &gt; maxIndex) &#123;</span><br><span class="line">centerIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当边界发生变化， 需要更新中间下标</span></span><br><span class="line">centerIndex = (minIndex+maxIndex)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> centerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]<span class="comment">//二维数组a可以看成一个两行5列的数组</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/24/qOGaBP61eo5mVdU.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arrays= &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//将数组遍历打印出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays[i].length; j++)&#123;</span><br><span class="line">                System.out.print(arrays[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Java的Arrays类"><a href="#Java的Arrays类" class="headerlink" title="Java的Arrays类"></a>Java的Arrays类</h2><p>数组的工具类<code>java.util.Arrays</code></p><p>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</p><p>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意：是“不用”而不是“不能”）</p><p>Arrays类具有以下<strong>常用</strong>功能</p><ul><li>给数组赋值：通过fill方法。</li><li>对数组排序：通过 sort 方法，按升序。</li><li>比较数组：通过equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><p>具体使用可参考<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">JDK文档</a></p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用<strong>稀疏数组</strong>来保存该数组。</p><p>稀疏数组的处理方式是：</p><ul><li><p>记录数组一共有几行几列，有多少个不同值</p></li><li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模</p></li></ul><blockquote><p>如下图：左边是原始数组，右边是稀疏数组</p><p><img src="https://i.loli.net/2020/05/24/4HsMGcvahmbUk72.png" alt=""></p><table><thead><tr><th align="center"></th><th align="center">行</th><th align="center">列</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">[0]</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">表示这是一个6行7列的数组，有效值有 8 个</td></tr><tr><td align="center">[1]</td><td align="center">0</td><td align="center">3</td><td align="center">22</td><td align="center">第一个有效值位于第0行第3列，值为22</td></tr><tr><td align="center">[2]</td><td align="center">0</td><td align="center">6</td><td align="center">15</td><td align="center">第二个有效值位于第0行第6列，值为15</td></tr><tr><td align="center">[3]</td><td align="center">1</td><td align="center">1</td><td align="center">11</td><td align="center">第三个有效值位于第1行第1列，值为11</td></tr><tr><td align="center">[4]</td><td align="center">1</td><td align="center">5</td><td align="center">17</td><td align="center">第四个有效值位于第1行第5列，值为17</td></tr><tr><td align="center">[5]</td><td align="center">2</td><td align="center">3</td><td align="center">-6</td><td align="center">第五个有效值位于第2行第3列，值为-6</td></tr><tr><td align="center">[6]</td><td align="center">3</td><td align="center">5</td><td align="center">39</td><td align="center">第六个有效值位于第3行第5列，值为39</td></tr><tr><td align="center">[7]</td><td align="center">4</td><td align="center">0</td><td align="center">91</td><td align="center">第七个有效值位于第4行第0列，值为91</td></tr><tr><td align="center">[8]</td><td align="center">5</td><td align="center">2</td><td align="center">28</td><td align="center">第八个有效值位于第5行第2列，值为28</td></tr></tbody></table></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** 转为稀疏数组 ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] toSparseArray(<span class="keyword">int</span>[][] arr)&#123;</span><br><span class="line">    <span class="comment">//获取有效值的个数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建一个稀疏数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>].length;</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">    <span class="comment">//遍历arr,将非零的值的信息，存放入稀疏数组中</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                arr2[count][<span class="number">0</span>] = i;</span><br><span class="line">                arr2[count][<span class="number">1</span>] = j;</span><br><span class="line">                arr2[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 稀疏数组转为普通数组 ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span>[][] arr)&#123;</span><br><span class="line">    <span class="comment">//读取稀疏数组,并新建一个数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[arr[<span class="number">0</span>][<span class="number">0</span>]][arr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//还原稀疏数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr2[arr[i][<span class="number">0</span>]][arr[i][<span class="number">1</span>]] = arr[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java流程控制</title>
      <link href="/2020/05/19/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2020/05/19/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h2><p>java.util.Scanner是Java5的新特征，我们可以通过Scanner 类来获取用户的输入。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">if</span> (s.hasNext)&#123;</span><br><span class="line">    type name = s.next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.hasNextLine)&#123;</span><br><span class="line">    type name = s.nextLine()</span><br><span class="line">&#125;</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>通过 Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()判断是否还有输入的数据。</p><blockquote><p><span style="color:red">凡是属于IO流的类如果不关闭会一直占用资源，要习惯用完就关掉.</span></p></blockquote><p>下面来看一下<code>next()</code>方法和<code>nextLine()</code>方法的区别</p><p><code>next()</code>:</p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next()方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><span style="color:red">next()不能得到带有空格的字符串。</span></li></ul><p><code>nextLine()</code>:</p><ul><li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导入Scanner工具类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建扫描器Scanner对象，用于接收键盘数据</span></span><br><span class="line">        Scanner in1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner in2 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//in1和in2都输入“hello world”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span>(in1.hasNext())&#123;</span><br><span class="line">            <span class="comment">//使用next()方法接收</span></span><br><span class="line">            String str1 = in1.next();</span><br><span class="line">            System.out.println(<span class="string">"用next()方法接收的输出："</span> + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(in2.hasNextLine())&#123;</span><br><span class="line">            <span class="comment">//使用nextLine()方法接收</span></span><br><span class="line">            String str2 = in2.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"用nextLine()方法接收的输出："</span> + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源，要习惯用完就关掉</span></span><br><span class="line">        in1.close();</span><br><span class="line">        in2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行结果如图所示：</p><img src="https://i.loli.net/2020/05/17/Bxt5UXKyWm1co3v.png" style="zoom:80%;" /><p>scanner工具中，还有hasNextInt()、hasNextFloat()等方法验证输入的类型，nextInt()、nextFloat()接收相关类型的输入。</p><blockquote><p>拓展说明：</p><p><code>print()</code>和<code>println()</code>的区别：</p><p><code>println()</code>:输出完会换行</p><p><code>print()</code>:输出完不会换行，内容都输出在一行</p></blockquote><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</p><p>顺序结构是最简单的算法结构。</p><img src="https://i.loli.net/2020/05/17/z5DBQHsrjbfiJMC.png" style="zoom: 50%;" /><p>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<span style="color:red">它是任何一个算法都离不开的一种基本算法结构。</span></p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if选择结构"><a href="#if选择结构" class="headerlink" title="if选择结构"></a><code>if</code>选择结构</h3><h4 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a><code>if</code>单选择结构</h4><p>我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用<code>if</code>语句来表示。</p><img src="https://i.loli.net/2020/05/19/QfS8e5un3JXVdyk.png" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a><code>if</code>双选择结构</h4><p>那现在有个需求，公司要收购一个软件，成功了，给人支付100万元，失败了，自己找人开发。这样的需求用一个<code>if</code>就搞不定了，我们需要有两个判断，需要一个双选择结构，所以就有了<code>if-else</code>结构。</p><img src="https://i.loli.net/2020/05/19/Ws7XgdF2jonTQfB.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为false将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####<code>if</code>多选择结构</p><p>我们发现不管是单选择结构，还是双选择结构都不符合实际情况，真实的情况还可能存在ABCD，存在区间多级判断。比如90-100就是A，80-90就是B..等等，在生活中我们很多时候的选择也不仅仅只有两个，所以我们需要一个多选择结构来处理这类问题！</p><img src="https://i.loli.net/2020/05/19/2NQ6qmIyFrUYE8i.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式2为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以上条件都不满足将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####嵌套的<code>if</code>结构 </p><p>使用嵌套的<code>if...else</code> 语句是合法的。也就是说你可以在另一个<code>if</code>或者<code>else if</code>语句中使用<code>if</code>或者<code>else if</code> 语句。你可以像<code>if</code>语句一样嵌套 <code>else if...else</code>。</p><p><strong>嵌套 if 语句</strong>，只有当外层 if 的条件成立时，才会判断内层 if 的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为true</span></span><br><span class="line">    <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//如果布尔表达式2为true将执行的语句</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果布尔表达式2为false将执行的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为false 将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swich多选择结构"><a href="#swich多选择结构" class="headerlink" title="swich多选择结构"></a><code>swich</code>多选择结构</h3><p>多选择结构还有一个实现方式就是<code>switch case</code> 语句。</p><p><code>switch case</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 语句中的变量类型可以是：</p><ul><li>byte、short、int 或者char。</li><li>从Java SE7开始，<code>switch</code> 支持字符串 String 类型了，同时 <code>case</code>标签必须为字符串常量或字面量。</li></ul><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只要布尔表达式为true，循环就会一直执行下去。</li><li><span style="color : red">大多数情况是需要让循环停下来的，我们可以以让表达式失效的方式来结束循环。</span></li><li>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</li><li>循环条件一直为true就会造成无限循环(死循环)，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死奔溃！</li></ul><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do...while循环"></a><code>do...while</code>循环</h3><p>对于while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p><code>do...while</code>循环和<code>while</code> 循环相似，不同的是，<code>do...while</code>循环至少会执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><p>While和do-While的区别：</p><ul><li><p><code>while</code>先判断后执行。<code>do…while</code>是先执行后判断！</p></li><li><p><code>do...while</code>总是保证循环体会被至少执行一次！这是他们的主要差别。</p></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><p>虽然所有循环结构都可以用 while或者do..while表示，但Java 提供了另一种语句-<code>for</code>循环，使一些循环结构变得更加简单。</p><p><span style="color:red">for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</span></p><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;迭代)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于for循环的几点说明：</p><ol><li><p>最先执行初始化步骤。可以声明一种类型，可初始化一个或多个循环控制变量，也可以是空语句。</p></li><li><p>然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</p></li><li><p>执行一次循环后，更新循环控制变量（送代因子控制循环变量的增减）。</p></li><li><p>再次检测布尔表达式。循环执行上面的过程。</p></li></ol></blockquote><h4 id="增强型for循环"><a href="#增强型for循环" class="headerlink" title="增强型for循环"></a>增强型<code>for</code>循环</h4><p>在java5中引入了一种主要用于数组或集合的增强型for循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p></li><li><p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ary = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;   <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="comment">//遍历数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : ary)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在任何循环语句的主体部分，均可用break控制循环的流程。break用于<span style="color:red">强行退出循环，不执行循环中剩余的语句。</span>(break语句也在switch语句中使用)</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 语句用在循环语句体中，用于<span style="color:red">终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</span></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java语法基础</title>
      <link href="/2020/05/16/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/05/16/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="注释、标识符，关键字"><a href="#注释、标识符，关键字" class="headerlink" title="注释、标识符，关键字"></a>注释、标识符，关键字</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><a id="more"></a><p>平时我们编写代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到注释了。</p><p>注释并不会被执行，是给写代码的人看的。</p><p><span style = color:red>写注释是一个很好的习惯</span></p><p><span style = color:red>写代码要注意规范</span></p><p>Java的注释有三种：单行注释；多行注释；文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaDoc:文档注释/** */</span></span><br><span class="line"><span class="comment">//javadoc命令是用来生成自己API文档的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  作者名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 版本号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 指明需要最早使用的jdk版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 参数名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 异常抛出情况</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>JavaDoc ，可通过终端命令生成Api文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charset UTF-8 *.java</span><br></pre></td></tr></table></figure><p>也可以通过Intellij IDEA生成，在工具栏中找到 <u>T</u>ools——&gt;Generate Java<u>D</u>oc…</p><p><img src="https://i.loli.net/2020/05/15/5FeQRjBkPAirSKs.png" alt=""></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://i.loli.net/2020/05/11/EjmKrwpXdu632gI.png" alt="Java关键字"></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><span style = color:red>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</span></p><p><code>标识符注意点：</code></p><ul><li>所有的标识符都应该以字母（A-z或者a-z），美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z或者a-z），美元符（$）、下划线（_）或数字的任何字符组合。</li><li><span style = color:red>不能使用关键字作为变量名或方法名。</span></li><li>标识符是<span style = color:red>大小写敏感</span>的</li><li><span style = color:red>可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low，不规范</span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合法标识符举例：age、$salary、value、_1_value</span></span><br><span class="line"><span class="comment">//非法标识符举例：123abc、-salary、#abc</span></span><br><span class="line"><span class="comment">//中文命名举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（string[]args）&#123;</span><br><span class="line">string 王者荣耀=<span class="string">"最强王者"</span>;</span><br><span class="line">    System.out.println(王者荣耀);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是强类型语言，要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用。</p><p><img src="https://i.loli.net/2020/05/11/NucZLt9mwnkRMyA.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八大基本数据类型</span></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> num3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">long</span> num3 = <span class="number">30L</span>;<span class="comment">//long类型要在数字后加个 L</span></span><br><span class="line"><span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="keyword">float</span> num5 = <span class="number">50.1F</span>;<span class="comment">//float类型要在数字后加个 F</span></span><br><span class="line"><span class="keyword">double</span> num6 = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="comment">//字符型</span></span><br><span class="line"><span class="keyword">char</span> name1 = <span class="string">'A'</span>;<span class="comment">//引号内只能有一个字符</span></span><br><span class="line"><span class="comment">//布尔值:只有是(true)、非(false) 两个值</span></span><br><span class="line"><span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>位（bit）：是计算机内部数据储存的最小单位，11001100是一个八位二进制数。</p><p>字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示，1B（byte，字节）=8bit（位）</p><p>字符：是指计算机中使用的字母、数字、字和符号</p><p>1bit表示1位，1Byte表示一个字节1B=8b。1024B=1KB，1024KB=1MB，1024MB=1GB…</p></blockquote><h3 id="数据类型拓展"><a href="#数据类型拓展" class="headerlink" title="数据类型拓展"></a>数据类型拓展</h3><h4 id="整数拓展"><a href="#整数拓展" class="headerlink" title="整数拓展"></a>整数拓展</h4><p>进制问题：</p><p>二进制 0b；十进制；八进制 0；十六进制 0x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0b10</span>;<span class="comment">//二进制输出2</span></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">10</span>;<span class="comment">//十进制输出10</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">010</span>;<span class="comment">//八进制输出8</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">0x10</span>;<span class="comment">//十六进制输出16</span></span><br></pre></td></tr></table></figure><h4 id="浮点数拓展"><a href="#浮点数拓展" class="headerlink" title="浮点数拓展"></a>浮点数拓展</h4><p>float和double类型，表现的长度是有限的，同时它也是离散的，它存在<code>舍入误差</code>的问题，他的结果是一个大约数，接近但不等于。</p><p><span style = color:red>尽量不要使用浮点数进行比较，尤其是在做涉及钱的业务时。</span></p><p>看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;<span class="comment">//0.1</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>/<span class="number">10</span>;<span class="comment">//0.1</span></span><br><span class="line">System.out.println(f==d);<span class="comment">//结果为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> d1 = <span class="number">2132154645646f</span>;</span><br><span class="line"><span class="keyword">float</span> d2 = d1 + <span class="number">1</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure><p>我们可以看出，浮点数是存在误差的。</p><p>Java中，我们可以用<code>BigDecimal</code>这个数学工具类来执行上述的操作。</p><h4 id="字符拓展"><a href="#字符拓展" class="headerlink" title="字符拓展"></a>字符拓展</h4><p>所有字符本质还是数字</p><p>编码： Unicode码   u0000-uFFFF —&gt;<code>UTF-8</code>，UTF-16，UTF-32</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符强制转换</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'中'</span>;</span><br><span class="line">System.out.println(c1);<span class="comment">//输出 a</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c1); <span class="comment">//强制转换 输出 97</span></span><br><span class="line">System.out.println(c2);<span class="comment">//输出 中</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c2); <span class="comment">//输出 20013</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'\u0061'</span>;<span class="comment">//十六进制</span></span><br><span class="line">System.out.println(c3);<span class="comment">//输出 a</span></span><br></pre></td></tr></table></figure><p>转义字符</p><table><thead><tr><th align="center">转义字符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">水平制表符</td></tr><tr><td align="center">\r</td><td align="center">回车，将当前位置移到本行开头</td></tr><tr><td align="center">\b</td><td align="center">退格，将当前位置移到前一列</td></tr><tr><td align="center">\f</td><td align="center">换页，将当前位置移到下页开头</td></tr><tr><td align="center">\\</td><td align="center">代表一个反斜线字符’’\‘</td></tr><tr><td align="center">\‘</td><td align="center">代表一个单引号（撇号）字符</td></tr><tr><td align="center">\“</td><td align="center">代表一个双引号字符</td></tr><tr><td align="center">\0</td><td align="center">空字符(NULL)</td></tr><tr><td align="center">\ddd</td><td align="center">1到3位八进制数所代表的任意字符 \000 ~ \377</td></tr><tr><td align="center">\uxxxx</td><td align="center">Unicode转义字符，\u + 四个十六进制数字所代表的字符 \u0000 ~ \uFFFF</td></tr></tbody></table><h4 id="布尔值拓展"><a href="#布尔值拓展" class="headerlink" title="布尔值拓展"></a>布尔值拓展</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//下面的方式是同样的效果，都表示当flag为真时，做什么</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)&#123;&#125;</span><br></pre></td></tr></table></figure><p><span style = color:red>Less is More,代码要精简易读</span></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低---------------------------------------&gt;高</span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br><span class="line">    <span class="comment">//浮点数优先级一定大于整数</span></span><br></pre></td></tr></table></figure><p>运算中，不同类型的数据先转换为同一类型，然后进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="comment">//强制类型转换  (类型)变量名高--&gt;低</span></span><br><span class="line"><span class="keyword">byte</span> b =(<span class="keyword">byte</span>)i;    <span class="comment">//byte类型范围为-128-127，转换后内存溢出</span></span><br><span class="line"><span class="comment">//自动类型转换  低--&gt;高</span></span><br><span class="line"><span class="keyword">double</span> d = i;</span><br><span class="line">System.out.println(i);<span class="comment">//输出 128</span></span><br><span class="line">System.out.println(b);<span class="comment">//输出 -128</span></span><br><span class="line">System.out.println(d);<span class="comment">//输出 128.0</span></span><br><span class="line"></span><br><span class="line">System.out.println((<span class="keyword">int</span>)<span class="number">23.7</span>);  <span class="comment">//输出23</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)-<span class="number">45.54f</span>);  <span class="comment">//输出 -45</span></span><br></pre></td></tr></table></figure><p><span style ="color:red"><b>注意:</b></span></p><ul><li>在类型转换时，要注意<span style="color:red">数据类型的取值范围，避免内存溢出</span>。</li><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>转换时还可能存在精度问题，比如将浮点数转换为int类型，会舍去小数部分。</li></ul><p><strong>操作比较大的数的时候，注意溢出问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7以后，数字之间可以用下划线分割，下划线并不会被打印出来</span></span><br><span class="line"><span class="keyword">int</span> money = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> total = money * year;  <span class="comment">//输出total的值为-1474836480。因为结果超出了int的范围，溢出</span></span><br><span class="line"><span class="keyword">long</span> total2 = money * year; </span><br><span class="line"><span class="comment">//输出total2的值为-1474836480。因为运算顺序是先计算等式右边的，再把结果转换为long类型赋值给total2，但转换之前的结果已经出问题了。</span></span><br><span class="line"><span class="keyword">long</span> total3 = money*((<span class="keyword">long</span>)year); </span><br><span class="line"><span class="comment">//这次total3的结果是正确的 先把一个数转换为long，这样等式右边计算时就是以long类型在计算，就不会发生溢出了</span></span><br></pre></td></tr></table></figure><h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量就是可以变化的量！</p><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和<span style ="color:red">作用域</span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type varNam [= value][&#123;,varName[= value],...&#125;];</span><br><span class="line"><span class="comment">//数据类型 变量名 = 值； 可以使用逗号隔开来声明多个同类型变量(不建议)。</span></span><br></pre></td></tr></table></figure><p><span style ="color:red"><strong>注意:</strong></span></p><ul><li><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</p></li><li><p>变量名必须是合法的标识符。</p></li><li><p>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p></li></ul><h4 id="类变量、实例变量、局部变量"><a href="#类变量、实例变量、局部变量" class="headerlink" title="类变量、实例变量、局部变量"></a>类变量、实例变量、局部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>;  <span class="comment">//类变量</span></span><br><span class="line">    String str = <span class="string">"hello world"</span>;  <span class="comment">//实例变量 从属于对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//局部变量，必须声明和初始化值，作用域仅限这个方法之内</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类变量：从属于类，作用域是在这个类内，随类一起出现，一起消失。</p><p>实例变量：从属于对象；如果不进行初始化,数值类型默认值为 0 | 0.0，char类型默认为一个空格，布尔类型默认值为false；除了基本类型，其余的默认都为 null。</p><p>局部变量，必须声明和初始化值，作用域仅限方法之内。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量(constant)：<span style="color:red">初识化(initialize)后不能再改变值！</span>不会变动的值。</p><p>所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</p><p>常量名一般使用大写字符表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><blockquote><p>说明：修饰符，不存在先后顺序， <code>final static double PI = 3.14</code>和<code>static final double PI = 3.14</code>是一样的。</p></blockquote><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul><li>所有变量、方法、类名：<span style="color:red"><strong>见名知意</strong></span></li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则：Man，GoodMan</li><li>方法名：首字母小写和驼峰原则：run()，runRun()</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java语言支持如下运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">算术运算符: +,-,*,/,%,++,--</span><br><span class="line">赋值运算符: =</span><br><span class="line">关系运算符: &gt;,&lt;,&gt;=,&lt;=,==,!=,<span class="keyword">instanceof</span></span><br><span class="line">逻辑运算符: &amp;&amp;,||,!</span><br><span class="line">位运算符:   &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class="line">条件运算符: ? :</span><br><span class="line">扩展赋值运算符：+=,-=,*=,/=</span><br></pre></td></tr></table></figure><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><h4 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(加),-(减),*(乘),/(除),%(模，取余)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低---------------------------------------&gt;高</span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>不同类型相互运算时，结果的类型总是与要计算的数中优先级最高的那个数的类型保持一致，但最低为int，即当只有short、byte、char相互运算时，结果仍为int类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">123.123</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">123.123F</span>;</span><br><span class="line">        <span class="keyword">long</span> c = <span class="number">123123123123123L</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">short</span> e = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> f =<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(getType(a+b+c+d+e+f+g)); <span class="comment">//double类型</span></span><br><span class="line">        System.out.println(getType(b+c+d+e+f+g));   <span class="comment">//float类型</span></span><br><span class="line">        System.out.println(getType(c+d+e+f+g));     <span class="comment">//long类型</span></span><br><span class="line">        System.out.println(getType(d+e+f+g));       <span class="comment">//int</span></span><br><span class="line">        System.out.println(getType(e+f+g));         <span class="comment">//int</span></span><br><span class="line">        System.out.println(getType(f+g));           <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取变量类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ++  --   自增，自减   一元运算符</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//后置自增,执行这行代码时,先将a的值赋给b,a再自增</span></span><br><span class="line">System.out.println(a);  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c = ++a;<span class="comment">//前置自增,执行这行代码时,先将a自增,再将自增后的结果赋给c</span></span><br><span class="line">System.out.println(a);  <span class="comment">//5</span></span><br><span class="line">System.out.println(b);  <span class="comment">//3</span></span><br><span class="line">System.out.println(c);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符计算后返回的结果是<code>布尔值</code>，常与<code>if</code>判断语句结合使用。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;&amp;(与),||(或),!(非)</span></span><br><span class="line"><span class="comment">//逻辑与运算：两个变量都为真，结果才为true</span></span><br><span class="line"><span class="comment">//逻辑或运算：两个变量有一个为真，则结果才为true</span></span><br><span class="line"><span class="comment">//非：如果是真则变为假，如果是假则变为真</span></span><br><span class="line"><span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(a&amp;&amp;b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a||b);<span class="comment">//true</span></span><br><span class="line">System.out.println(!(a&amp;&amp;b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//短路运算</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">boolean</span> d = (c &lt; <span class="number">4</span>)&amp;&amp;(c++ &lt; <span class="number">4</span>); <span class="comment">//如果&amp;&amp;前面的为false，则后面的不会被运算</span></span><br><span class="line">System.out.println(c);  <span class="comment">//5，说明c++没有被运算</span></span><br><span class="line">System.out.println(d);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A和B都是二进制数</span><br><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">1100</span>按位与：都为<span class="number">1</span>时为<span class="number">1</span>，其他情况为<span class="number">0</span></span><br><span class="line">A|B = <span class="number">0011</span> <span class="number">1101</span>按位或：都为<span class="number">0</span>时为<span class="number">0</span>，其他情况为<span class="number">1</span></span><br><span class="line">A^B = <span class="number">0011</span> <span class="number">0001</span>按位异或：相同为<span class="number">0</span>，不同为<span class="number">1</span></span><br><span class="line">~B = <span class="number">1111</span> <span class="number">0010</span>按位取反</span><br><span class="line">_________________________________________________</span><br><span class="line"></span><br><span class="line">&lt;&lt;：左移，每移一位相当于乘以<span class="number">2</span></span><br><span class="line">&gt;&gt;：右移，每移一位相当于除以<span class="number">2</span></span><br><span class="line">如 <span class="number">2</span>&lt;&lt;<span class="number">3</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>位运算由于是操作二进制数，所以效率极高。</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>看下面例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a += b;<span class="comment">//就相当于 a=a+b</span></span><br><span class="line">a -= b;<span class="comment">//就相当于 a=a-b</span></span><br><span class="line"><span class="comment">// 同样*=、/=也是这样的</span></span><br></pre></td></tr></table></figure><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件运算符是三元运算符</span><br><span class="line">x ? y : z</span><br><span class="line">如果x为真，则结果为有，否则结果为z</span><br></pre></td></tr></table></figure><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>()、[]、{}</td><td>从左向右</td></tr><tr><td>2</td><td>!、+、-、~、++、–</td><td>从右向左</td></tr><tr><td>3</td><td>*、/、%</td><td>从左向右</td></tr><tr><td>4</td><td>+、-</td><td>从左向右</td></tr><tr><td>5</td><td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><td>从左向右</td></tr><tr><td>7</td><td>==、!=</td><td>从左向右</td></tr><tr><td>8</td><td>&amp;</td><td>从左向右</td></tr><tr><td>9</td><td>^</td><td>从左向右</td></tr><tr><td>10</td><td>|</td><td>从左向右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>12</td><td>||</td><td>从左向右</td></tr><tr><td>13</td><td>? :</td><td>从右向左</td></tr><tr><td>14</td><td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td><td>从右向左</td></tr></tbody></table><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li><p>字符串连接符    +</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">"引号在前面"</span>+a+b);<span class="comment">// 输出 引号在前面1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">"引号在后面"</span>);<span class="comment">// 输出 30引号在后面</span></span><br></pre></td></tr></table></figure></li></ol><p>可见，如果字符串在前面，则它后面连接的内容不会进行运算，如果字符串在后面，则它前面连接的内容会进行运算。</p><ol start="2"><li><p>很多运算，我们需要一些工具类来操作！如下代码用<code>Math</code>类进行幂运算。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> power = Math.pow(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//2的3次方，8.0</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p><p>包语句的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[. pkg2[. pkg3...]];</span><br></pre></td></tr></table></figure><p><span style="color:red">一般利用公司域名倒置作为包名</span></p><p>为了能够使用某一个包的成员，我们需要在Java 程序中明确导入该包。使用<code>import</code>语句可完成此功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(classname|*);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识Java</title>
      <link href="/2020/05/16/%E5%88%9D%E8%AF%86Java/"/>
      <url>/2020/05/16/%E5%88%9D%E8%AF%86Java/</url>
      
        <content type="html"><![CDATA[<h2 id="java帝国的建立"><a href="#java帝国的建立" class="headerlink" title="java帝国的建立"></a>java帝国的建立</h2><p>1972 年C语言诞生 ，C语言具有贴近硬件，运行速度极快，效率极高的优点，一经诞生，就广泛用于操作系统、编译器、数据库、网络系统等的开发。但由于C语言的指针问题和内存管理的问题，对新手有一些不太友好。</p><a id="more"></a><p>1982年C++诞生，C++兼容C语言，它增加了面向对象的特性，在图形领域和游戏方面取得了一些成就。但C++更加复杂。</p><p>1995年，java诞生，它语法有些像C，但没有C中的指针和内存管理问题；它实现了真正的可移植性，编写一次，到处运行；它也有面向对象的特性，有更安全的类型，有高质量的类库等优点。</p><h3 id="java的发展"><a href="#java的发展" class="headerlink" title="java的发展"></a>java的发展</h3><p>1995年的网页简单而粗糙，缺乏互动性。java团队在浏览器中放入了java的运行环境，开发了一个图形界面程序(Applet)，使得网页变得更美观，有互动性。java进入了广大程序员的视线。</p><p>1998年，java 发布java2版本，该版本包含三个方向：</p><p>Java 2 标准版（J2SE）    针对桌面端开发</p><p>Java 2 移动版（J2ME）    针对移动端开发</p><p>Java 2 企业版（J2EE）     针对服务器端开发</p><p> 但是Java SE 和Java ME当时并没有得到很好的发展。反而Java EE得到了很多IT大公司的应用 ，他们基于Java开发了许多的平台、系统、工具：</p><ul><li>构建工具：Ant，Maven，Jekins</li><li>应用服务器：Tomcat，Jetty，Jboss，Websphere，weblogic</li><li>Web开发：Struts，Spring，Hibernate，myBatis</li><li>开发工具：Eclipse，Netbean，intellij idea，Jbuilder</li><li>……</li></ul><p>2006年，Hadoop的发布让Java进入大数据领域</p><p>2008年，Android的诞生，让Java重新进入了移动端领域，并在移动端开发中占据了举足轻重的地位。</p><p>之后，Java的发展就一发不可收拾，占据了服务器端开发的大部分市场，一个伟大的帝国诞生了！！</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拓展：</span><br><span class="line">“三高”问题：高可用，高性能，高并发。</span><br></pre></td></tr></table></figure><h2 id="Java的特性和优势"><a href="#Java的特性和优势" class="headerlink" title="Java的特性和优势"></a>Java的特性和优势</h2><ul><li>简单性</li><li>面向对象</li><li>跨平台 可移植性</li><li>高性能</li><li>分布式</li><li>动态性（反射机制）</li><li>多线程</li><li>安全性</li><li>健壮性</li></ul><h2 id="Java-的三大版本"><a href="#Java-的三大版本" class="headerlink" title="Java 的三大版本"></a>Java 的三大版本</h2><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><p>标准版（桌面程序，控制台开发…）</p><h3 id="JavaME"><a href="#JavaME" class="headerlink" title="JavaME"></a>JavaME</h3><p>嵌入式开发（手机，小家电…）</p><p>该版本几乎已经没有人用了</p><h3 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h3><p>企业级开发（web端，服务器开发…）</p><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><p>JDK：Java Development Kit，称为Java开发包或者Java开发者工具，是一个编写Java的Applet小程序和应用程序的开发环境。JDK是整个Java的核心，包括了<code>Java运行环境(JRE)</code>，一些<code>Java工具</code>和<code>Java的核心类库(Java API)</code>。</p><p>JRE：Java Runtime Environment。JRE是个运行环境，JDK是个开发环境。因此写Java程序时需要JDK，而运行Java程序时就需要JRE。而JDK中已经包含了JRE，因此只要安装了JDK就可以编辑Java程序，也可以正常运行Java程序。</p><p>JVM：Java Virtual Machine</p><p><img src="https://i.loli.net/2020/05/09/h5MHDELCjmzKvcY.png" alt=""></p><h2 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h2><p><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></p><p>去上面网址下载对应的版本</p><p>下载后双击安装，记住安装的路径</p><p><strong>配置环境变量</strong></p><p>右键点击此电脑，打开属性，找到高级系统设置-&gt;环境变量-&gt;系统变量</p><ol><li>新建一个变量JAVA_HOME，值为jdk安装的路径</li></ol><p><img src="https://i.loli.net/2020/05/09/dF2PvYc5eJ8H9nD.png" alt=""></p><ol start="2"><li>配置Path变量，找到系统变量中的Path变量，点击编辑，新建两个，值分别为<code>%JAVA_HOME%\bin</code>，<code>%JAVA_HOME%\jre\bin</code></li></ol><p><img src="https://i.loli.net/2020/05/09/uaRCMe71En3XG9V.png" alt=""></p><p>配置好环境变量之后，打开cmd(终端)，输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>出现下图效果说明JDK安装配置成功</p><p><img src="https://i.loli.net/2020/05/09/hTROlwQ7uWEyVaJ.png" alt=""></p><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p><strong>HelloWorld</strong></p><p>步骤：</p><ol><li>新建一个文件夹，存放代码</li><li>新建一个Java文件(Hello.java)</li><li>编写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>编译 ，打开终端，输入命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -Hello.java</span><br></pre></td></tr></table></figure><p> 编译完成后生成一个Hello.class文件，再输入运行命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Hello</span><br></pre></td></tr></table></figure><p> 就能看到终端中打印出了 <code>Hello,World!</code></p></li></ol><p><img src="https://i.loli.net/2020/05/09/oLXTjy8ECYeFV25.png" alt=""></p><p><strong>可能遇到的问题</strong></p><ul><li>每个单词的大小写不能出现问题，<strong>Java对大小写敏感</strong></li><li>文件名 和 类名必须保持一致，并且首字母大写</li><li>符号要用英状态下的符号</li></ul><h2 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h2><h3 id="编译型与解释型"><a href="#编译型与解释型" class="headerlink" title="编译型与解释型"></a>编译型与解释型</h3><p>我们知道，计算机是无法理解现在的高级语言程序的，计算机只能理解机器语言，也就是可以通过CPU进行分析和执行的指令集。而要想让计算机能够运行我们写的高级语言程序，就需要一个系统软件来实现，它就是<strong><code>语言处理程序</code></strong>，也称为<strong><code>编译程序</code></strong>，它可以将我们写的高级语言程序，翻译成计算机可执行的<strong><code>机器语言</code></strong>。而这个翻译的方式就分为<strong><code>编译型</code></strong>和<strong><code>解释性</code></strong>两种。</p><p><strong><code>编译型：</code></strong>是有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码(机器码),这个过程就被称为编译,而来编译的程序也就被称为编译器,也就是说我们写一个程序代码在源文件当中,通常经过编译以后生成一个可执行文件,这样我们就可以直接运行了。</p><p><strong><code>解释型：</code></strong>在程序运行的前一刻，还只有源程序没有可执行程序,而当执行时每执行到源程序的某一条指令，则会有有一个称为解释程序的外壳程序将源代码转换成二进制代码以供执行,也就是说一边解释 一边执行 ,所以解释型程序是离不开解释程序的。</p><p>从上面我们可以看出，编译型和解释型的关键区别就在于这个翻译的时机不同。解释型语言在运行程序的时候才翻译,每执行一次,要翻译一次,效率较低。编译型就是直接编译成机器可以执行的格式,只翻译一次。</p><p>编译型和解释型各有优缺点</p><p>优点:</p><p>解释型:可移植性好,只要有运行相应需要的解释环境,可以在不用的操作系统上运行,修改调试也非常方便</p><p>编译型:相比解释执行编译执行效率高，占用资源小，适合复杂程序</p><p>缺点:</p><p>解释型:一句一句执行解释,浪费计算机资源,效率低</p><p>编译型:兼容性差,编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译.</p><h3 id="Java程序运行机制-1"><a href="#Java程序运行机制-1" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h3><p><strong>Java这个语言有些特殊，它既是编译型的，又是解释型的</strong></p><p>说Java是编译型的，是因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。</p><p>说Java是解释型的，是因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释型的了。 </p><p>但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。像C、C++ 他们经过一次编译之后直接可以编译成操作系统了解的类型，可以直接执行的 所以他们是编译型的语言。没有经过第二次的处理 而Java不一样，他首先由编译器编译成.class类型的文件，这个是Java自己类型的文件 ，然后再通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，而由于Java对于多种不同的操作系统有不同的JVM所以 Java实现了真正意义上的跨平台！</p><p>观看下面两张图 了解一下Java的虚拟机机制：</p><blockquote><p>1.java语言的编译–&gt;解释—&gt;执行过程</p><p><img src="https://i.loli.net/2020/05/10/HtRmwf4LBIr1qPS.jpg" alt="java语言的编译--&gt;解释---&gt;执行过程"></p></blockquote><p><img src="https://i.loli.net/2020/05/10/ITZEnaNuweHiflQ.jpg" alt="java虚拟机JVM"></p><blockquote><p>如果严格按照定义来说，Java应该是解释型语言，因为<em>.java程序在编译之后，被编译为\</em>.class文件，并不是机器码，依然不能被计算机直接运行。*.class文件是在JVM中被解释运行的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机硬件核心基础</title>
      <link href="/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来了解一些基本概念：</p><p><strong><code>编程语言</code></strong>本质是一门语言，语言就是一种事物与另外一种事物沟通的表达方式/工具，那么编程语言就是<strong>人</strong>与<strong>计算机</strong>之间沟通的方式。</p><a id="more"></a><p><strong><code>编程</code></strong>就是人类把自己想让计算机做的事，也就是自己的思维逻辑，用编程语言表达出来。</p><p><strong><code>编程的目的</code></strong>就是让计算机按照人类的思维逻辑去工作，从而解放人力。</p><p><img src="https://i.loli.net/2020/05/07/hg3NOqwCmSMkfGj.jpg" alt="1"></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><blockquote><p><img src="https://i.loli.net/2020/05/16/Hr8qJpKlM3tcuIi.jpg" alt="简单计算机组件"></p></blockquote><h3 id="计算机五大组成部分"><a href="#计算机五大组成部分" class="headerlink" title="计算机五大组成部分"></a>计算机五大组成部分</h3><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a><strong><code>控制器</code></strong></h4><p><strong>控制器</strong>是计算机的指挥系统。控制器通过地址访问存储器，从存储器中取出指令，经译码器分析后，根据指令分析结果产生相应的操作控制信号作用于其他部件，使得各部件在控制器控制下有条不紊地协调工作。</p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a><strong><code>运算器</code></strong></h4><p><strong>运算器</strong>是实现算术运算和逻辑运算的部件。</p><p><strong><code>控制器 + 运算器 = CPU</code></strong> </p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a><strong><code>存储器</code></strong></h4><p><strong>存储器</strong>是计算机用来存放所有数据和程序的记忆部件。它的基本功能是按指定的地址存（写）入或者取（读）出信息。 </p><p>计算机中的存储器可分成两大类：一类是内存储器，简称<strong>内存或主存</strong>；另一类是外存储器(辅助存储器)，简称<strong>外存或辅存</strong>。 存储器由若干个存储单元组成，每个存储单元都有一个地址，计算机通过地址对存储单元进行读写。一个存储器所包含的字节数称为<strong>存储容量</strong>，单位有B、KB、MB、GB、TB等。</p><ul><li><p><strong>内存:</strong> 存取数据快；断电数据丢失，只能临时存取数据。</p></li><li><p><strong>外存:</strong>存取数据慢；断电数据不会丢失，用来永久保存数据 。</p><p>  内存的存取速度要远高于外存。</p></li></ul><h4 id="输入设备input"><a href="#输入设备input" class="headerlink" title="输入设备input"></a><strong><code>输入设备input</code></strong></h4><p><strong>输入设备</strong>是计算接收外界输入数据的工具，如键盘、鼠标。</p><h4 id="输出设备output"><a href="#输出设备output" class="headerlink" title="输出设备output"></a><strong><code>输出设备output</code></strong></h4><p><strong>输出设备</strong>是计算机向外输出数据的工具，如显示器、打印机。</p><p>存储器如内存、磁盘等既是输入设备又是输出设备，统称为IO设备</p><blockquote><p><img src="https://i.loli.net/2020/05/16/4aDRbLGvfy7wrAs.png" alt="img"></p></blockquote><p>CPU存取的数据和指令都来自主存储器(内存) 。</p><p>内存称之为主存，主存储器内的数据则是从输入单元所传输进来！而CPU处理完毕的数据也必须先写回主存储器中，最后数据才从主存储器传输到输出单元。</p><h3 id="程序运行与三大核心硬件-CPU-内存-硬盘-的关系"><a href="#程序运行与三大核心硬件-CPU-内存-硬盘-的关系" class="headerlink" title="程序运行与三大核心硬件(CPU 内存 硬盘)的关系"></a>程序运行与三大核心硬件(CPU 内存 硬盘)的关系</h3><p>我们编写的程序一定是要运行于计算机硬件之上，而站在硬件的角度，与运行程序有关的三大核心硬件为CPU、内存、硬盘。</p><p>程序最先是存放于硬盘中的，程序的运行是先从硬盘把代码加载到内存中，然后CPU是从内存中读取指令运行。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的由来"><a href="#操作系统的由来" class="headerlink" title="操作系统的由来"></a>操作系统的由来</h3><p>大前提：我们编程目的就是为了奴役计算机，让计算机硬件自发地运行起来，然而硬件毕竟是”死的“，<strong>硬件的运行都是由软件支配</strong>。</p><p>倘若我们要开发一个应用程序，在没有操作系统之前，开发者在编写业务逻辑之前，必须先编写一套完整的控制程序来控制所有的硬件基本运行(这要求开发者需要详细了解计算机硬件的各种控制细节，例如要熟悉CPU里面所有的指令集)，如此，所有开发者在开发程序时都必须按以下两个步骤：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.编写一套完整的的控制程序，用来控制硬件的基本运行，以及把复杂的硬件的操作封装成简单的接口</span><br><span class="line">2.基于控制程序的接口开发包含一系列业务逻辑的程序，为了与控制程序区分，可以称为应用程序.</span><br></pre></td></tr></table></figure><p>综上，对于不同的应用程序来说，应用程序的业务逻辑各不相同，但硬件的控制程序都大致相同，为了避免所有开发者做重复劳动，以及不用再耗费精力去了解所有硬件的运行细节，有公司专门跳出来承担起控制程序的开发任务，这里所说的控制程序指的就是操作系统。</p><p><strong><code>操作系统</code></strong>是一个协调、管理、控制计算机硬件资源与应用软件资源的控制程序。它位于计算机硬件与应用软件之间，起承上启下的作用。</p><p><strong>操作系统的功能:</strong> </p><ul><li><p>控制计算机硬件的基本运行</p></li><li><p>帮我们把复杂的硬件的控制封装成简单的接口，对于开发应用程序来说只需要调用操作系统提供给我们的接口即可</p></li></ul><h3 id="系统软件与应用软件"><a href="#系统软件与应用软件" class="headerlink" title="系统软件与应用软件"></a>系统软件与应用软件</h3><ul><li><p>系统软件：</p><p>  指控制和协调计算机及外部设备、支持应用软件开发和运行的系统，是无需用户干预的各种程序的集合，主要功能是调度、监控和维护计算机系统；负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。</p><p>  一般来讲，系统软件包括操作系统和一系列基本的工具（比如编译器，数据库管理，存储器格式化，文件系统管理，用户身份验证，驱动管理，网络连接等方面的工具），是支持计算机系统正常运行并实现用户操作的那部分软件。</p></li><li><p>应用软件：</p><p>  应用软件(Application）是和系统软件相对应的，是用户可以使用的各种程序设计语言，以及用各种程序设计语言编制的应用程序的集合，分为应用软件包和用户程序。应用软件包是利用计算机解决某类问题而设计的程序的集合，多供用户使用。</p><p>  应用软件是为满足用户不同领域、不同问题的应用需求而提供的那部分软件。 它可以拓宽计算机系统的应用领域，放大硬件的功能。</p></li></ul><h3 id="计算机系统三层结构"><a href="#计算机系统三层结构" class="headerlink" title="计算机系统三层结构"></a>计算机系统三层结构</h3><p>我们开发应用程序本质是在控制硬件，但是我们直接打交道的是操作系统，应用程序都是通过操作系统来间接地操作硬件的，所以一套完整的计算机系统分为三层，如下：</p><blockquote><p><img src="https://i.loli.net/2020/04/20/nrdy8V6NIoPLhiD.jpg" alt="计算机系统三层结构"></p></blockquote><h3 id="平台与跨平台的概念"><a href="#平台与跨平台的概念" class="headerlink" title="平台与跨平台的概念"></a>平台与跨平台的概念</h3><p>应用程序都是运行于操作系统之上，而操作系统则是运行于硬件之上的，所以承载应用程序的是一台运行有操作系统的计算机，称之为应用程序的运行平台，即：<strong><code>硬件 + 操作系统 = 平台</code></strong>。</p><blockquote><p><img src="https://i.loli.net/2020/04/20/iBWhvPRqGZ14ry5.jpg" alt="平台"></p></blockquote><p>常见的平台有：windows系统+某款硬件、linux系统+某款硬件、ubuntu+某款硬件等，我们在开发应用程序时就需要考虑到应用程序的<strong>跨平台</strong>性，如果能开发出一款可以在任意平台运行的应用程序，那对于开发者来说真是极大的福音。</p><p>跨平台即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。而决定应用软件的跨平台性的关键因素往往是编程语言的选择,一般解释型语言(即不需编译的语言，比如：PHP、Python等)都可跨平台运行；有些编译型语言(如：Java等)由于其本身的特性(不同平台有不同的库、具有跨平台的扩展以及中间件)，也可跨平台运行。</p><h2 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h2><h3 id="CPU详解"><a href="#CPU详解" class="headerlink" title="CPU详解"></a>CPU详解</h3><h4 id="CPU的分类与指令集"><a href="#CPU的分类与指令集" class="headerlink" title="CPU的分类与指令集"></a>CPU的分类与指令集</h4><p>CPU内部是含有微指令集的，我们所使用的的软件都要经过CPU内部的微指令集来完成才行。这些指令集的设计主要又被分为两种设计理念，这就是目前世界上常见到的两种主要的CPU种类：分别是精简指令集（RISC）与复杂指令集（CISC）系统。下面我们就来谈谈这两种不同CPU种类的差异！</p><p>1.<strong><code>精简指令集</code></strong></p><p>精简指令集(Reduced Instruction Set Computing，RISC)：这种CPU的设计中，微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的RISC指令集CPU主要例如Sun公司的SPARC系列、IBM公司的Power Architecture（包括PowerPC）系列、与ARM系列等。【注：Sun已经被Oracle收购】</p><p>SPARC架构的计算机常用于学术领域的大型工作站中，包括银行金融体系的主服务器也都有这类的计算机架构；</p><p>PowerPC架构的应用，如Sony出产的Play Station 3（PS3）使用的就是该架构的Cell处理器。</p><p>ARM是世界上使用范围最广的CPU，常用的各厂商的手机、PDA、导航系统、网络设备等，几乎都用该架构的CPU。</p><p>2.<strong><code>复杂指令集</code></strong></p><p>复杂指令集（Complex Instruction Set Computer，CISC）与RISC不同，在CISC的微指令集中，每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因此指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。</p><p>总结：</p><p>CPU按照指令集可以分为精简指令集CPU和复杂指令集CPU两种，区别在于前者的指令集精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。后者的指令集每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。</p><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h4><p><strong><code>x86架构</code></strong></p><p>x86是针对cpu的型号或者说架构的一种统称，详细地讲，最早的那颗Intel发明出来的CPU代号称为8086，后来在8086的基础上又开发出了80285、80386….，因此这种架构的CPU就被统称为x86架构了。</p><p>由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人计算机上面，因此，个人计算机常被称为x86架构的计算机！</p><p>程序员开发出的软件最终都要翻译成cpu的指令集才能运行，因此软件的版本必须与cpu的架构契合，举个例子，我们在MySQL官网下载软件MySQL时名字为：<code>Windows(x86,32-bit),ZIP Archive (mysql-5.7.20-win32.zip)</code>我们发现名字中有x86，这其实就是告诉我们：该软件应该运行在x86架构的计算机上。</p><p><strong><code>64位</code></strong></p><p>cpu的位数指的是cpu一次性能从内存中取出多少位二进制指令，64bit指的是一次性能从内存中取出64位二进制指令。</p><p>在2003年以前由Intel所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64位，到现在，个人计算机CPU通常都是x86_64的架构。</p><p>cpu具有向下兼容性，指的是64位的cpu既可以运行64位的软件，也可以运行32位的软件，而32位的cpu只能运行32位的软件。这其实很好理解，如果把cpu的位数当成是车道的宽，而内存中软件的指令当做是待通行的车辆，宽64的车道每次肯定既可以通行64辆车，也可以通信32辆车，而宽32的车道每次却只能通行32辆车</p><h4 id="运算器与控制器"><a href="#运算器与控制器" class="headerlink" title="运算器与控制器"></a>运算器与控制器</h4><p>常将运算器和控制器合称为中央处理器(Central Processing Unit，CPU)。其中运算器用来主要负责程序运算与逻辑判断，控制器则主要协调各组件和各单元的工作，所以CPU的工作主要在于管理和运算。可以说计算机的大脑就是CPU。</p><p><strong><code>1.运算器</code></strong></p><p>运算器是对信息进行处理和运算的部件。经常进行的运算是算术运算和逻辑运算，所以运算器又可称为算术逻辑运算部件（Arithmetic and Logical，ALU）。</p><p>运算器的核心是加法器。运算器中还有若干个通用寄存器或累加寄存器，用来暂存操作数并存放运算结果。寄存器的存取速度比存储器的存放速度快很多。</p><p><strong><code>2.控制器</code></strong></p><p>控制器是整个计算机的指挥中心，它的主要功能是按照人们预先确定的操作步骤，控制整个计算机的各部件有条不紊的自动工作。</p><p>控制器从主存中逐条地读取出指令进行分析，根据指令的不同来安排操作顺序，向各部件发出相应的操作信号，控制它们执行指令所规定的任务。控制器中包括一些专用的寄存器。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器是中央处理器内的组成部份。它跟CPU有关。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p><blockquote><p><img src="https://i.loli.net/2020/05/16/l1qb8EsJoZPtx4m.jpg" alt="img"></p></blockquote><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><p>除了在嵌入式系统中的非常简单的CPU(如:单片机)之外，多数CPU都有两种模式，即<strong><code>内核态与用户态</code></strong>。</p><p>通常，计算机由<a href="https://baike.baidu.com/item/PSW/1878339?fr=aladdin" target="_blank" rel="noopener">PSW</a>(程序状态寄存器)控制这两种模式。</p><p><strong><code>内核态：</code></strong>当cpu在内核态运行时，cpu可以执行指令集中所有的指令，很明显，所有的指令中包含了使用硬件的所有功能，（操作系统在内核态下运行，从而可以访问整个硬件）</p><p><strong><code>用户态：</code></strong>用户程序在用户态下运行，仅仅只能执行cpu整个指令集的一个子集，该子集中不包含操作硬件功能的部分，因此，一般情况下，在用户态中有关I/O和内存保护（操作系统占用的内存是受保护的，不能被别的程序占用），当然，在用户态下，将PSW中的模式设置成内核态也是禁止的。</p><p><strong><code>内核态与用户态切换:</code></strong><br>        用户态下工作的软件不能操作硬件，但是我们的软件一定会有操作硬件的需求，比如从磁盘上读一个文件，那就必须经历从用户态切换到内核态的过程，为此，用户程序必须使用<a href="https://baike.baidu.com/item/系统调用/861110" target="_blank" rel="noopener">系统调用(system call)</a>，通过相应的指令把用户态切换成内核态。</p><p>把系统调用看成一个特别的过程调用指令就可以了，该指令具有从用户态切换到内核态的特别能力。</p><h4 id="多线程与多核芯片"><a href="#多线程与多核芯片" class="headerlink" title="多线程与多核芯片"></a>多线程与多核芯片</h4><p>在一个CPU中增加多个处理逻辑，称为多线程或超线程，该概念是由Inter公司首次提出。</p><p>多核就是多个完整的CPU处理器。</p><p>比如，我们常说的四核八线程，就是指有四个CPU,每个CPU中有两个线程。</p><blockquote><img src="https://i.loli.net/2020/05/03/L4eNdiVUZ3AYOgs.png" alt="1" style="zoom: 80%;" /><img src="https://i.loli.net/2020/05/03/Ix8Ogqi9DKUa36H.png" alt="2" style="zoom:80%;" /></blockquote><h3 id="存储器相关"><a href="#存储器相关" class="headerlink" title="存储器相关"></a>存储器相关</h3><blockquote><p><img src="https://i.loli.net/2020/05/16/Ko49glFa7BZUNXV.jpg" alt="存储层次结构"></p></blockquote><p>存储器系统采用如上图的分层结构，顶层的存储器速度较高，容量较小，与底层的存储器相比每位的成本较高，其差别往往是十亿数量级的。</p><h4 id="寄存器即L1缓存"><a href="#寄存器即L1缓存" class="headerlink" title="寄存器即L1缓存"></a>寄存器即L1缓存</h4><p>用与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延，典型容量是：在32位cpu中为32*32，在64位cpu中为64*64，在两种情况下容量均小于1KB。</p><h4 id="高速缓存即L2缓存"><a href="#高速缓存即L2缓存" class="headerlink" title="高速缓存即L2缓存"></a>高速缓存即L2缓存</h4><p>主要由硬件控制高速缓存的存取，内存中有高速缓存行按照0~64字节为行0，64~127为行1…</p><p>最常用的高速缓存行放置在cpu内部或者非常接近cpu的高速缓存中。当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。如果是，则称为<strong>高速缓存命中</strong>，缓存满足了请求，就不需要通过总线把访问请求送往主存(内存)，这毕竟是慢的。高速缓存的命中通常需要两个时钟周期。<strong>高速缓存未命中</strong>，就必须访问内存，这需要付出大量的时间代价。由于高速缓存价格昂贵，所以其大小有限，有些机器具有两级甚至三级高速缓存，每一级高速缓存比前一级慢但是容量大。</p><p>缓存在计算机科学的许多领域中起着重要的作用，并不仅仅只是RAM（随机存取存储器）的缓存行。只要存在大量的资源可以划分为小的部分，那么这些资源中的某些部分肯定会比其他部分更频发地得到使用，此时用缓存可以带来性能上的提升。一个典型的例子就是操作系统一直在使用缓存，比如，多数操作系统在内存中保留频繁使用的文件（的一部分），以避免从磁盘中重复地调用这些文件，类似的/root/a/b/c/d/e/f/a.txt的长路径名转换成该文件所在的磁盘地址的结果然后放入缓存，可以避免重复寻找地址，还有一个web页面的url地址转换为网络地址(IP)地址后，这个转换结果也可以缓存起来供将来使用。</p><p>缓存是一个好方法，在现代cpu中设计了两个缓存，再看3.1.5中的两种cpu设计图。第一级缓存称为L1总是在CPU中，通常用来将已经解码的指令调入cpu的执行引擎，对那些频繁使用的数据字，多数芯片还会安装第二L1缓存 … 另外往往设计有二级缓存L2，用来存放近来经常使用的内存字。L1与L2的差别在于对cpu对L1的访问无时间延迟，而对L2的访问则有1-2个时钟周期（即1-2ns）的延迟。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>再往下一层是主存，此乃存储器系统的主力，主存通常称为<strong>随机访问存储(可读可写)<code>RAM</code></strong>，就是我们通常所说的内存，容量一直在不断攀升，所有不能再高速缓存中找到的，都会到主存中找，<strong>主存是易失性存储，断电后数据全部消失</strong>。</p><p>除了主存RAM之外，许多计算机已经在使用少量的<strong>非易失性随机访问存储如<code>ROM</code>(Read Only Memory)</strong>，在电源切断之后，非易失性存储的内容并不会丢失，ROM只读存储器在工厂中就被编程完毕，然后再也不能修改。ROM速度快且便宜，在有些计算机中，用于启动计算机的引导加载模块(BIOS)就存放在ROM中，另外一些I/O卡也采用ROM处理底层设备的控制。 </p><p><strong><code>EEPROM</code>（Electrically Erasable PROM，电可擦除可编程ROM）和<code>闪存</code>（flash memory）也是非易失性的</strong>，但是与ROM相反，他们可以擦除和重写。不过重写时花费的时间比写入RAM要多。在便携式电子设备中中，闪存通常作为存储媒介。闪存是数码相机中的胶卷，是便携式音译播放器的磁盘，还应用于固态硬盘。闪存在速度上介于RAM和磁盘之间，但与磁盘不同的是，闪存擦除的次数过多，就被磨损了。</p><p>还有一类存储器就是<strong><code>CMOS</code>，它是易失性的</strong>，许多计算机利用CMOS存储器来<strong>保持当前时间和日期</strong>。CMOS存储器和递增时间的电路由一小块<strong>电池驱动</strong>，所以，即使计算机没有加电，时间也仍然可以正确地更新，除此之外<strong>CMOS还可以保存配置的参数，比如，哪一个是启动磁盘等</strong>，之所以采用CMOS是因为它耗电非常少，一块工厂原装电池往往能使用若干年，但是当电池失效时，相关的配置和时间等都将丢失</p><h4 id="硬盘（磁盘-机械硬盘）"><a href="#硬盘（磁盘-机械硬盘）" class="headerlink" title="硬盘（磁盘/机械硬盘）"></a>硬盘（磁盘/机械硬盘）</h4><blockquote><p><img src="https://i.loli.net/2020/05/03/17kJ8TzIfXl4rix.png" alt="3"></p><img src="https://i.loli.net/2020/05/03/cNI7GgKnPJVzvMS.png" alt="4" style="zoom:80%;" /></blockquote><p>磁盘低速的原因是因为它一种机械装置，在磁盘中有一个或多个金属盘片，它们以5400，7200或10800rpm（RPM =revolutions per minute 每分钟多少转 ）的速度旋转。从边缘开始有一个机械臂悬在盘面上，这类似于老式黑胶唱片机上的拾音臂。信息卸载磁盘上的一些列的同心圆上，是一连串的2进制位（称为bit位），为了统计方法，8个bit称为一个字节Bytes，1024Bytes=1kB，1024kB=1MB，1024MB=1GB，1024GB=1TB，1024TB = 1PB所以我们平时所说的磁盘容量最终指的就是磁盘能写多少个2进制位。</p><p>每个磁头可以读取一段换新区域，称为<strong><code>磁道</code></strong>。</p><p>把一个机械手臂位置上所有的磁道合起来，组成一个<strong><code>柱面</code></strong>。</p><p>每个磁道划成若干<strong><code>扇区</code></strong>，站在硬盘的角度，一次性读写数据的最小单位为扇区，一个扇区通常为512Bytes。</p><p>操作系统一次性读写的单位是一个Block块，默认是8个扇区，也就是4096Bytes</p><h4 id="硬盘的IO延迟问题"><a href="#硬盘的IO延迟问题" class="headerlink" title="硬盘的IO延迟问题"></a>硬盘的IO延迟问题</h4><p><strong>数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆圈，从磁盘读取一段数据需要经历寻道时间和延迟时间</strong></p><p><strong>平均寻道时间：</strong></p><p>机械手臂从一个柱面随机移动到相邻的柱面的时间称为寻道时间，找到了磁道就意味着找到了数据所在的那个圈圈，但是还不知道数据具体这个圆圈的具体位置。受限于物理工艺水平。</p><p><strong>平均延迟时间：</strong></p><p>机械臂到达正确的磁道之后还必须等待旋转到数据所在的扇区下，这段时间称为延迟时间。受限于硬盘的转速！</p><p>IO延迟 = 平均寻道时间+平均延期时间。</p><blockquote><p><strong><code>优化程序运行效率的一个核心法则：能从内存取数据，就不要从硬盘取数据</code></strong></p></blockquote><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>许多计算机支持虚拟内存机制，该机制使计算机可以运行大于物理内存的程序，方法是将正在使用的程序放入内存执行，而暂时不需要执行的程序放到磁盘的某块地方，这块地方成为虚拟内存，在linux中称为swap，这种机制的核心在于快速地映射内存地址，由cpu中的一个部件负责，成为存储器管理单元(Memory Management Unit， MMU)</p><blockquote><p>从一个程序切换到另外一个程序，称为上下文切换(context switch),缓存和MMU的出现提升了系统的性能，尤其是上下文切换。</p></blockquote><blockquote><p>PS：磁带：</p><p>在价钱相同的情况下比硬盘拥有更高的存储容量，虽然速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。（常见于大型数据库系统中）</p></blockquote><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p><strong>IO设备 = 设备的控制器+设备本身</strong></p><p>cpu和存储器并不是操作系统唯一需要管理的资源，I/O设备也是非常重要的一环。</p><p>见1.1的图，<strong>I/O设备一般包括两个部分：设备控制器和设备本身</strong>。</p><p>控制器：是查找主板上的一块芯片或一组芯片（硬盘，网卡，声卡等都需要插到一个口上，这个口连的便是控制器），控制器负责控制连接的设备，它从操作系统接收命令，比如读硬盘数据，然后就对硬盘设备发起读请求来读出内容。</p><p>控制器的功能：通常情况下对设备的控制是非常复杂和具体的，控制器的任务就是为操作系统屏蔽这些复杂而具体的工作，提供给操作系统一个简单而清晰的接口</p><p>设备本身：有相对简单的接口且标准的，这样大家都可以为其编写驱动程序了。要想调用设备，必须根据该接口编写复杂而具体的程序，于是有了控制器提供设备驱动接口给操作系统。必须把设备驱动程序安装到操作系统中。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>在第1节的结构在小型计算机中沿用了多年，并也用在早期的IBM PC中。但是随着处理器和存储器速度越来越快，单总线很难处理总线的交通流量了，于是出现了下图的多总线模式，他们处理I/O设备及cpu到存储器的速度都更快。</p><p>北桥即PCI桥：连接高速设备</p><p>南桥即ISA桥：连接慢速设备</p><blockquote><p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118183358656-1969770652.png" alt=""></p></blockquote><p>主板图解：</p><p><img src="https://images2018.cnblogs.com/blog/1036857/201803/1036857-20180314164300354-1096940375.jpg" alt=""></p><h3 id="操作系统启动流程"><a href="#操作系统启动流程" class="headerlink" title="操作系统启动流程"></a>操作系统启动流程</h3><p>在计算机的主板上有一个基本的输入输出程序（Basic  Input Output System)</p><p>BIOS就相当于一个小的操作系统，它有底层的I/O软件，包括读键盘，写屏幕，进行磁盘I/O,该程序存放于一非易失性存储ROM中。</p><p><strong>启动流程：</strong></p><p>1.计算机加电</p><p>2.BIOS开始运行，检测硬件：cpu、内存、硬盘等</p><p>3.BIOS读取CMOS存储器中的参数，选择启动设备</p><p>4.从启动设备上读取第一个扇区的内容（MBR主引导记录512字节，前446为引导信息，后64为分区信息，最后两个为标志位）</p><p>5.根据分区信息读入bootloader启动装载模块，启动操作系统</p><p>6.然后操作系统询问BIOS，以获得配置信息。对于每种设备，系统会检查其设备驱动程序是否存在，如果没有，系统则会要求用户安装设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始有关的表格（如进程表），传进需要的进程，并在每个终端上启动登录程序或GUI</p><blockquote><p>补充：<strong>应用程序的启动流程</strong></p><ol><li>双击exe快捷方式，该快捷方式指向一个绝对路径</li><li>操作系统会根据路径找到exe程序在硬盘中的位置，控制其代码从硬盘加载到内存</li><li>然后CPU从内存中读取刚刚读入内存的程序代码执行，应用程序完成启动</li></ol></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1]    <a href="https://www.cnblogs.com/linhaifeng/p/6523843.html#4462371" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/p/6523843.html#4462371</a></p><p>[2]    <a href="https://zhuanlan.zhihu.com/p/108350791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108350791</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成 </tag>
            
            <tag> 计算机硬件 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
