<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹏空间</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.pengspace.top/"/>
  <updated>2020-11-16T11:43:25.846Z</updated>
  <id>https://www.pengspace.top/</id>
  
  <author>
    <name>AnswerCoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL数据库高级</title>
    <link href="https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    <id>https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/</id>
    <published>2020-11-16T11:41:42.000Z</published>
    <updated>2020-11-16T11:43:25.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DQL数据查询进阶"><a href="#DQL数据查询进阶" class="headerlink" title="DQL数据查询进阶"></a>DQL数据查询进阶</h2><p>这里所用到的表结构如下图所示：</p><p><img src="https://i.loli.net/2020/11/11/T2PUqaGgcXIZv18.png" alt=""></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询即嵌套在其他查询中的查询。可以利用嵌套关系完成一些复杂情况的查询。</p><blockquote><p>  <strong>例子 1：利用子查询进行过滤</strong></p><p>  订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储⼀行。 各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。现在，假如需要列出订购了物品TNT2的所有客户，可以用下面的方式查询</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 从oderitems表中查询所有包含物品TNT2中的订单编号order_num;</span><br><span class="line">-- 将上一步查询出的order_num作为在oders表中查询的条件，查询出符合条件的用户编号cust_id;</span><br><span class="line">-- 再将上一步查询出的cust_id作为在customers表中查询的条件,就可以查询出订购了物品TNT2的所有客户啦</span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (</span><br><span class="line">   SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (</span><br><span class="line">       SELECT order_numFROM orderitems WHERE prod_id &#x3D; &#39;TNT2&#39;</span><br><span class="line">   )</span><br><span class="line">); </span><br><span class="line">-- 查询结果：</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br></pre></td></tr></table></figure><p>  <strong>例子 2：作为计算字段使用子查询</strong></p><p>  假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 从customers表中检索客户列表。对于检索出的每个客户，统计其在orders表中的订单数目。</span><br><span class="line">SELECT cust_id,cust_name,</span><br><span class="line">(SELECT COUNT(*)</span><br><span class="line">FROM orders</span><br><span class="line">WHERE orders.cust_id &#x3D; customers.cust_id) as ordersNum</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+-----------+</span><br><span class="line">| cust_id | cust_name      | ordersNum |</span><br><span class="line">+---------+----------------+-----------+</span><br><span class="line">|   10001 | Coyote Inc.    |         2 |</span><br><span class="line">|   10005 | E Fudd         |         1 |</span><br><span class="line">|   10002 | Mouse House    |         0 |</span><br><span class="line">|   10003 | Wascals        |         1 |</span><br><span class="line">|   10004 | Yosemite Place |         1 |</span><br><span class="line">+---------+----------------+-----------+</span><br></pre></td></tr></table></figure><p>  这条SELECT 语句对customers 表中每个客户返回3 列：cust_name、cust_state和ordersNum。ordersNum是一个计算字段，它是由圆括号中的子查询<code>SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) as ordersNum)</code>建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。</p><blockquote><p>  子查询中的WHERE子句与前面使用的WHERE子句稍有不同，因为它使用了完全限定列名。这种方式叫做相关子查询，它是涉及外部查询的子查询。任何时候只要列名可能有多义性，就必须使用这种语法。因为有两个cust_id列，一个在customers中，另一个在orders中，需要⽐比较这两个列列以正确地把订单与它们相应的顾客匹配</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE orders.cust_id &#x3D; customers.cust_id</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><p>SQL最强大的功能之⼀就是能在数据检索查询的执行中联结（join）表。在能够有效地使⽤用联结前，必须了了解关系表以及关系数据库设计的⼀些基础知识</p><h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><p>MySQL作为一个关系型数据，最大的特点便是通过表与表之间的关系，可以有效地存储和方便地处理数据</p><p><strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系(relational)）互相关联。</strong></p><p>表与表之间的关系，通过外键进行关联。<strong>外键存在于两个拥有相同字段的表中，其中一个表的主键在另一个表中作为外键</strong>查找数据时，可以通过外键确定数据对应关系。</p><p>表关系又下面三种</p><ul><li><p>一对一关系：就是在一个表A中的一条数据，对应着另外一张表B中的一条数据，反过来也是。</p></li><li><p>一对多（多对一）关系：在一个表A中的一条数据对应着另外一个表B中的多条数据，但反过来另一个表B中的一条数据也只能对应表A中的一条数据，比如，爸爸和儿女，一个爸爸可以有很多儿女，但一个儿女只能有一个爸爸。</p></li><li><p>多对多关系：在一个表A中的一条数据对应另一个表B中的多条数据，同时，表B中的一条数据也对应着表A中的多条数据</p><p><img src="https://i.loli.net/2020/11/11/ki3lRrb2MfgV7hX.png" alt=""></p></li></ul><blockquote><p>  有关<strong>表关系</strong>更详细的内容可以看这两篇文章</p><p>  <a href="https://cloud.tencent.com/developer/article/1585927" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1585927</a></p><p>  <a href="https://blog.csdn.net/weixin_40001125/article/details/88252494" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40001125/article/details/88252494</a></p></blockquote><h4 id="表联结查询"><a href="#表联结查询" class="headerlink" title="表联结查询"></a>表联结查询</h4><p>如果数据存储在多个表中，怎样⽤用单条SELECT语句句检索出数据？</p><p>答案是使⽤用联结。简单地说，联结是⼀种机制，用来在一条SELECT语句中关联表，因此称之为联<br>结。</p><p>使⽤用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h5 id="内联结（等值连接）——INNER-JOIN"><a href="#内联结（等值连接）——INNER-JOIN" class="headerlink" title="内联结（等值连接）——INNER JOIN"></a>内联结（等值连接）——INNER JOIN</h5><p>获取两个表中字段匹配关系的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 表名1.字段名1,表名2.字段名2... FROM 表名1 INNER JOIN 表名2 ON 表名1.字段名3 &#x3D; 表名2.字段名3;</span><br></pre></td></tr></table></figure><p>也可以省略 INNER ，只写一个 JOIN。</p><p><img src="https://i.loli.net/2020/11/11/B9bHELYmCAZwiJ1.png" alt=""></p><blockquote><p>  举例：我们需要查询出所有的商品及对应的供应商信息：    </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id &#x3D; products.vend_id</span><br><span class="line">-- 查询结果</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">+-------------+----------------+------------+</span><br></pre></td></tr></table></figure><p>  上面语句等价于：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors,products</span><br><span class="line">WHERE vendors.vend_id &#x3D; products.vend_id</span><br></pre></td></tr></table></figure></blockquote><p>多表联结：SQL对⼀一条SELECT语句句中可以联结的表的数目没有限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT 表名1.字段名1,表名2.字段名2... </span><br><span class="line">FROM 表名1 </span><br><span class="line">INNER JOIN 表名2 ON 表名1.字段名3 &#x3D; 表名2.字段名3</span><br><span class="line">INNER JOIN 表名3 ON 表名2.字段名4 &#x3D; 表名3.字段名4</span><br><span class="line">...</span><br><span class="line">(WHERE 过滤条件);</span><br><span class="line">-- ON 后面跟联结条件</span><br></pre></td></tr></table></figure><h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><p>自联结在查询一些特定数据时可以作为子嵌套查询的替代</p><p>这时候，就需要自己与自己进行联结，为了区分，需要用AS取一个别名</p><blockquote><p>  举例：</p><p>  假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 1.自联结 JOIN</span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1 </span><br><span class="line">JOIN products AS p2</span><br><span class="line">ON p1.vend_id &#x3D; p2.vend_id </span><br><span class="line">WHERE p2.prod_id &#x3D; &#39;DTNTR&#39;;</span><br><span class="line">-- 2.自联结 WHERE</span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id &#x3D; p2.vend_id AND p2.prod_id &#x3D; &#39;DTNTR&#39;;</span><br><span class="line">-- 3.子查询</span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id &#x3D; (SELECT vend_id FROM products WHERE prod_id &#x3D; &#39;DTNTR&#39;);</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+</span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+---------+----------------+</span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+---------+----------------+</span><br></pre></td></tr></table></figure></blockquote><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候<strong>处理联结远比处理子查询快得多</strong>。</p><h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><ul><li><p>左联结 LEFT JOIN：以左侧表为基准，去关联右侧的表进行联结，如果有未关联的数据，那么结果为null</p></li><li><p>右联结 RIGHT JOIN：以右侧表为基准，去关联左侧的表进行联结，如果有未关联的数据，那么结果为null</p><p>  <img src="https://i.loli.net/2020/11/11/NszZBtwy3GSOMcU.png" alt=""></p></li></ul><blockquote><p>  例如：我们要对每个客户下了多少订单进行计数，<strong>包括那些至今尚未下订单的客户</strong>；</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-- 1.内部联结。它检索所有客户及其订单：</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM customers INNER JOIN orders </span><br><span class="line">ONcustomers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">-- 明显这种方式不能达到我们的要求，它不包含至今尚未下订单的客户 10002</span><br><span class="line"></span><br><span class="line">-- 2.外部联结。检索所有客户，包括那些没有订单的客户</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM customers LEFT JOIN orders </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">-- 也可以写成这样</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM orders RIGHT JOIN customers </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10002 |      NULL |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br><span class="line"></span><br><span class="line">-- 加入订单量计数</span><br><span class="line">SELECT customers.cust_id,customers.cust_name,COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers LEFT JOIN orders </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line">| cust_id | cust_name      | num_ord |</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line">|   10001 | Coyote Inc.    |       2 |</span><br><span class="line">|   10002 | Mouse House    |       0 |</span><br><span class="line">|   10003 | Wascals        |       1 |</span><br><span class="line">|   10004 | Yosemite Place |       1 |</span><br><span class="line">|   10005 | E Fudd         |       1 |</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line"></span><br><span class="line">-- 列出所有产品以及订购数量量，包括没有⼈人订购的产品；</span><br><span class="line">select products.prod_id,products.prod_name,count(orderitems.order_num) AS num_ord</span><br><span class="line">from products left join orderitems</span><br><span class="line">on products.prod_id &#x3D; orderitems.prod_id</span><br><span class="line">group by products.prod_id;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>表联结注意事项</strong></p><ul><li>保证使⽤用正确的联结条件，否则将返回不不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡⼉儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采⽤用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单</li></ul></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>MySQL也允许执行多个查询（多条SELECT语句句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p><p><strong>UNION规则</strong></p><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ul><blockquote><p>  举例：假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002);</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line"></span><br><span class="line">-- UNION会从查询结果集中自动去除了重复的行 这是UNION的默认行为，但是如果需要，可以改变它。</span><br><span class="line">-- 如果想返回所有匹配的行，可使用UNION ALL</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002);</span><br><span class="line"></span><br><span class="line">-- 结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |-- 重复数据</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 | -- 重复数据</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure><p>  <strong>对组合查询结果排序</strong></p><p>  SELECT语句的输出用ORDER BY子句排序。在⽤UNION组合查询时，只能使⽤一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。<strong>ORDER BY子句是对整个结果集排序</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002)</span><br><span class="line">ORDER BY prod_price;</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure></blockquote><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>事务（Transaction）是由⼀系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。</p><p><img src="https://i.loli.net/2020/11/13/mEoWeQDFin72Rhd.png" alt=""></p><p>事务的基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start transaction;或者 begin;</span><br><span class="line">-- 事务操作的语句</span><br><span class="line">commit; -- 使得当前的修改确认</span><br><span class="line">rollback; -- 使得当前的修改被放弃</span><br></pre></td></tr></table></figure><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ol><li><p><strong>原子性（Atomicity）</strong></p><p> 事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部执行失败。</p><p> 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，<br> 会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体。</p></li><li><p><strong>一致性（Consistency）</strong></p><p> 事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，不能时数据发生错乱</p></li><li><p><strong>隔离性（Isolation）</strong></p><p> 事务的隔离性是指在<strong>并发环境</strong>中，<strong>并发的事务</strong>是互相隔离的，各有各自的数据空间。</p></li><li><p><strong>持久性（Duration）</strong></p><p> 事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机，只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。</p></li></ol><h3 id="事务并发常见问题"><a href="#事务并发常见问题" class="headerlink" title="事务并发常见问题"></a>事务并发常见问题</h3><ul><li><p>脏读（Dirty Read）：读取到了没有提交的数据。</p><p>例如：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据。</p></li><li><p>不可重复读（Unrepeatale Read）：同⼀条命令返回不同的结果集</p><p>例如：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p></li><li><p>幻读（Phantom Read）：重复查询的过程中，数据就发生了量的变化。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(READ_UNCOMMITTED)</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>读已提交(READ_COMMITTED)</td><td>禁止</td><td>允许</td><td>允许</td></tr><tr><td>可重复读(REPEATABLE_READ)</td><td>禁止</td><td>禁止</td><td>可能会</td></tr><tr><td>顺序读(SERIALIZABLE)</td><td>禁止</td><td>禁止</td><td>禁止</td></tr></tbody></table><blockquote><p>  4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越高。 一般数据默认级别是读已提交或可重复读。</p></blockquote><blockquote><p>  <strong>查看和设置事务隔离级别的语句</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前会话中事务的隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置当前会话中的事务隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted | read committed | repeatable read |  SERIALIZABLE</span><br></pre></td></tr></table></figure></blockquote><ol><li><p><strong>读未提交(READ_UNCOMMITTED)</strong></p><p>该隔离级别允许脏读取，其隔离级别是最低的。一个事务正在处理某⼀数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务，而与此同时，允许另一个事务也能够访问该数据。</p></li><li><p><strong>读已提交(READ_COMMITTED)</strong></p><p>不同的事务执行的时候只能获取到已经提交的数据。 这样就不会出现上面的脏读的情况了。但是在同一个事务中执行同一个读取，结果不一致，即不可重复读问题</p></li><li><p><strong>可重复读(REPEATABLE_READ)</strong></p><p>保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别限制了不可重复读和脏读，但是有可能出现幻读的数据。</p></li><li><p><strong>顺序读(SERIALIZABLE)</strong></p><p>最严格的事务隔离级别，不允许事务并发，必须依次排序执行。</p></li></ol><p><strong>不同的隔离级别的锁的情况</strong></p><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁。它与RC的区别是能够查询到未提交的数据。</li><li>读已提交（RC）：有行级的锁，没有间隙锁，读不到没有提交的数据。</li><li>可重复读（RR）：有行级的锁，也有间隙锁，每次读取的数据都是一样的，并且没有幻读的情况。</li><li>序列列化（S）：有行级锁，也有间隙锁，读表的时候，就已经上锁了。</li></ol><h2 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。</p><p>存储过程就像脚本语⾔言中函数定义⼀样，是一组为了完成特定功能的SQL语句集，经过编译之后存储在数据库中，在需要时直接调用。</p><p><strong>创建存储过程</strong> ：<code>create procedure 存储过程名()</code> </p><blockquote><p>  <code>\d //</code>：修改MySQL默认的语句结尾符<code>;</code>改为<code>//</code> 。</p><p>  <code>create procedure 存储过程名()</code>  创建语句</p><p>  <code>BEGIN</code>和<code>END</code>语句用来限定存储过程体</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 定义存储过程 向users表中循环插入80条数据</span><br><span class="line">\d &#x2F;&#x2F;</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">set @i&#x3D;10;</span><br><span class="line">while @i&lt;90 do</span><br><span class="line">insert into users values(null,concat(&#39;user:&#39;,@i),@i,0); -- </span><br><span class="line">set @i&#x3D;@i+1;</span><br><span class="line">end while;</span><br><span class="line">end;</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong>： <code>call 存储过程名()</code></p><p><strong>查看存储过程</strong>：<code>show create procedure 存储过程名\G</code></p><p><strong>删除存储过程</strong>：<code>drop procedure 存储过程名</code></p><h2 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h2><p>触发器是指MySQL<strong>响应</strong>写操作(增、删、改)而<strong>自动执行</strong>的一条或一组定义在BEGIN和END之间的MySQL语句。</p><p>或可理理解为：提前定义好一个或一组操作,在指定的SQL操作前或后来触发指定的SQL自动执行，触发器就像是JavaScript中的事件一样。</p><p><strong>触发器语法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建触发器</span><br><span class="line">\d &#x2F;&#x2F;</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event</span><br><span class="line">ON tbl_name FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">trigger_stmt;</span><br><span class="line">END;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">\d ; -- 结束之后要把语句结束符改回来</span><br><span class="line">-- 说明：</span><br><span class="line"># trigger_name：触发器名称</span><br><span class="line"># trigger_time:触发时间，可取值：BEFORE或AFTER</span><br><span class="line"># trigger_event：触发事件，可取值：INSERT、UPDATE或DELETE。</span><br><span class="line"># tb1_name：指定在哪个表上</span><br><span class="line"># trigger_stmt：触发理SQL语句。</span><br><span class="line"></span><br><span class="line">-- 查看所有的 触发器器</span><br><span class="line">show triggers\G;</span><br><span class="line"></span><br><span class="line">-- 删除触发器</span><br><span class="line">drop trigger trigger_name;</span><br></pre></td></tr></table></figure><blockquote><p>  在使用触发器时，可以建立虚拟表来方便某些操作</p><ul><li>在INSERT触发器代码内，可引用⼀个名为NEW的虚拟表，访问被 插入的行;</li><li>在DELETE触发器代码内，可引用一个名为OLD的虚拟表，访问被删除的行;<ul><li>OLD中的值全都是只读的，不能更新。</li><li>在AFTER DELETE的触发器中无法获取OLD虚拟表</li></ul></li><li>在UPDATE触发器代码中<ul><li>可以引用一个名为OLD的虚拟表访问更新以前的值<br>可以引用一个名为NEW的虚拟表访问新更新的值;</li></ul></li></ul></blockquote><h2 id="MySQL的视图"><a href="#MySQL的视图" class="headerlink" title="MySQL的视图"></a>MySQL的视图</h2><p><strong>视图的定义及特性</strong></p><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询语句。</p><p>视图本身不不包含数据，它们返回的数据是从其他表中检索出来的。</p><p><strong>视图的作用</strong></p><ul><li><p>重用SQL语句，简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</p></li><li><p>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p></li><li><p>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p></li></ul><blockquote><p>  <strong>注意：视图不能索引，也不不能有关联的触发器或默认值</strong>。</p></blockquote><p><strong>视图的语法和使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图</span><br><span class="line">create view 视图名 as 要封装的select语句;</span><br><span class="line">-- 例如：</span><br><span class="line">create view v_users as select id,name,age from users where age &gt;&#x3D; 25 and age&lt;&#x3D; 35;</span><br><span class="line"></span><br><span class="line">-- 查看当前库中所有的视图</span><br><span class="line">show tables; -- 可以查看到所有的表和视图</span><br><span class="line">show table status where comment&#x3D;&#39;view&#39;\G; -- 只查看当前库中的所有视图</span><br><span class="line"></span><br><span class="line">-- 删除视图v_t1:</span><br><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h2 id="MySQL索引与优化"><a href="#MySQL索引与优化" class="headerlink" title="MySQL索引与优化"></a>MySQL索引与优化</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><strong>定义</strong></p><p>MySQL官方对索引的定义为：<strong>索引(Index)是帮助MySQL高效获取数据的数据结构。</strong></p><p>索引类似图书的目录，是一种有序结构，可以提高数据检索的效率，降低数据库的IO成本。</p><p><strong>分类</strong></p><table><thead><tr><th>索引类型</th><th>说明</th></tr></thead><tbody><tr><td>主键索引</td><td>根据主键建立的索引。<strong>不允许重复，不允许空值</strong>。<br>如果表中没有定义主键，InnoDB 会选择一个唯⼀的非空索引代替；如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</td></tr><tr><td>唯一索引</td><td>用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></td></tr><tr><td>普通索引</td><td>用表中普通列构建的索引，没有任何限制</td></tr><tr><td>全文索引</td><td>用大文本对象的列构建的索引（5.6之前MyISAM支持，InnoDB不支持；8.0之前不支持中文。）</td></tr><tr><td>组合索引</td><td>用多个列组合构建的索引，这多个列的值不允许空值，<strong>需遵循“最左”原则</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引和删除索引</span><br><span class="line">-- 1.主键索引 </span><br><span class="line">-- 1.创建表时，直接创建主键索引 PRIMARY KEY</span><br><span class="line">CREATE TABLE users( </span><br><span class="line">        id int NOT NULL AUTO_INCREMENT PRIMARY KEY</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</span><br><span class="line">-- 2.修改时添加主键和自增</span><br><span class="line">alter table users modify uid int primary key AUTO_INCREMENT;</span><br><span class="line">-- 删除主键索引注意需要先取消自增，再删除主键</span><br><span class="line">-- 先取消自增,修改字段</span><br><span class="line">alter table users modify uid int;</span><br><span class="line">-- 删除主键</span><br><span class="line">alter table users drop primary key;</span><br><span class="line">-- 2.唯一索引 </span><br><span class="line">-- 1.创建表时,直接创建唯一索引UNIQUE KEY</span><br><span class="line">    CREATE TABLE users(</span><br><span class="line">    name varchar(10) NOT NULL ,</span><br><span class="line">    UNIQUE KEY name(name),-- name为索引名</span><br><span class="line">    )ENGINE&#x3D;InnoDB DEFAULT CHARSET-utf8mb4</span><br><span class="line">    --  2.添加唯一索引UNIQUE当前列要求唯一，但允许为空</span><br><span class="line">    alter table users add untque u_name(name); -- u_name为索引名</span><br><span class="line">    -- 删除唯一索引</span><br><span class="line">    alter table users drop index u_name;</span><br><span class="line">-- 3.普通索引</span><br><span class="line">-- 1.创建表时，直接创建普通索引 KEY</span><br><span class="line">    CREATE TABLE users(</span><br><span class="line">    email varchar ( 10 ) NOT NULL ,</span><br><span class="line">    KEY  index_email(email)-- index_email为索引名</span><br><span class="line">    )ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br><span class="line">    -- 2.添加索引</span><br><span class="line">    alter table users add index in_email(email);</span><br><span class="line">    -- 删除普通索引</span><br><span class="line">    drop index in_email on users;</span><br><span class="line">-- 4.添加全文索引</span><br><span class="line">ALERT TABLE 表名 ADD FULLTEXT INDEX 索引名(要建立索引的字段);</span><br><span class="line">-- 5.组合索引 </span><br><span class="line">-- 添加索引</span><br><span class="line">alter table users add index in_x(email,phone,uname)</span><br><span class="line">-- 删除索引</span><br><span class="line">alter table users drop index in_x;</span><br></pre></td></tr></table></figure><h3 id="索引原理-索引与B-Tree"><a href="#索引原理-索引与B-Tree" class="headerlink" title="索引原理-索引与B+Tree"></a>索引原理-索引与B+Tree</h3><blockquote><p>  <strong>哈希索引</strong></p><p>  只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p></blockquote><p>正常情况下，如果不指定索引的类型，那么一般是指B+Tree索引。</p><p>存储引擎以不同的方式使用B+Tree索引。性能也各有不同，InnoDB时按照原数格式进行存储的。</p><p>首先，要了解B+树之前，我们先了解一下B树，<strong>B树是一种自平衡树状结构，一般多用于存储系统上</strong>，比如数据库或文件系统。</p><blockquote><p>  一个n阶的B树，每个节点可以存储n-1个值</p></blockquote><p><img src="https://i.loli.net/2020/11/14/R9swUcgBDSIWZ5p.png" alt=""></p><p>可以看到B树每个叶子节点都带有数据，在效率上还是存在一些弊端，可以进行优化，提高查询效率，便演变出了B+树，如下图所示</p><p><img src="https://i.loli.net/2020/11/14/FeBMcODgiwTVfqA.png" alt="image-20201114211729600"></p><p>使用B+树的优势</p><ol><li><p>磁盘读写代价更低</p><p>B树的数据和索引都在同一个节点上，那么每个块中包含的索引是少量的，如果想要取出比较深层的数据，意味着要读取更多的块，才能得到想要的索引和数据，那么就增加了IO次数；</p><p>而B+树中每个块能存储的索引是B树的很多倍，那么获取比较深层的数据，也只需要读取少量的块<br>就可以，那么就减少了磁盘的IO次数</p></li><li><p>随机IO的次数更少</p><p>随机I/O是指读写操作时间连续，但访问地址不连续，时长约为10ms。</p><p>顺序I/O是指读取和写入操作基于逻辑块逐个连续访问来自相邻地址的数据，时长约为0.1ms</p><p>在相同情况下，B树要进行更多的随机IO，而B+树需要更多的顺序IO，因此B+树，效率也更快</p></li><li><p>查询速度更稳定</p><p>由于B+Tree非叶子节点不存储数据（data)，因此所有的数据都要查询至叶子节点，而叶子节点的<br>高度都是相同的，因此所有数据的查询速度都是一样的。</p></li></ol><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p><strong>聚簇索引：</strong>索引即数据，找到索引便找到了数据</p><p><strong>非聚簇索引：</strong>索引是一个文件，数据在另一个文件，根据索引文件找到数据的key值，然后到数据文件中根据key值找到数据</p><p><img src="https://i.loli.net/2020/11/14/g98ev1TwkP5cAUS.png" alt=""></p><blockquote><p>  <strong>MyISAM的索引方案</strong></p><p>  InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储，也就是把索引信息单独存到一个文件中，这个文件称为索引文件。</p><p>  MyISAM会单独为表的主键创建⼀个索引，只不过在索引的叶子节点中存储的不是完整的数据记录，而是主键值 + 行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！其它非主键索引也是一样的，这种情况我们称为“回行”。所以在MyISAM中所有的索引都是非聚簇索引，也叫二级索引。</p><p>  <img src="https://i.loli.net/2020/11/14/PbsI1ugyhd9UZGz.png" alt=""></p><p>  <strong>MyISAM和InnoDB的区别</strong></p><ul><li><p>数据存储方式：</p><ul><li>InnoDB由两种文件组成，表结构、数据和索引</li><li>MyISAM由三种文件组成，表结构、数据、索引</li></ul></li><li><p>索引的方式：</p><ul><li>索引的底层都是基于B+Tree的数据结构建立</li><li>InnoDB中主键索引为聚簇索引，辅助索引是非聚簇索引</li><li>MyISAM中数据和索引存在不同的文件中，因此都是非聚簇索引</li></ul></li><li><p>事务的支持：</p><ul><li>InnoDB支持事务</li><li>MyISAM不支持事务</li></ul></li></ul></blockquote><h3 id="慢查询与SQL优化"><a href="#慢查询与SQL优化" class="headerlink" title="慢查询与SQL优化"></a>慢查询与SQL优化</h3><h4 id="慢查询与Explain执行计划"><a href="#慢查询与Explain执行计划" class="headerlink" title="慢查询与Explain执行计划"></a>慢查询与Explain执行计划</h4><p>MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p><p>默认情况下，MySQL数据库并不启动慢查询目思，需要手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，开启慢查询日志会或多或少带来一定的性能影响。</p><p><img src="https://i.loli.net/2020/11/14/dlLvRoOMuDXxQY8.png" alt=""></p><p><strong>Explain执行计划</strong></p><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划。这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个语句的具体执行计划。</p><p><img src="https://i.loli.net/2020/11/14/V5hRgPtf2BxEYM1.png" alt=""></p><table><thead><tr><th>参数</th><th>参数解释</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个 SELECT关键字都对应一个唯一的 id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>ﬁltered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p><strong>索引优化</strong></p><ul><li><p>适当建立索引</p><ul><li>创建并使用自增数字来建立主键索引</li><li>为经常作为where条件的字段建立索引</li><li>添加索引的字段尽可能的保持唯一性</li><li>可考虑使用组合索引并进行<em>索引覆盖</em>(多个字段组合成一个联合索引，在查询时，所要的字段和查询条件中的索引是一致的)</li><li>索引绝不是加的越多越好，每建立一个索引都会建立一棵B+树，并且需要维护，很费性能和存储空间。</li></ul></li><li><p>合理使用索引，查询时避免索引失效</p><ul><li>不要在查询的索引列上使用函数</li><li>不要在查询的索引列上进行运算</li><li>避免查询条件左右类型不匹配发生隐式转换</li><li>使用like模糊查询时避免通配符%放在第一位</li><li>多个单列索引并不是最佳选择，可以使用组合索引</li><li>使用组合查询时谨记最左前缀原则（从最左字段开始使用索引：查询条件中使用了组合索引的第一个字段，索引才会被使用。因此，在组合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。）</li></ul></li></ul><p><strong>SQL语句的优化</strong></p><ul><li>避免嵌套语句（子查询）</li><li>避免多表查询（复杂查询简单化）</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DQL数据查询进阶&quot;&gt;&lt;a href=&quot;#DQL数据查询进阶&quot; class=&quot;headerlink&quot; title=&quot;DQL数据查询进阶&quot;&gt;&lt;/a&gt;DQL数据查询进阶&lt;/h2&gt;&lt;p&gt;这里所用到的表结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.pengspace.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-16T11:36:21.000Z</published>
    <updated>2020-11-16T11:41:29.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><ul><li><p>什么是数据库</p><p>数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库。<br>专业的数据库是专门对数据进行创建，访问，管理，搜索等操作的软件，比起我们自己用文件读写的方式，用它对数据进行管理更加的方便，快速，安全。</p></li><li><p>数据库特点及作用</p><ul><li>对数据进行持久化的保存</li><li>方便数据的存储和查询，速度快，安全，方便</li><li>可以处理并发访问</li><li>更加安全的权限管理访问机制</li></ul></li><li><p>常见的数据库</p><p>数据库分两大类，一类是 <a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831?fr=aladdin" target="_blank" rel="noopener">关系型数据库</a>。另一类叫做 <a href="https://baike.baidu.com/item/NoSQL/8828247?fromtitle=%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&fromid=6376860&fr=aladdin" target="_blank" rel="noopener">非关系型数据库</a>。</p><ul><li>关系型数据库： MySQL，Oracle，PostgreSQL，SQLserver…</li><li>非关系型数据库：Redis内存数据库，MongoDB文档数据库…</li></ul><p><img src="https://i.loli.net/2020/11/07/fdz4w9cKgm5eoqu.png" alt=""></p><p>关系型数据库与非关系型数据库对比可以看这篇文章:</p><p><a href="https://my.oschina.net/u/3647687/blog/1534979" target="_blank" rel="noopener">https://my.oschina.net/u/3647687/blog/1534979</a></p></li></ul><blockquote><p>  ‘</p><p>  MySQL是最流行的关系型数据库管理系统</p><p>  关于数据库的一些概念</p><ul><li><p>数据库 Database</p></li><li><p>数据表 Tables</p></li><li><p>数据字段 filed</p></li><li><p>行 row ：每一行就是一条数据</p></li><li><p>列 col</p><p><img src="https://i.loli.net/2020/11/07/tqBQ3OWFiJYAVXM.png" alt=""></p><p><img src="https://i.loli.net/2020/11/07/4JtSwzNr2am3qZb.png" alt=""></p></li></ul></blockquote><h2 id="MySql基础操作"><a href="#MySql基础操作" class="headerlink" title="MySql基础操作"></a>MySql基础操作</h2><h3 id="使用MySql的三种方式："><a href="#使用MySql的三种方式：" class="headerlink" title="使用MySql的三种方式："></a>使用MySql的三种方式：</h3><blockquote><p>  方式一：通过在命令行敲命令来操作</p><p>  方式二：通过图型界面工具,如 Navicat 等</p><p>  方式三：通过编程语言(python,php,java,go…)执行mysql命令</p></blockquote><h3 id="SQL-Structure-query-language-结构化查询语言"><a href="#SQL-Structure-query-language-结构化查询语言" class="headerlink" title="SQL ( Structure query language ) 结构化查询语言"></a>SQL ( Structure query language ) 结构化查询语言</h3><blockquote><p>  SQL语言分为4个部分：DDL（定义）、DML（操作）、DQL（查询）、DCL（控制）</p></blockquote><p>####SQL语句中的快捷指令</p><blockquote><p>  <code>\G</code> 格式化输出（文本式，竖立显示）</p><p>  <code>\s</code> 查看服务器端信息</p><p>  <code>\c</code> 结束命令输入操作</p><p>  <code>\q</code>退出当前sql命令行模式</p><p>  <code>\h</code> 查看帮助</p></blockquote><h3 id="数据库操作步骤-windows命令行"><a href="#数据库操作步骤-windows命令行" class="headerlink" title="数据库操作步骤(windows命令行)"></a>数据库操作步骤(windows命令行)</h3><ol><li><strong>开启数据库服务：</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start 你电脑中mysql服务的服务名</span><br></pre></td></tr></table></figure><blockquote><p>  你mysql服务的服务名一般安装时就指定好的，默认是mysql。如果不是可以从系统服务里找一下</p><p>  windows中查看你的mysql服务名</p><ol><li><p><kbd>win</kbd>+<kbd>R</kbd>键 打开运行，输入<code>services.msc</code>，确定</p><p><img src="https://i.loli.net/2020/11/07/dHBwemsUYk8Kr79.png" alt="image-20201107184754395"></p></li><li><p>找到你mysql的服务名</p><p><img src="https://i.loli.net/2020/11/07/Wv9U7rtKES5ohRZ.png" alt="image-20201107185331055"></p></li></ol></blockquote><p><img src="https://i.loli.net/2020/11/07/9NtUVPWJTiYzwGZ.png" alt=""></p><blockquote><p>  关闭数据库服务：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop 你电脑中mysql服务的服务名</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><strong>连接数据库：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 服务器地址 -u 用户名 -p (密码) -P 端口</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/07/iCOfXvus3qG7A26.png" alt="image-20201107190657607"></p><p>如果时本地操作可以省略 -h 和 -P，写成这样即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p (密码)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>操作(增删改)</strong></li></ol><p>后面会详细讲解</p><ol start="4"><li><strong>退出MySql</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit;</span><br><span class="line">-- 或者</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure><p>也可以用快捷命令<code>\q</code></p><h2 id="MySql数据类型"><a href="#MySql数据类型" class="headerlink" title="MySql数据类型"></a>MySql数据类型</h2><blockquote><p>  数据类型是定义列中可以存储什么类型的数据以及该数据实际怎样存储的基本规则</p><p>  数据类型限制存储在数据列中的数据的类型。例如，数值数据类型列只能接受数值类型的的数据</p><p>  在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。</p><p>  后续更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失），定义之后一般不会再修改字段的数据类型</p></blockquote><p><strong>基本常用的数据类型</strong></p><blockquote><p>  数据类型：整型、浮点型、字符串、日期等</p></blockquote><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><p>最常用的数据类型是串数据类型。它们存储串，如名字、地址、电 话号码、邮政编码等。</p><p>最常用的有三种基本的串类型，分别为<strong>定长串<code>char</code></strong>、<strong>变长串<code>varchar</code></strong>和<strong>变成文本<code>text</code></strong></p><p><strong>定长串：<code>char</code></strong></p><ul><li><p>接受长度固定的字符串，其长度是在创建表时指定的。不允许存储多于指定长度字符的数据。</p></li><li><p>指定长度后，就会分配固定的存储空间用于存放数据</p></li></ul><blockquote><p>  <code>char(7)</code> 不管实际插入多少字符，它都会占用7个字符位置</p></blockquote><p><strong>变长串 ：<code>varchar</code></strong></p><ul><li>存储可变长度的字符串 </li></ul><blockquote><p>  <code>varchar(7)</code> 如果实际插入4个字符，那么它只占4个字符位置，当然插入的数据长度不能超过7个字符。</p></blockquote><blockquote><p>  <strong>注意：</strong></p><p>  既然变长串数据类型这样灵活，为什么还要使用定长串数据类型？</p><p>  回答：因为性能，MySQL处理定长列远比处理变长列快得多。</p></blockquote><p><strong>变长文本：<code>text</code></strong></p><p>变长文本类型存储，最大长度为64K</p><p><img src="https://i.loli.net/2020/11/07/YMBXG18lpdgKWVm.png" alt="串类型"></p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。支持的取值范围越大，所需存储空间越多。</p><p><img src="https://i.loli.net/2020/11/07/TrcszjHbp2lK7FR.png" alt="数值类型"></p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decimal(5, 2) <span class="comment">--表示数值总共5位, 小数占2位</span></span><br><span class="line">tinyint <span class="comment">--1字节(8位) 0-255/-128-127</span></span><br><span class="line">int <span class="comment">--4字节。 -21亿-21亿/0-42亿</span></span><br><span class="line"><span class="comment">-- MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)或float</span></span><br></pre></td></tr></table></figure><blockquote><p>  <strong>有符号或无符号</strong></p><p>  所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号</p><p>  有符号数值列可以存储正或负的数值</p><p>  无符号数值列只能存储正数。</p><p>  默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字</p></blockquote><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>MySQL使用专门的数据类型来存储日期和时间值</p><p><img src="https://i.loli.net/2020/11/07/i9WorwyE14DXhZg.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime <span class="comment">-- 8字节 范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</span></span><br></pre></td></tr></table></figure><h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等</p><blockquote><p>  通常情况下，不会使用二进制数据类型进行存储到数据库中</p></blockquote><p><img src="https://i.loli.net/2020/11/07/xiOq49MkGC7mR2p.png" alt="二进制类型"></p><h3 id="表的字段约束"><a href="#表的字段约束" class="headerlink" title="表的字段约束"></a>表的字段约束</h3><ul><li><code>unsigned</code> 无符号(给数值类型使用，表示为正数，不写可以表示正负数都可以)</li><li>字段类型后面加括号限制宽度<ul><li>char(5)、varchar(7) 在字符类型后面加限制，表示字符串的长度</li><li>int(4) 没有意义，默认无符号的int为int(11)，有符号的int(10)，在数字类型后面只加(x)限制宽度没有意义。</li><li><code>int(4) unsigned zerofill</code>只有当给int类型设置有前导零(zerofill)时，设置int的宽度才有意义(不够长度会在前面补 0)。</li></ul></li><li><code>not null</code> 不能为空，在操作数据库时如果输入该字段的数据为NULL ，就会报错</li><li><code>default</code> 设置默认值</li><li><code>primary key</code> 主键不能为空，且唯一。一般和自动递增一起配合使用。</li><li><code>auto_increment</code> 定义列为自增属性，一般用于主键，数值会自动加1</li><li><code>unique</code> 唯一索引(数据不能重复:用户名)可以增加查询速度，但是会降低插入和更新速度</li></ul><h3 id="MySQL的运算符"><a href="#MySQL的运算符" class="headerlink" title="MySQL的运算符"></a>MySQL的运算符</h3><ul><li><p>算术运算符： +、 -、 *、 /或DIV、 %或MOD</p></li><li><p>比较运算符： =、 &gt;、 &lt;、 &gt;=、 &lt;=、!=</p></li><li><p>数据库特有的比较： in、not in、is null、is not null、like、between、and</p></li><li><p>逻辑运算符： and、or、not</p></li><li><p>like: 支持特殊符号 % 和 _  </p><p>其中 % 表示任意数量的任意字符， _ 表示任意一位字符</p><p><strong>详细内容可以看<a href="https://www.runoob.com/mysql/mysql-operator.html" target="_blank" rel="noopener">菜鸟编程MySQL运算符</a></strong></p></li></ul><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote><p>  <font color=red>表中每一行都应该有可以唯一标识自己的一列，用于记录两条记录不能重复</font>，任意两行都不具有相同的主键值</p><p>  应该总是定义主键 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操作和管理。</p></blockquote><p><strong>对于主键的要求</strong></p><ul><li><p>记录一旦插入到表中，主键最好不要再修改</p></li><li><p>不允许NULL</p></li><li><p>不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并或更改其名字时，就得更改这个主键。）</p></li><li><p>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键</p></li><li><p>可以使用多个列作为联合主键，但联合主键并不常用。使用多列作为主键时，所有列值的组合必须是唯一的</p></li></ul><h2 id="MySql数据库表引擎与字符集"><a href="#MySql数据库表引擎与字符集" class="headerlink" title="MySql数据库表引擎与字符集"></a>MySql数据库表引擎与字符集</h2><h3 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h3><p>其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</strong></p><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：</p><p><img src="https://i.loli.net/2020/11/08/iW2HgJZTRpaGBby.png" alt=""></p><blockquote><p>  虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p></blockquote><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p><code>MySQL</code> 服务器把<strong>数据的存储和提取操作</strong>都封装到了一个叫<strong>存储引擎</strong>的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能， <code>MySQL</code> 提供了各式各样的存储引擎，不同存储引<br>擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><blockquote><p>  存储引擎以前叫做<strong>表处理器</strong>，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p></blockquote><p>为了管理方便，人们把<strong>连接管理、查询缓存、语法解析、查询优化</strong>这些并不涉及真实数据存储的功能划分为<br><code>MySQL server</code> 的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的<code>MySQL server</code> 层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像”读取索引第一条内容”、”读取索引下一条内容”、”插入记录”等等。</p><p>所以在MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><p>MySQL 支持非常多种存储引擎：</p><table><thead><tr><th>存储引擎</th><th>描述</th></tr></thead><tbody><tr><td><code>ARCHIVE</code></td><td>用于数据存档（行被插入后不能再修改）</td></tr><tr><td><code>BLACKHOLE</code></td><td>丢弃写操作，读操作会返回空内容</td></tr><tr><td><code>CSV</code></td><td>在存储数据时，以逗号分隔各个数据项</td></tr><tr><td><code>FEDERATED</code></td><td>用来访问远程表</td></tr><tr><td><code>InnoDB</code></td><td>具备外键支持功能的事务存储引擎</td></tr><tr><td><code>MEMORY</code></td><td>置于内存的表</td></tr><tr><td><code>MERGE</code></td><td>用来管理多个MyISAM表构成的表集合</td></tr><tr><td><code>MyISAM</code></td><td>主要的非事务处理存储引擎</td></tr><tr><td><code>NDB</code></td><td>MySQL集群专用存储引擎</td></tr></tbody></table><h4 id="MyISAM和InnoDB表引擎的区别"><a href="#MyISAM和InnoDB表引擎的区别" class="headerlink" title="MyISAM和InnoDB表引擎的区别"></a>MyISAM和InnoDB表引擎的区别</h4><ol><li><p><strong>事务支持</strong></p><p>MyISAM不支持事务，而InnoDB支持。</p><blockquote><p>  事物：访问并更新数据库中数据的执行单元。事物操作中，要么都执行要么都不执行</p></blockquote></li><li><p><strong>存储结构</strong></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。</p><ul><li>.frm文件存储表结构。</li><li>.MYD文件存储数据。</li><li>.MYI文件存储索引。</li></ul><p>InnoDB：主要分为两种文件进行存储。</p><ul><li>.frm 存储表结构</li><li>.ibd 存储数据和索引 （也可能是多个.ibd文件，或者是独立的表空间文件）</li></ul></li><li><p><strong>表锁差异</strong></p><p>MyISAM：<strong>只支持表级锁</strong>，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 </p><p>InnoDB：<strong>支持事务和行级锁，是innodb的最大特色。</strong>行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，<strong>InnoDB的行锁是基于索引建立的，如果索引失效或者没有索引，那么，行锁失效，由行锁升级为表锁。</strong></p></li><li><p><strong>表主键</strong></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 </p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p></li><li><p><strong>表的具体行数</strong></p><p>MyISAM：保存有表的总行数，如果<code>select count(*) from table;</code>会直接取出出该值。 </p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用<code>select count(*) from table;</code>就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p></li><li><p><strong>CURD操作</strong></p><p>MyISAM：如果执行大量的<code>SELECT</code>，MyISAM是更好的选择。 </p><p>InnoDB：如果你的数据执行大量的<code>INSERT</code>或<code>UPDATE</code>，出于性能方面的考虑，应该使用InnoDB表。<code>DELETE</code> 从性能上InnoDB更优，但<code>DELETE FROM table</code>时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用<code>truncate table</code>这个命令。</p></li><li><p><strong>外键</strong></p><p>MyISAM：不支持 </p><p>InnoDB：支持</p></li><li><p><strong>查询效率</strong></p><p>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>推荐考虑使用InnoDB来替代MyISAM引擎，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。</p><p>另外，任何一种表都不是万能的，只有恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p></li><li><p><strong>MyISAM和InnoDB两者的应用场景：</strong></p><p>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的<code>SELECT</code>查询，那么MyISAM是更好的选择。 </p><p>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的<code>INSERT</code>或<code>UPDATE</code>操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。现在默认最常使用InnoDB。</p></li></ol><h3 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h3><blockquote><p>  我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：</p><ol><li><p>你要把哪些字符映射成二进制数据？也就是界定清楚字符范围。</p></li><li><p>怎么映射？</p><p> 将一个字符映射成一个二进制数据的过程也叫做<strong>编码</strong>，将一个二进制数据映射到一个字符的过程叫做<strong>解码</strong>。</p></li></ol></blockquote><p>人们抽象出一个字符集的概念来描述某个字符范围的编码规则，以下是一些常用字符集：</p><ul><li><p><code>ASCII</code> 字符集</p><p>共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'L' -&gt; 01001100（十六进制：0x4C，十进制：76）</span><br><span class="line">'M' -&gt; 01001101（十六进制：0x4D，十进制：77）</span><br></pre></td></tr></table></figure></li><li><p><code>ISO 8859-1</code> 字符集</p><p>共收录256个字符，是在ASCII 字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以<br>使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code> 。</p></li><li><p><code>GB2312</code> 字符集</p><p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>  字符集，所以在编码方式上显得有些奇怪：</p><ul><li>如果该字符在ASCII 字符集中，则采用1字节编码。否则采用2字节编码。</li></ul><p>这种表示一个字符需要的字节数可能不同的编码方式称为<strong>变长编码方式</strong>。比方说字符串’爱u’ ，其中’爱’ 需要用2个字节进行编码，编码后的十六进制表示为0xCED2 ， ‘u’ 需要用1个字节进行编码，编码后的十六进制表示为0x75 ，所以拼合起来就是0xCED275 。</p></li><li><p><code>GBK</code> 字符集</p><p><code>GBK</code> 字符集只是在收录字符范围上对<code>GB2312</code> 字符集作了扩充，编码方式上兼容<code>GB2312</code> 。</p></li><li><p><code>Unicode</code> 字符集</p><p>也称为万国码，收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code> 字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'L' -&gt; 01001100（十六进制：0x4C）</span><br><span class="line">'啊' -&gt; 111001011001010110001010（十六进制：0xE5958A）</span><br></pre></td></tr></table></figure><blockquote><p>  我们常用的<code>utf8</code>只是<code>Unicode</code>字符集的一种编码方案，<code>Unicode</code>字符集可以采用<code>utf8</code>、<code>utf16</code>、<code>utf32</code>这几种编码方案，<code>utf8</code>使用1～4个字节编码一个字符，<code>utf16</code>使用2个或4个字节编码一个字符，<code>utf32</code>使用4个字节编码一个字符</p></blockquote></li></ul><p>对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字’我’ 来说， <code>ASCII</code> 字符集中根本没有收录这个字符， utf8 和gb2312 字符集对汉字’我’的编码方式如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf8编码：  111001101000100010010001 (3个字节，十六进制表示是：0xE68891)</span><br><span class="line">gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2)</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>更多关于字符集和编码的内容可以看下面这篇文章</strong></p><p>  <strong><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></strong></p></blockquote><h4 id="MySQL中的utf8和utf8mb4"><a href="#MySQL中的utf8和utf8mb4" class="headerlink" title="MySQL中的utf8和utf8mb4"></a>MySQL中的utf8和utf8mb4</h4><p>我们上边说<code>utf8</code> 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以MySQL的设计人员定义了两个概念：</p><ul><li><code>utf8mb3</code> ：阉割过的utf8 字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code> ：正宗的utf8 字符集，使用1～4个字节表示字符。</li></ul><p><strong>注意：</strong>在MySQL 中，utf8指的是utf8mb3，所以之后在MySQL中提到utf8 就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4 。</p><blockquote><p>  <strong>字符集的查看</strong></p><p>  MySQL 支持多种字符集，查看当前MySQL 中支持的字符集可以用下边这个语句：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show charset;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Mysql数据库与数据表操作"><a href="#Mysql数据库与数据表操作" class="headerlink" title="Mysql数据库与数据表操作"></a>Mysql数据库与数据表操作</h2><blockquote><p>  <strong>库和表的概念与关系</strong></p><p>  库就像是文件夹，库中可以有很多个表，表就像是我们的excel表格文件一样，每一个表中都可以存储很多数据。</p><p>  mysql中可以有很多不同的库，库中可以有很多不同的表，表中可以定义不同的列（字段），表中可以根据结构去存储很多的数据。</p></blockquote><h3 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h3><h4 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 链接mysql数据库后，进入mysql后可以操作数据</span><br><span class="line"># 创建库</span><br><span class="line">create database if not exists test default charset&#x3D;utf8mb4;</span><br><span class="line">-- 1. 数据库 test 如果不存在则创建数据库，存在则不创建</span><br><span class="line">-- 2. 创建 test 数据库，并设置字符集为utf8</span><br><span class="line">-- 3. 无特殊情况都要求字符集为utf8或者utf8mb4的字符编码</span><br></pre></td></tr></table></figure><h4 id="查看所有库"><a href="#查看所有库" class="headerlink" title="查看所有库"></a>查看所有库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有库</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><h4 id="打开库-进入库-选择库"><a href="#打开库-进入库-选择库" class="headerlink" title="打开库/进入库/选择库"></a>打开库/进入库/选择库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># use 库名</span><br><span class="line">use test;</span><br></pre></td></tr></table></figure><h4 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h4><blockquote><p>  <font color=red>删库有风险，动手需谨慎！！！</font></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除库，库中的所有数据都将在磁盘中删除。</span><br><span class="line">drop database 库名</span><br></pre></td></tr></table></figure><h3 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(字段名，类型，[字段约束]，…)；</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 以下创建一个 users 的表</span><br><span class="line">create table if not exists users(</span><br><span class="line">-- 创建ID字段，为正整数，不允许为空 主键，自动递增</span><br><span class="line">id int unsigned not null primary key auto_increment,</span><br><span class="line">-- 创建存储 名字 的字段，为字符串类型，最大长度5个字符，不允许为空</span><br><span class="line">username varchar(5) not null,</span><br><span class="line">-- 创建存储 密码 的字段，固定长度 32位字符， 不允许为空</span><br><span class="line">password char(32) not null,</span><br><span class="line">-- 创建存储 年龄 的字段，不允许为空，默认值为 20</span><br><span class="line">age tinyint not null default 20</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8mb4;</span><br><span class="line">-- 表引擎innodb 字符集utf8mb4</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">desc users;</span><br><span class="line"></span><br><span class="line">#查看建表语句</span><br><span class="line">show create table users;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/07/ERAg51wJ43vdKNF.png" alt=""></p><p><strong>创建表的基本原则：</strong></p><ul><li>表明和字段名 尽可能的符合命名规范，并且最好能够‘见名之意’</li><li>表中数据必须有唯一标识，即主键定义。无特殊情况，主键都为数字并自增即可</li><li>表中字段所对应的类型设置合理，并限制合理长度</li><li>表引擎推荐使用innodb，并无特殊情况都要求为utf8或者utf8mb4的字符编码</li></ul><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 action (更改的选项)</span><br></pre></td></tr></table></figure><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 添加的字段信息</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 在 users 表中 追加 一个 num 字段 int类型 不为空 默认加在最后面</span><br><span class="line">alter table users add num int not null;</span><br><span class="line">-- 在指定字段后面追加字段 在 users 表中 age字段后面 添加一个 email 字段</span><br><span class="line">alter table users add email varchar(50) after age;</span><br><span class="line">-- 在指定字段后面追加字段，在 users 表中 age字段后面 添加一个 phone</span><br><span class="line">alter table users add phone char(11) not null after age;</span><br><span class="line">-- 在表的最前面添加一个字段</span><br><span class="line">alter table users add aa int first;</span><br></pre></td></tr></table></figure><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除字段 alter table 表名 drop 被删除的字段名</span><br><span class="line">alter table users drop aa;</span><br></pre></td></tr></table></figure><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change|modify 被修改的字段信息</span><br><span class="line"># change: 可以修改字段名，</span><br><span class="line"># modify: 不能修改字段名。</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改表中的 num 字段 类型,使用 modify 不修改字段名</span><br><span class="line">alter table users modify num tinyint not null default 12;</span><br><span class="line"># 修改表中的 num 字段 为 int 并且 字段名改为 mm</span><br><span class="line">alter table users change num mm int;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>注意：一般情况下，无特殊要求，不要轻易修改表结构</strong></p></blockquote><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 原表名 rename as 新表名;</span><br></pre></td></tr></table></figure><h4 id="更改表中自增的值"><a href="#更改表中自增的值" class="headerlink" title="更改表中自增的值"></a>更改表中自增的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在常规情况下，auto_increment 默认从1开始继续递增</span><br><span class="line"># 更改自增值让其从1000开始</span><br><span class="line">alter table users auto_increment &#x3D; 1000;</span><br></pre></td></tr></table></figure><blockquote><p>  <font color = red> 注意：</font></p><p>  更改之后，只对后面再增加的数据有影响，对已存在的数据没有影响。</p></blockquote><h4 id="修改表引擎"><a href="#修改表引擎" class="headerlink" title="修改表引擎"></a>修改表引擎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 推荐在定义表时，表引擎定义为 innodb。</span><br><span class="line"># 通过查看建表语句获取当前的表引擎</span><br><span class="line">mysql&gt; show create table users\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Table: users</span><br><span class="line">Create Table: CREATE TABLE &#96;users&#96; (</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">    ....</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1001 DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 直接查看当前表状态信息</span><br><span class="line">mysql&gt; show table status from test where name &#x3D; &#39;users&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Name: users</span><br><span class="line">   Engine: InnoDB</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line"># 修改表引擎语句</span><br><span class="line">alter table users engine &#x3D; &#39;myisam&#39;;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名</span><br></pre></td></tr></table></figure><h2 id="MySQL-数据操作——DML"><a href="#MySQL-数据操作——DML" class="headerlink" title="MySQL 数据操作——DML"></a>MySQL 数据操作——DML</h2><blockquote><p>  <strong>数据的DML操作：添加数据，修改数据，删除数据</strong></p></blockquote><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段列表)] values(值列表...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 标准添加（指定所有字段，给定所有的值）</span><br><span class="line">insert into stu(id,name,age,sex,classid) values(1,&#39;zhangsan&#39;,20,&#39;m&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 指定部分字段添加值</span><br><span class="line">insert into stu(name,classid) value(&#39;lisi&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 不指定字段添加值</span><br><span class="line">insert into stu value(null,&#39;wangwu&#39;,21,&#39;w&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line">-- 批量添加值</span><br><span class="line">insert into stu values</span><br><span class="line">(null,&#39;zhaoliu&#39;,25,&#39;w&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;uu01&#39;,26,&#39;m&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;uu02&#39;,28,&#39;w&#39;,&#39;lamp92&#39;),</span><br><span class="line">(null,&#39;qq02&#39;,24,&#39;m&#39;,&#39;lamp92&#39;),</span><br><span class="line">(null,&#39;uu03&#39;,32,&#39;m&#39;,&#39;lamp138&#39;),</span><br><span class="line">(null,&#39;qq03&#39;,23,&#39;w&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;aa&#39;,19,&#39;m&#39;,&#39;lamp138&#39;);</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段1&#x3D;值1,字段2&#x3D;值2,字段n&#x3D;值n... where 条件;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 将id为11的age改为35，sex改为m值</span><br><span class="line">update stu set age&#x3D;35,sex&#x3D;&#39;m&#39; where id&#x3D;11;</span><br><span class="line"></span><br><span class="line">-- 将id值为12和14的数据值sex改为m，classid改为lamp92</span><br><span class="line">update stu set sex&#x3D;&#39;m&#39;,classid&#x3D;&#39;lamp92&#39; where id&#x3D;12 or id&#x3D;14 </span><br><span class="line">update stu set sex&#x3D;&#39;m&#39;,classid&#x3D;&#39;lamp92&#39; where id in(12,14);  -- 等价于上面</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表中id值为100的数据</span><br><span class="line">delete from stu where id&#x3D;100;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值为20到30的数据</span><br><span class="line">delete from stu where id&gt;&#x3D;20 and id&lt;&#x3D;30;</span><br><span class="line">delete from stu where id between 20 and 30;-- 等价于上面</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值大于200的数据</span><br><span class="line">delete from stu where id&gt;200;</span><br></pre></td></tr></table></figure><h2 id="MySQL数据查询——DQL基本语法"><a href="#MySQL数据查询——DQL基本语法" class="headerlink" title="MySQL数据查询——DQL基本语法"></a>MySQL数据查询——DQL基本语法</h2><p>语法格式：<font color = red> sql查询语句 一定要严格按照这样的顺序，否则会产生错误</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表|* from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><p>下面以一个数据表stu为例进行讲解</p><p>SQL示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE &#96;stu&#96;(</span><br><span class="line">&#96;id&#96;  int unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;name&#96; varchar(10) NOT NULL,</span><br><span class="line">&#96;email&#96; char(50) NOT NULL,</span><br><span class="line">&#96;phone&#96; char(11) NOT NULL,</span><br><span class="line">&#96;age&#96; tinyint(4)NOT NULL,</span><br><span class="line">&#96;sex&#96; char(1) DEFAULT NULL,</span><br><span class="line">&#96;class_id&#96; int DEFAULT NULL, </span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">)ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">insert into stu values</span><br><span class="line">(null,&#39;张三&#39;,&#39;zhangsane@qq.com&#39;,&#39;13701184321&#39;,21,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;李四&#39;,&#39;lisi@qq.com&#39;,&#39;13701104322&#39;,22,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;王五&#39;,&#39;wangwu@qq.com&#39;,&#39;13701104323&#39;,20,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;赵六&#39;,&#39;zhaoliu@qq.com&#39;,&#39;13701104324&#39;,19,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;田七&#39;,&#39;tianqi@qq.com&#39;,&#39;13701104325&#39;,23,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;王五六&#39;,&#39;wangwuliu@qq.com&#39;,&#39;13701104326&#39;,23,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;熊大&#39;,&#39;xiongda@qq.com&#39;,&#39;13701184327&#39;,25,&#39;男&#39;,2),</span><br><span class="line">(null,&#39;熊二&#39;,&#39;xionger@qq.com&#39;,&#39;13701104328&#39;,22,&#39;男&#39;,2),</span><br><span class="line">(null,&#39;一一&#39;,&#39;yiyi@qq.com&#39;,&#39;13701184329&#39;,19,&#39;女&#39;,2),</span><br><span class="line">(null,&#39;呀呀&#39;,&#39;yaya@qq.com&#39;,&#39;13701104320&#39;,22,&#39;男&#39;,2);</span><br><span class="line"> </span><br><span class="line"> -- 查看表数据</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><h3 id="检索数据SELECT"><a href="#检索数据SELECT" class="headerlink" title="检索数据SELECT"></a>检索数据<code>SELECT</code></h3><p><strong>检索列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 检索单个列</span><br><span class="line">select name from stu; -- 查询 stu 表中 name （字段）列的所有数据</span><br><span class="line"></span><br><span class="line"># 检索多个列</span><br><span class="line">select id, name, age, sex from stu; </span><br><span class="line"></span><br><span class="line"># 检索所有列</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/C1EtjLHgFfQ76SX.png" alt=""></p><blockquote><p>  如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。</p><p>  返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的</p><p>  <strong>使用通配符 <code>*</code> 的说明：</strong></p><p>  一般除非你确实需要表中的每个列，否则最好别使用 <code>*</code> 通配符。</p><p>  虽然使用通配符，不用明确列出所需列，会使你自己省事，但检索不需要的列通常会降低检索和应用程序的性能。使用通配符有一个优点： 由于不明确指定列名（因为 <code>*</code> 检索每个列），所以能检索出名字未知的列。</p></blockquote><p><strong>检索不同的行（去重） DISTNCT</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检索不同的行（去重） DISTNCT</span><br><span class="line">select distinct class_id from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/No9qvOmStG1z6be.png" alt=""></p><blockquote><p>  DISTINCT关键字指示MySQL只返回不同的值。</p><p>  DISTINCT关键字应用于所有列，而不仅是前置它的列。</p><p>  如果给出<code>SELECT DISTINCT 字段1,字段2,.... FROM xxx;</code>除非指定的列都不同，否则所有行都将被检索出来</p></blockquote><p><strong>使用完全限定的表名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name from stu; -- 无限制</span><br><span class="line">select stu.name from stu; -- 限制字段名 stu.name stu表的name字段</span><br><span class="line">select stu.name from test.stu;  -- 限制表名 test.stu test库的stu表</span><br></pre></td></tr></table></figure><h3 id="WHERE-数据检索条件过滤"><a href="#WHERE-数据检索条件过滤" class="headerlink" title="WHERE 数据检索条件过滤"></a>WHERE 数据检索条件过滤</h3><blockquote><p>  数据库表一般包含大量的数据，很少需要检索表中所有行。</p><p>  通常只会根据特定操作或报告的需要提取表数据的子集。</p><p>  只检索所需数据需要指定搜索条件（search criteria)，搜索条件也称为过滤条件（filtercondition)。</p><p>  在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。</p></blockquote><ul><li>可以在where子句中指定任何条件</li><li>可以使用 and 或者 or 指定一个或多个条件</li><li>where条件也可以运用在update和delete语句的后面</li></ul><p><strong>WHERE 子句操作符</strong></p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td></tr><tr><td><code>&lt;&gt;</code>   <code>!=</code></td><td>不等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>BETWEEN…AND…</code></td><td>指定两值之间</td></tr><tr><td><code>IS NULL</code></td><td>空值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 age &gt; 22的数据</span><br><span class="line">select * from stu where age &gt; 22;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 name&#x3D;某个条件值 的数据</span><br><span class="line">select * from stu where name &#x3D; &#39;王五&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 sex 为 null 的数据</span><br><span class="line">select * from stu where sex is null;</span><br></pre></td></tr></table></figure><p><strong>组合WHERE子句</strong></p><blockquote><p>   MySQL允许给出多个WHERE子句。</p><p>   这些子句可以两种方式使用：以<code>AND</code>子句的方式或<code>OR</code>子句的方式使用。也称为逻辑操作符</p><ul><li><code>AND</code> 检索满足<strong>所有</strong>给定条件的行</li><li><code>OR</code>   检索满足<strong>任一</strong>给定条件的行</li></ul></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 年龄在22到25之间的数据</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age &lt;&#x3D; 25;</span><br><span class="line">select * from stu where age between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄不在22到25之间的数据</span><br><span class="line">select * from stu where age &lt; 22 or age &gt; 25;</span><br><span class="line">select * from stu where age not between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的女生信息</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age &lt;&#x3D; 25 and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong><font color=red>注意</font></strong></p><p>  <code>and</code> 和 <code>or</code> 在使用时要注意 sql语句优先级的问题，sql会优先处理<code>and</code>条件</p><p>  比如下面语句：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age&#x3D;22 or age &#x3D; 25 and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><p>  假如要求查询 users 表中 年龄为22或者25 的女生信息，上面语句查询的结果就不能符合我们的要求。</p><p>  上面语句查询的是 （年龄为22的所有人） 或者 （年龄为25的女生）信息：</p><p>  要达到我们要求的查询，可以用小括号来提升优先级</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where (age&#x3D;22 or age &#x3D; 25) and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure></blockquote><p><strong><code>IN</code>与<code>NOT</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 id 是1或2或3的数据</span><br><span class="line">select * from stu where id in (1,2,3);</span><br><span class="line">-- 查询 stu 表中 id 不是1 也不是2 也不是3的数据</span><br><span class="line">select * from stu where id not in (1,2,3);</span><br></pre></td></tr></table></figure><blockquote><p>  <code>IN</code> 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。功能与<code>OR</code>相当</p><p>  <code>NOT</code> 用于否定后跟进的条件</p><p>  与<code>OR</code>，相比，使用<code>IN</code>的优点</p><ul><li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li><li>IN操作符一般比OR操作符清单执行更快。</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li></ul></blockquote><p><strong>通配符的使用 <code>LIKE</code></strong></p><p>我们可以在where条件中使用 <code>=</code>，<code>&lt;</code>，<code>&gt;</code> 等符号进行条件的过滤，但是当想查询某个字段是否包含某个字符时如何过滤呢？例如： 查询 name字段中包含五的数据</p><p>可以使用<code>LIKE</code>语句进行某个字段的模糊搜索。</p><p><strong>常用通配符：</strong></p><ul><li>百分号(<code>%</code>) ：表示任意字符出现任意次数</li><li>下划线(<code>_</code>)：用途与<code>%</code>类似，但下划线只匹配单个字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- like 语句 like某个确定的值 和。where name &#x3D; &#39;王五&#39; 是一样</span><br><span class="line">select * from stu where name like &#39;王五&#39;;</span><br><span class="line"></span><br><span class="line">-- 使用 % 模糊搜索。%代表任意个任意字符</span><br><span class="line">-- 查询name字段中包含五的</span><br><span class="line">select * from stu where name like &#39;%五%&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询name字段中最后一个字符 为 五的</span><br><span class="line">select * from stu where name like &#39;%五&#39;;</span><br><span class="line">   </span><br><span class="line">    -- 查询name字段中第一个字符 为 王 的</span><br><span class="line">select * from stu where name like &#39;王%&#39;;</span><br><span class="line"></span><br><span class="line">-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似</span><br><span class="line">-- 查询表中 name 字段为两个字符的数据</span><br><span class="line">select * from stu where name like &#39;__&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 name 字段最后为 五 的两个字符的数据</span><br><span class="line">select * from stu where name like &#39;_五&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>where子句中的like在使用<code>%</code>或者<code>_</code>进行模糊搜索时，所花时间更长，效率不高，使用时注意：</strong></p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，尽量使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据</li></ul></blockquote><blockquote><p>  MySql中也支持正则表达式，使用 <code>REGEXP</code> 关键字来匹配。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 id 为 3到8 的所有数据</span><br><span class="line">select * from stu where id regexp &#39;[3-8]&#39;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="字段的计算"><a href="#字段的计算" class="headerlink" title="字段的计算"></a>字段的计算</h3><p>存储在数据库表中的数据一般不是应用程序所需要的格式。下面举几个例子:</p><ul><li>如果想在一个字段中既显示用户名，又显示班级号，但这两个信息一般包含在不同的表列中。</li><li>同时姓名、手机号和地址存储在不同的列中（应该这样）,但快递单打印程序却需要把它们作为一个恰当格式的字段检索出来。</li><li>列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。</li><li>物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可）。为打印发票需要物品的总价格。</li><li>需要根据表数据进行总数、平均数计算或其他计算</li></ul><p><strong>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的</strong></p><p><strong>拼接Concat</strong></p><p>stu表包含用户名和手机号码信息。假如要生成一个学生报表，需要在学生的名字中按照name(phone)这样的<br>格式列出</p><p>解决办法是把两个列拼接起来。在MySQL的SELECT语句中，可使用<code>concat()</code>函数来拼接两个列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(name ,&#39;(&#39;, phone,&#39;)&#39;) from stu;</span><br></pre></td></tr></table></figure><p><strong>使用别名AS</strong></p><p>SELECT语句拼接字段可以完成。但此新计算列的名字是什么呢？实际上它没有名字，它只是一个值。<br>如果仅在SQL查询工具中查看一下结果，这样没有什么不好。</p><p>但是，一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。</p><p>为了解决这个问题，SQL支持列别名。别名（alias)是一个字段或值的替换名。别名用<code>AS</code>关键字赋予</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(name ,&#39;(&#39;,phone,&#39;)&#39;) as name_phone from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/i8v9tsl1JkrISmE.png" alt=""></p><h3 id="MySql查询常用函数"><a href="#MySql查询常用函数" class="headerlink" title="MySql查询常用函数"></a>MySql查询常用函数</h3><blockquote><p>  与其他大多数计算机语言一样，SQL支持利用函数来处理数据。</p><p>  函数一般是在数据上执行的，它给数据的转换和处理提供了方便。</p></blockquote><p><strong>文本处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/string-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/string-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/kfDA5FUwxgGN6jz.png" alt="image-20201108204526003"></p><p><strong>日期和时间处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/a8mH6gLkY5zOpbS.png" alt=""></p><blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据出生日期计算年龄</span></span><br><span class="line">TIMESTAMPDIFF(YEAR, @birthday, CURDATE()) </span><br></pre></td></tr></table></figure></blockquote><p><strong>数值处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/numeric-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/fkPm93ciztJb7uA.png" alt=""></p><h3 id="Mysql中的统计函数（聚合函数）"><a href="#Mysql中的统计函数（聚合函数）" class="headerlink" title="Mysql中的统计函数（聚合函数）"></a>Mysql中的统计函数（聚合函数）</h3><blockquote><p>  我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。</p><p>  使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成</p></blockquote><ul><li><code>max()</code>  返回某列最大值</li><li><code>min()</code> 返回某列最小值</li><li><code>count()</code> 返回某列的行数</li><li><code>sum()</code>  返回某列值和</li><li><code>avg()</code>    返回某列的平均值</li></ul><blockquote><p>  在使用count时，如果指定列名，则指定列的值为空的行被忽略，但如果COUNT函数中用的是星号（*）,则不忽略。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄</span><br><span class="line">select max(age),min(age),sum(age),avg(age) from stu;</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| max(age) | min(age) | sum(age) | avg(age) |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">|       25 |       19 |      216 |  21.6000 |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化</span><br><span class="line">select max(age) as max_age,</span><br><span class="line">min(age) as min_age,</span><br><span class="line">sum(age) as sum_age,</span><br><span class="line">avg(age) as avg_age from stu;</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">| max_age | min_age | sum_age | avg_age |</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">|      25 |      19 |     216 | 21.6000 |</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">-- 统计 users 表中的数据量</span><br><span class="line">select count(*) from stu;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       10 |</span><br><span class="line">+----------+</span><br><span class="line">select count(id) from stu;</span><br><span class="line">+----------+</span><br><span class="line">| count(id)|</span><br><span class="line">+----------+</span><br><span class="line">|       10 |</span><br><span class="line">+----------+</span><br><span class="line"></span><br><span class="line">-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？</span><br><span class="line">-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算</span><br><span class="line">-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，</span><br><span class="line">-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计</span><br><span class="line">-- 假设有下面这样的一张表需要统计</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">| id   | name      |  age |  phone |     email |  sex | mm   |</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">| 1000 | aa        | 20   | 123    | NULL      | 男   | NULL |</span><br><span class="line">| 1001 | bb        | 20   | 123456 | NULL      | 男   | NULL |</span><br><span class="line">| 1002 | cc        | 25   | 123    | NULL      | 女   | NULL |</span><br><span class="line">| 1003 | dd        | 20   | 456    | NULL      | 女   | NULL |</span><br><span class="line">| 1004 | ff        | 28   | 789    | NULL      | NULL | NULL |</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">-- 如果按照sex这一列进行统计，结果就是4个而不是5个，因为sex这一列中有NULL值存在</span><br><span class="line">mysql&gt; select count(sex) from stu;</span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">| 4          |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>聚合函数除了以上简单的使用以外，通常情况下都是配合着分组进行数据的统计和计算</p><h3 id="GROUP-BY-分组"><a href="#GROUP-BY-分组" class="headerlink" title="GROUP BY 分组"></a>GROUP BY 分组</h3><p><code>group by</code> 语句根据一个或多个列对结果集进行分组</p><p>一般情况下，是用于数据的统计或计算，配合聚合函数使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 统计 users 表中 男女生人数,</span><br><span class="line">-- 很明显按照上面的需要，可以写出两个语句进行分别统计</span><br><span class="line">select count(*) from stu where sex &#x3D; &#39;女&#39;;</span><br><span class="line">select count(*) from stu where sex &#x3D; &#39;男&#39;;</span><br><span class="line">-- 可以使用分组进行统计，更方便</span><br><span class="line">select sex,count(*) from stu group by sex;</span><br><span class="line"></span><br><span class="line">-- 统计1班和2班的人数</span><br><span class="line">select class_id,count(*) from stu group by class_id;</span><br><span class="line"></span><br><span class="line">-- 分别统计每个班级的男女生人数</span><br><span class="line">select class_id,sex,count(*) as num from stu group by class_id,sex;</span><br></pre></td></tr></table></figure><p>注意：在使用<code>group by</code>分组时，一般除了聚合函数，其它在<code>select</code>后面出现的字段列都需要出现在<code>grouop by</code> 后面。</p><p><strong><code>HAVING</code>子句</strong></p><p><code>having</code> 在分组聚合计算后，对结果再一次进行过滤，类似于where，where过滤的是行数据，having过滤的是分组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 要统计班级人数</span><br><span class="line">select class_id,count(*) from stu group by classid;</span><br><span class="line">-- 统计班级人数，并且要人数达到5人及以上</span><br><span class="line">select class_id,count(*) as num from stu group by class_id having num &gt;&#x3D;5;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-对检索数据进行排序"><a href="#ORDER-BY-对检索数据进行排序" class="headerlink" title="ORDER BY 对检索数据进行排序"></a>ORDER BY 对检索数据进行排序</h3><blockquote><p>  默认查询出的数据，并不是随机排序的，如果没有指定排序，数据一般将以它在底层表中出现的顺序显示，关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p></blockquote><p>我们在mysql中使用<code>select</code>的语句查询的数据结果是根据数据在底层文件的结构来排序的，在需要排序时可以使用<code>order by</code>对返回的结果进行排序</p><p><code>order by</code>asc 升序，默认</p><ul><li>desc 降序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 按照年龄对结果进行排序，</span><br><span class="line">-- 从大到小</span><br><span class="line">select * from users order by age desc;</span><br><span class="line">-- 从小到大排序 asc 默认可以不写</span><br><span class="line">select * from users order by age;</span><br><span class="line">-- 也可以按照多个字段进行排序</span><br><span class="line">select * from users order by age,id; # 先按照age进行排序，age相同情况下，按照id进行排序 升序</span><br><span class="line">select * from users order by age,id desc; -- 降序</span><br></pre></td></tr></table></figure><h3 id="限制结果-LIMIT"><a href="#限制结果-LIMIT" class="headerlink" title="限制结果 LIMIT"></a>限制结果 LIMIT</h3><ul><li><code>limit n</code> 提取n条数据，</li><li><code>limit m,n</code> 跳过m条数据，提取后面的n条数据</li><li><code>limit n offset m</code>  跳过m条数据，提取后面的n条数据 ，等同于<code>limit m,n</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 查询stu 表中的数据，只要3条</span><br><span class="line">select * from stu limit 3;</span><br><span class="line"></span><br><span class="line">-- 跳过前3条数据，再取4条数据</span><br><span class="line">select * from stu limit 3,4;</span><br><span class="line">select * from stu limit 4 offset 3;</span><br><span class="line">-- limit一般应用在数据分页上面</span><br><span class="line">-- 例如每页显示10条数据</span><br><span class="line">第一页 limit 0,10</span><br><span class="line">第二页 limit 10,10</span><br><span class="line">第三页 limit 20,10</span><br><span class="line">第四页 limit 30,10</span><br><span class="line">...</span><br><span class="line">-- 查询stu 表中年龄最大的两个人的信息</span><br><span class="line">select * from stu order by age desc limit 2;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/WmOsZi8a5KjRMSN.png" alt="image-20201108191010335"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>mysql中的查询语句比较灵活多样，并且在使用查询语句时，一定要注意sql的正确性和顺序。</p><p><img src="https://i.loli.net/2020/11/08/qoVjDgp12uvzaYw.png" alt="image-20201108162518097"></p><h2 id="Mysql数据库导入导出和授权"><a href="#Mysql数据库导入导出和授权" class="headerlink" title="Mysql数据库导入导出和授权"></a>Mysql数据库导入导出和授权</h2><h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><ul><li><strong>数据库数据导出</strong>：在命令行中然后输入以下命令 导出某个库中的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p 库名 &gt; 要保存的文件路径/xxx.sql</span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">mysqldump -u root -p <span class="built_in">test</span> &gt; D://test.sql</span><br></pre></td></tr></table></figure><p>导出一个库中所有数据，会形成一个建表和添加语句组成的sql文件</p><p><img src="https://i.loli.net/2020/11/08/DY6nwXKyW9lefOI.png" alt=""></p><ul><li><strong>将数据库中的表导出</strong> :在命令行中然后输入以下命令 导出某个库中指定表的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p 库名 表名 &gt; 要保存的文件路径/xxx.sql</span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">mysqldump -u root -p <span class="built_in">test</span> users &gt; D://<span class="built_in">test</span>-users.sql</span><br></pre></td></tr></table></figure><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>把导出的sql文件数据导入到mysql数据库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在新的数据库中 导入备份的数据，导入导出的sql文件</span><br><span class="line">mysql -u root -p 新建的库名 &lt; 路径&#x2F;xxx.sql</span><br><span class="line"># 把导出的表sql 导入数据库</span><br><span class="line">mysql -u root -p 新建的库名 &lt; 路径&#x2F;xxx.sql</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><blockquote><p>  mysql中的root用户是数据库中权限最高的用户，千万不要用在项目中。</p><p>  可以给不同的用户，或者项目，创建不同的mysql用户，并适当的授权，完成数据库的相关操作，这样就在一定程度上保证了数据库的安全。</p></blockquote><p>创建用户的语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 授权的操作 on 授权的库.授权的表 to 账户@登录地址 identified by &#39;密码&#39;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql中 创建一个 zhangsan 用户，授权可以对test这个库中的所有表 进行 添加和查询 的权限</span><br><span class="line">grant select,insert on test.* to zhangsan@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line"># 用户 lisi，密码 123456 可以对test库中的所有表有所有操作权限</span><br><span class="line">grant all on test.* to lisi@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line"># 删除用户 lisi</span><br><span class="line">drop user &#39;lisi&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库介绍&quot;&gt;&lt;a href=&quot;#数据库介绍&quot; class=&quot;headerlink&quot; title=&quot;数据库介绍&quot;&gt;&lt;/a&gt;数据库介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是数据库&lt;/p&gt;
&lt;p&gt;数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库
      
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.pengspace.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>移动端布局</title>
    <link href="https://www.pengspace.top/2020/11/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    <id>https://www.pengspace.top/2020/11/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/</id>
    <published>2020-11-16T11:31:49.000Z</published>
    <updated>2020-11-16T11:38:17.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端现状"><a href="#移动端现状" class="headerlink" title="移动端现状"></a>移动端现状</h2><ul><li>内核<ul><li>当前国产主流手机浏览器，内核都是Webkit</li></ul></li><li>分辨率：手机分辨率，碎片化太多<ul><li>Android：480x800, 480x854, 540x960, 720x1280，1080x1920 等</li><li>iPhone：640x960, 640x1136, 750x1334, 1242x2208 等</li><li>2K、4K等高分辨率</li></ul></li></ul><p>在开发过程中，Google chrome是主要模拟手机的手段之一，步骤：</p><ol><li><p>鼠标右键 检查 或 F12 控制器界面方向；</p></li><li><p>选择 手机模式</p></li><li><p>选择 手机类型及尺寸；调节适当的显示比例；</p></li><li><p>点右键 查看 页面元素；</p></li></ol><p><img src="https://i.loli.net/2020/11/05/Gkg6KFxR7IHm3ZJ.png" alt=""></p><h2 id="viewport-视口"><a href="#viewport-视口" class="headerlink" title="viewport(视口)"></a>viewport(视口)</h2><p><strong>定义：</strong></p><p>视口：浏览器（PC、移动端）显示页面内容的屏幕区域；不同的屏幕的大小，我们看到的区域也是不同的；</p><p>PC端的页面直接放入手机屏显示，不友好，可以用viewport来解决</p><p><img src="https://i.loli.net/2020/11/05/s1gtWMJ95GX42j3.png" alt="image-20201105130620315"></p><p><img src="https://i.loli.net/2020/11/05/Y7wazID9g2hUQGO.png" alt=""></p><p>HTML宽度默认为980px，不是很合适；</p><blockquote><p>  各手机型号尺寸：</p><table><thead><tr><th>设备</th><th>尺寸（英寸）</th><th>开发尺寸（px）</th><th>物理像素比（dpr）</th></tr></thead><tbody><tr><td>iphone3G</td><td>3.5</td><td>320*480</td><td>1.0</td></tr><tr><td>iphone4/4s</td><td>3.5</td><td>320*480</td><td>2.0</td></tr><tr><td>iphone5/5s/5c</td><td>4.0</td><td>320*568</td><td>2.0</td></tr><tr><td>HTC One M8</td><td>4.5</td><td>360*640</td><td>3.0</td></tr><tr><td>iphone6</td><td>4.7</td><td>375*667</td><td>2.0</td></tr><tr><td>Nexus4</td><td>4.7</td><td>384*640</td><td>2.0</td></tr><tr><td>Nexus5x</td><td>5.2</td><td>411*731</td><td>2.6</td></tr><tr><td>iphone6 Plus</td><td>5.5</td><td>414*736</td><td>3.0</td></tr><tr><td>Samsung Galaxy Note4</td><td>5.7</td><td>480*853</td><td>3.0</td></tr><tr><td>Sony Xperia Z Ultra</td><td>6.4</td><td>540*960</td><td>2.0</td></tr><tr><td>Nexus 7(‘12)</td><td>7.0</td><td>600*960</td><td>1.3</td></tr><tr><td>iPad Mini</td><td>7.9</td><td>768*1024</td><td>1.0</td></tr></tbody></table></blockquote><p>那么设置HTML宽度多少为合适呢？设置为屏幕的窗口大小应该正好合适</p><p><strong>设置viewport</strong></p><p>meta标签设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0,maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>width=device-width</code>：改变HTML默认的980px 为 屏幕的宽度；</p><p><code>user-scalable</code>: 是否允许用户缩放屏幕 值：no(0不允许) yes(1允许)；</p><p><code>initial-scale</code>：初始化缩放比例；1.0：不缩放；</p><p><code>maximum-scale</code>：用户对页面的最大缩放比例；值：比例</p><p><code>minimum-scale</code>：用户对页面的最小缩放比例；值：比例</p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><p><strong>物理像素点</strong></p><ul><li>指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光<br>点。每个点可以发一个颜色，就是我们看到的画面。</li><li>早期的屏幕，物理像素点都比较大，随着技术的进步，物理像素点会被做的越来越小。</li></ul><p><strong>屏幕分辨率</strong></p><ul><li>由物理像素点的个数来衡量，表示屏幕水平和垂直方向的物理像素点的个数。</li></ul><blockquote><p>  例如：iPhone3和iPhone4是同一个屏幕尺寸下，比较分辨率：</p><p>  <img src="https://i.loli.net/2020/11/05/tmYVi7JlQxLUeup.png" alt=""></p><p>  Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里；从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p><p>  <img src="https://i.loli.net/2020/11/05/NfyYevr6w3DQa1q.png" alt="image-20201105133553373"></p></blockquote><p><strong>图片分辨率</strong></p><p>假设：有200*200分辨率的图片，展示在宽度分别是320（iphone3）、640(iphone4)分辨率的手机上，展示<br>的效果如下：</p><p><img src="https://i.loli.net/2020/11/05/AKrpNHldgYZSI6F.png" alt="image-20201105133722991"></p><p>可以看出，不同的屏幕下，显示的图片大小是不一样的；物理像素点的宽度大小为1：0.5，物理像素点的数量：320（1 x 200=200长度）、640(0.5 x 400=200长度；都设为是200长度，才能保证显示的大小一样，这时320的屏幕是200像素点，而640的屏幕是400个像素点。</p><p>在移动端，我们可以通过设置CSS样式宽高200px后，会自动保证每个屏幕显示元素大小一样，它会自动算出不同屏幕下，背后需要提供物理像素点需要多少个。</p><p><strong>二倍图</strong></p><p>像针对640分辨率手机屏（iPhone4），要求设计给400*400图，对应我们CSS设置200px,有二倍的关系：</p><p>命名：</p><ul><li><a href="mailto:xxxxx@2x.png">xxxxx@2x.png</a>：二倍图</li><li><a href="mailto:xxxxx@3x.png">xxxxx@3x.png</a>：三倍图</li></ul><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><p>了解常见布局不同，针对业务需求选择不同的方案；实际开发过程中，都是混合使用，没有哪一种是绝对的<br>单独使用。</p><p>常见布局包括以下几种方式</p><ul><li>单独制作移动端页面<ul><li>流式布局 (百分比布局)</li><li>flex弹性布局 (强列推荐)</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul></li><li>响应式页面兼容移动端<ul><li>媒体查询</li><li>bootstrap</li></ul></li></ul><p>比较：</p><ul><li>单独制作：流式、flex、rem布局、专门针对各种手机屏幕进行开发。例如：淘宝、京东、苏宁手机端都是单独制作的</li><li>响应式：可兼容PC 移动端，一个页面多个端适配显示；制作起来要考虑到兼容性的样式。例如：三星电子官网<a href="http://www.samsung.com/cn/" target="_blank" rel="noopener">www.samsung.com/cn/</a> 就是响应式布局</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>看下面代码，左右两部分以百分比来定义宽度，这样无论屏幕如何变化都可以保证效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        *&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.op</span>&#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.op</span>&gt;<span class="selector-tag">div</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            width: 40%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            width: 60%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"op"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>参考<a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p><h4 id="flex介绍"><a href="#flex介绍" class="headerlink" title="flex介绍"></a>flex介绍</h4><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p><strong>传统布局与flex布局比较：</strong></p><ul><li><p>传统布局：</p><ul><li>兼容性好、布局繁琐、浮动（清除浮动）</li><li>有局限性不能在移动端很好的布局</li></ul></li><li><p>flex布局：</p><ul><li>操作方便，布局极其简单，移动端使用比较广泛</li><li>PC端浏览器支持情况比较差</li></ul><blockquote><p>  如果是PC端页面布局，采用传统方式；如果是移动端或者是不考虑兼容的PC端则采用flex布局</p></blockquote></li></ul><p><strong>flex布局特点：</strong></p><ul><li>任何一个容器标签都可以指定使用 flex 布局。</li><li><font color = red>当为父标签设为 flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</font></li><li>使用思想上和传统盒子完全不同，不要再想子元素是块级元素、行内元素，</li><li>flex通过行和列的思路来控制布局；</li></ul><p><strong>基本概念：</strong></p><p>采用 flex 布局的元素，称为 flex 容器（flex container），父级简称”<strong>容器</strong>“。它的所有子元素自动成为容器成员，称为 flex 项目（flex item），简称”<strong>项目</strong>“。</p><p><img src="https://i.loli.net/2020/11/05/Oznr9KpjHYfoLe8.png" alt=""></p><p><strong>语法使用：</strong></p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p>容器属性有以下6个</p><ul><li><code>flex-direction</code></li><li><code>flex-wrap</code></li><li><code>flex-flow</code></li><li><code>justify-content</code></li><li><code>align-items</code></li><li><code>align-content</code></li></ul><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p> <code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。元素默认按照确认的主轴方向进行排布。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction:row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><p>它有4个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>row</code> (默认值)</td><td align="left">水平方向 ，从左到右</td></tr><tr><td align="left"><code>row-reverse</code></td><td align="left">水平方向，从右到左</td></tr><tr><td align="left"><code>column</code></td><td align="left">垂直方向，从上到下</td></tr><tr><td align="left"><code>column-reverse</code></td><td align="left">垂直方向，从下到上</td></tr></tbody></table><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap:nowrap | warp | wrap-reverse;</span><br></pre></td></tr></table></figure><p>它有3个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>nowarp</code>(默认值)</td><td align="left">不换行；子项目加起来的宽度超过父级的宽度时，子项宽度会被缩小，宽度只是不生效，必须设置</td></tr><tr><td align="left"><code>warp</code></td><td align="left">换行，子项的总宽加起来超过父级宽度，就会换行，第一行在上方</td></tr><tr><td align="left"><code>warp-reverse</code></td><td align="left">换行，子项的总宽加起来超过父级宽度，就会换行，第一行在下方</td></tr></tbody></table><h5 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h5><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，类似word里的左对齐，右对齐，居中对齐，分散对齐；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p>它有5个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code>(默认值)</td><td align="left">从头部开始 排列，如果主轴是x轴，则从左到右（左对齐）</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">从尾部开始排列</td></tr><tr><td align="left"><code>center</code></td><td align="left">在主轴居中对齐（如果主轴是x轴 水平居中）</td></tr><tr><td align="left"><code>space-around</code></td><td align="left">每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</td></tr><tr><td align="left"><code>space-between</code></td><td align="left">两端对齐，项目之间的间隔都相等。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/TVsbDKdaExAP8f4.png" alt="image-20201105165428118"></p><h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p><code>align-items</code>属性是控制子项单行在侧轴（交叉轴，默认是y轴）上的对齐方式，在子项为单项（单行）的时候使用；整体一行元素看成整体，设置在侧轴上的对齐方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>它有5个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code></td><td align="left">交叉轴的起点对齐(如果是y轴 ，从上到下）</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">交叉轴的终点对齐</td></tr><tr><td align="left"><code>center</code></td><td align="left">交叉轴的中点对齐。</td></tr><tr><td align="left"><code>stretch</code>(默认值)</td><td align="left">如果项目未设置高度或设为auto，将占满整个容器的高度。</td></tr><tr><td align="left"><code>baseline</code></td><td align="left">项目的第一行文字的基线对齐。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/Pb8shxufpnevYMS.png" alt=""></p><h5 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h5><p><code>align-content</code>属性设置项目在侧轴的排列方式 ，只能用于子项出现换行或者多行的情况,如果项目只有一根轴线(一行)，该属性不起作用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>它有6个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code></td><td align="left">从侧轴头部开始排列</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">从侧轴尾部开始排列</td></tr><tr><td align="left"><code>center</code></td><td align="left">在侧轴中间显示</td></tr><tr><td align="left"><code>stretch</code>(默认值)</td><td align="left">项目高度平分容器高度</td></tr><tr><td align="left"><code>space-between</code></td><td align="left">与侧轴两端对齐，轴线之间的间隔平均分布。</td></tr><tr><td align="left"><code>space-arond</code></td><td align="left">每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/NvrsDGHJ3mp6WM9.png" alt="image-20201105171729060"></p><h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><p>项目属性有以下6个：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h5 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h5><p><img src="https://i.loli.net/2020/11/05/EZfINrvdcjOiazR.png" alt=""></p><h5 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h5><p><img src="https://i.loli.net/2020/11/05/dmEyo3HPGRc9WJK.png" alt="image-20201105172534642"></p><h5 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h5><p><img src="https://i.loli.net/2020/11/05/QTybV43Cfz62JLo.png" alt=""></p><h5 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h5><p><img src="https://i.loli.net/2020/11/05/PIBMRicrzHqlyn2.png" alt=""></p><h5 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h5><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 <code>none</code> (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h5><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了auto，其他5个属性值的含义与<code>align-items</code>属性完全一样。</p><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><blockquote><p>  媒体查询可以感受到屏幕的变化；可以根据屏幕不同的宽，从而获得不同的样式，然后实现不同的样式显示。</p><ol><li><p>CSS3 新语法，是一个查询屏幕的过程，通过查询当前屏幕尺寸属于哪个范围，从而有哪个范围的样式生效；</p></li><li><p>感受屏幕变化，屏幕变化就是宽度的变化，通过预设置，当屏幕到了我已经预设置的变化的范围，就会把我提前设置好的样式进行生效；</p></li></ol></blockquote><p><strong>语法</strong>：CSS样式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mediatype 查询类型:</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">all 所有设备</span></span><br><span class="line"><span class="comment">print 用于打印机和打印预览</span></span><br><span class="line"><span class="comment">screen 用于电脑屏幕，平板电脑，智能手机等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">条件:</span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">and 并且 not 不满足 only 仅仅满足</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">media feature 查询条件:</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">width,min-with,max-width</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123;</span><br><span class="line"><span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong>如果文档宽度小于 500 像素则修改背景颜色(background-color)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* min-width/max-width：最小界值，最大界值；查询条件包含等于号；*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">499px</span>) &#123;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><blockquote><p>  rem是一个相对单位，类似于em，</p><p>  不同的是rem的基准是相对于html元素的字体大小，em是父元素字体大小。</p></blockquote><p>rem让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。</p><p>rem单位，可以控制整个页面所有元素有关PX类（宽、高、padding、margin、top…）只要是你设置数值的地方都可以实现控制；</p><p>根(root): 1 rem代表HTML的font-size大小；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.根html 为 10px */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2.此时 div 的宽就是 150px */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">15rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rem应用：</strong></p><p>使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的适配。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">640px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在屏幕宽度为320px-639px的设备上，div的宽高就都是20px;</span></span><br><span class="line"><span class="comment">在屏幕宽度大与等于640px的设备上，div的宽高就都是40px;*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><ul><li>less : 让你写更少的代码，实现相同的效果；</li><li>less :是一门 CSS 扩展语言，它扩展了CSS的动态特性。 CSS 预处理语言。</li><li>常见的CSS预处理器：Sass、Less、Stylus 。</li><li>Less中文网址：<a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></li></ul><p><strong>less安装：</strong></p><p>sublime安装less和less2Css插件：</p><p><a href="https://blog.csdn.net/redase/article/details/83998172" target="_blank" rel="noopener">https://blog.csdn.net/redase/article/details/83998172</a></p><p>vscode安装less插件：</p><ul><li>在扩展：商店中搜 Easy Less安装即可</li></ul><p>测试：写一个.less文件，保存，就会在当前目录生成一个对应的.css文件</p><p><img src="https://i.loli.net/2020/11/05/SCPpKOIl3Qy4soZ.png" alt="image-20201105205211449"></p><p><strong>less变量</strong></p><p>变量是指没有固定的值，可以改变的。我们CSS中的一些颜色和数值等经常使用，可以设置为变量；语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@变量名:值;</span></span><br><span class="line"><span class="variable">@bg:</span><span class="number">#333</span>;</span><br><span class="line"><span class="selector-class">.box_1</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@bg</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box_2</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@bg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量命名规则：</p><ul><li>必须有@为前缀</li><li>不能包含特殊字符~=+、不能以数字开头</li><li>大小写敏感区分；</li></ul><p><strong>less嵌套</strong></p><p>类似HTML一样写less结构；语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* less 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">.logo &#123;</span><br><span class="line"><span class="selector-tag">width</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交集|伪类|伪元素选择器，语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css写法 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* less写法 */</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">&amp;:hover&#123;</span><br><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less运算</strong></p><p>任何数字、颜色或者变量都可以参与运算，Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span> - <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 颜色</span></span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#666</span> - <span class="number">#222</span>;</span><br><span class="line"><span class="comment">// 注意：运算符中间左右有个空格隔开</span></span><br></pre></td></tr></table></figure><p>运算后的单位选择：</p><ul><li>如果两个值之间只有一个值有单位，则运算结果就取该单位</li><li>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位</li></ul><blockquote><p>  更多less的用法可以访问less的文档</p><ol><li><p><a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></p></li><li><p><a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a></p></li></ol></blockquote><h4 id="两种移动端适配方案"><a href="#两种移动端适配方案" class="headerlink" title="两种移动端适配方案"></a>两种移动端适配方案</h4><h5 id="方案一-：rem-媒体查询-less"><a href="#方案一-：rem-媒体查询-less" class="headerlink" title="方案一 ：rem+媒体查询+less"></a>方案一 ：rem+媒体查询+less</h5><p>上面已经说明过了</p><p>使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的适配。</p><p>大概步骤就是：</p><ol><li>准备各个档位下的rem ：提前准备好各个档位下的HTML 的font-size大小；</li><li>拿到当前尺寸的1rem代表多少px；</li><li>计算比例：把页面刚才所有的元素的PX值替换为rem,可通过less来计算。</li><li>达到目标：那么，屏尺寸变化时，1rem(基础块)也会变化，自然就是等比缩放。</li></ol><h5 id="方案二：rem-flexible-js-less"><a href="#方案二：rem-flexible-js-less" class="headerlink" title="方案二：rem+ flexible.js+less"></a>方案二：rem+ flexible.js+less</h5><p>和上个方案实现原理一样，都是通过改变1rem(基础块)大小实现页面整体元素改变；</p><p><strong>filexible.js</strong></p><ul><li><p>手机淘宝团队出的 简洁高效 移动端适配库；<font color = red>和flex布局没有任何关系</font></p></li><li><p>github地址：<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">https://github.com/amfe/lib-flexible</a></p></li><li><p>不是通过设置CSS媒体查询设置font-size，通过 JS 设置font-size，效果是屏幕变化一点，就有一个rem重新计算；</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// docEl.clientWidth JS获取当前屏幕的宽度</span></span><br><span class="line"><span class="comment">// 除以10,得到基础块,(将屏幕划分为10块)</span></span><br><span class="line"><span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span>;</span><br><span class="line">docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><ul><li><p>假如拿到屏幕宽度按430px设计的设计稿，</p></li><li><p>拿到UI设计稿，原稿实现：页面上所有的元素，在设计稿上进行测量，代码实现；（流式、flex）只要是UI给图上有标注，就是写出来；先全部实现出来，一会儿统一替换；</p><ul><li>在哪里写？less文件</li><li>需要把生成的css文件进行引入index.html；</li></ul></li><li><p>设计稿宽度/10 ：1rem = 43px；</p></li><li><p>统一替换：100px=100/43 rem;</p></li></ul><blockquote><p>  <strong>两种方案的对比</strong></p><ul><li>相同：<ul><li>都是对font-size实现控制，1rem（基础块）变化，实现等比效果；</li></ul></li><li>不同：<ul><li>rem+媒体查询+less：通过设置不同的档位下，设置不同的1rem值；效果为阶梯式变化；</li><li>flexible.js+rem：通过js设置不同的1rem值，效果为连续变化；这个看起来更为连贯，适配任何屏幕。</li></ul></li></ul></blockquote><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>响应式布局可以通过同一份代码快速、有效适配手机、平板、PC设备等所有的屏幕。</p><p>响应式布局涉及屏幕宽度变化(媒体查询)和布局知识[传统布局方案(百分比、浮动、清除浮动、定位)]</p><h4 id="档位划分"><a href="#档位划分" class="headerlink" title="档位划分"></a>档位划分</h4><p>媒体查询：档位划分；市场上默认的划分，三个节点、四个档位</p><ul><li>w&lt;768 超小屏幕（xs）（手机）</li><li>768&lt;= w &lt;992 小屏设备（sm）（平板）</li><li>992&lt;= w &lt;1200 中等屏幕（md）（小显示屏的PC显示器）</li><li>1200&lt;=w 大宽屏设备（lg）（大桌面显示器）</li></ul><p><img src="https://i.loli.net/2020/11/05/tS6KdNzboRBkLiw.png" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把市场上所有屏幕包括在内:*/</span></span><br><span class="line"><span class="comment">/* 1. 超小屏幕下 xs 小于 768 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">0px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 小屏幕下 sm 大于等于768 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 3. 中等屏幕下 md 大于等于 992px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 4. 大屏幕下 lg 大于等于1200 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h4><p>不同的档位下，版心不同；所有的子元素都是归于版心下，不同的版心宽度，意味着子元素要以不同的布局排版满足用户浏览友好的需求；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 超小屏幕下 xs 小于 768 布局容器的宽度为 100% */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">767px</span>) &#123;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 小屏幕下 sm 大于等于768 布局容器改为 750px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 3. 中等屏幕下 md 大于等于 992px 布局容器修改为 970px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 4. 大屏幕下 lg 大于等于1200 布局容器修改为 1170 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意：</p><ul><li>媒体查询使用符号的相关：min-，max-包含等号，后面是数值单位为px；</li><li>除超小屏以外：版心的宽度设置都是小于当前档位最小界值，比如 min-width: 768px，版心是750px；两边留空白，用户体验好。</li><li>以上是市场默认划分，可根据自己需求添加档位；</li></ul></blockquote><h4 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a><a href="https://www.bootcss.com/" target="_blank" rel="noopener">BootStrap</a></h4><p>BootStrap框架可快速搭建出响应式页面；</p><ul><li><p>BootStrap 出自 Twitter（推特），是目前最受欢迎的前端响应式框架。</p></li><li><p>网址：</p><ul><li>中文网：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></li></ul></li><li><p>版本：</p><ul><li>2.x.x：停止维护，代码不够简洁，功能不够完善。</li><li>3.x.x：目前使用最多，稳定，不支持IE6-IE7。对 IE8 支持，界面效果不好，偏向用于开发响应式布局、移动设备优先的WEB 项目。</li><li>4.x.x：最新版，目前还不是很流行</li></ul></li></ul><p><strong>使用</strong></p><p>使用前需要先去官网下载<a href="https://v3.bootcss.com/getting-started/，如无特殊需求，建议下载用于生产环境的。" target="_blank" rel="noopener">https://v3.bootcss.com/getting-started/，如无特殊需求，建议下载用于生产环境的。</a></p><p><img src="https://i.loli.net/2020/11/05/I8aFMTEqcypOxXZ.png" alt=""></p><p>下载完成后，将其整个文件夹放入你的项目中。</p><p> 初始化html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要求 当前网页 使用 IE浏览器 最高版本的内核 来渲染 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>BootStrap Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Bootstrap 的文件引入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--解决ie9以下浏览器对html5新增标签的不识别，并导致CSS不起作用的问题--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--解决ie9以下浏览器对 css3 Media Query 的不识别 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 条件注释:解决小于IE9的版本一些问题 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">        &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>  条件注释：满足条件，下面代码链接就会发出请求；</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[if lt IE 9]</span></span><br><span class="line">&lt;script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span><br><span class="line"><span class="selector-attr">[endif]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h5><ul><li>版心设置：BootStrap 需要为页面内容包裹一个 .container 或者.container-fluid 容器，它提供了两个作此用处的类。</li><li><code>.container</code>：设置不同档位下的版心的宽度；<ul><li>超小屏（xs : extra small）：手机； 0px &lt;=w ；版心宽度为100%</li><li>小屏（sm : small） ：平板； 768px&lt;=w ；版心宽度定为 750px</li><li>中屏（md: medium）：桌面；992px&lt;=w ；版心宽度定为 970px</li><li>大屏（lg: large）：大桌面；1200px&lt;=w ；版心宽度定为 1170px</li></ul></li><li>.container-fluid：百分百宽度；</li><li>特点：<ul><li>所有元素为CSS3盒子模型；</li><li>布局盒子有左右15px padding值；</li></ul></li></ul><h5 id="Bootstrap预制类名"><a href="#Bootstrap预制类名" class="headerlink" title="Bootstrap预制类名"></a>Bootstrap预制类名</h5><ul><li><p>排版</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1. Bootstrap heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>h2. Bootstrap heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>h6. Bootstrap heading<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#type" target="_blank" rel="noopener">https://v3.bootcss.com/css/#type</a></p></li><li><p>按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#buttons" target="_blank" rel="noopener">https://v3.bootcss.com/css/#buttons</a></p></li><li><p>辅助类样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上下文颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-muted"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下拉三角 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"caret"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#helper-classes" target="_blank" rel="noopener">https://v3.bootcss.com/css/#helper-classes</a></p></li><li><p>字体图标</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 搜索🔍 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-search"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/components/#glyphicons" target="_blank" rel="noopener">https://v3.bootcss.com/components/#glyphicons</a></p></li></ul><h5 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a>Bootstrap栅格系统</h5><p>栅格系统可以设置子元素在不同档位下的布局；</p><p>栅格系统，在各个档位下，控制子元素布局不同；将版心宽度均分为12份；</p><p>各个档位下都有预制好的类前缀：</p><p><img src="https://i.loli.net/2020/11/05/v5pARWne17VXTZ9.png" alt=""></p><p>栅格系统用于通过一系列的<strong>行（row）与列（column）的组合</strong>来创建页面布局，你的内容就可以放入这些创建好的布局中，控制不同的档位下，<strong>列的子元素占有几份</strong></p><p><strong>基本使用：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 中屏和以上占有6份 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span>.col-md-6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span>.col-md-6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 各个档位下，按照各个档位下布局 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-4"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-8"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>单一类前缀：各个档位下的类前缀，为包括当前且向上生效；例如：.col-md-6为中屏和以上占有6份；</li><li>多个类前缀：分别按照各个档位列划分生效；</li><li>每个子项：默认左右15px的padding；</li><li>行（.row） 可以去除父容器左右15px的padding值：.row的左右margin为-15px；</li></ul><p><strong>列嵌套</strong></p><p>可以在已经分好的子元素中内部，继续进行列的划分（共12份），继续在分好的布局内继续划分；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接嵌套 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用row嵌套 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加1个行 row 这样可以表现出抵消父元素的左右15padding值 而且高度自动和父级一样高; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>列偏移：</strong></p><p>划分好的子项进行列的份数偏移，场景：左右布局，居中布局；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 左右对齐--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果只有一个盒子 那么就偏移 = 12-4-4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4 col-lg-offset-4"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 居中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果只有一个盒子 那么就偏移 = 2 8 2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-8 col-md-offset-2"</span>&gt;</span>中间盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>栅格系统相关内容可以参考：<a href="https://v3.bootcss.com/css/#grid" target="_blank" rel="noopener">https://v3.bootcss.com/css/#grid</a></p><h5 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h5><p><img src="https://i.loli.net/2020/11/05/HPAdJC73MOzXIbo.png" alt=""></p><ul><li>注意：和列类前缀的参数形成对比记忆，<ul><li>col-sm-* 是超小屏（包含）以上的屏幕都是这个份数的划分；</li><li>响应式工具 只是对当前档位下的类前缀类名生效；</li></ul></li></ul><p>响应式工具相关内容可以参考：<a href="https://v3.bootcss.com/css/#responsive-utilities" target="_blank" rel="noopener">https://v3.bootcss.com/css/#responsive-utilities</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;移动端现状&quot;&gt;&lt;a href=&quot;#移动端现状&quot; class=&quot;headerlink&quot; title=&quot;移动端现状&quot;&gt;&lt;/a&gt;移动端现状&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内核&lt;ul&gt;
&lt;li&gt;当前国产主流手机浏览器，内核都是Webkit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="前端" scheme="https://www.pengspace.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://www.pengspace.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="flex布局" scheme="https://www.pengspace.top/tags/flex%E5%B8%83%E5%B1%80/"/>
    
      <category term="响应式布局" scheme="https://www.pengspace.top/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举、注解和反射</title>
    <link href="https://www.pengspace.top/2020/11/16/%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <id>https://www.pengspace.top/2020/11/16/%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</id>
    <published>2020-11-16T11:24:54.000Z</published>
    <updated>2020-11-16T11:29:00.189Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JDK1.5引入了新的类型——枚举。</p><p>在JDK1.5 之前，我们定义常量都是： public static fianl…. 。很难管理。</p><p>枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。用于定义有限数量的一组同类常量，例如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误级别：</span><br><span class="line">低、中、高、急</span><br><span class="line">一年的四季：</span><br><span class="line">春、夏、秋、冬</span><br><span class="line">商品的类型：</span><br><span class="line">美妆、手机、电脑、男装、女装...</span><br></pre></td></tr></table></figure><p>在枚举类型中定义的常量是该枚举类型的<strong>实例</strong>。</p><h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="keyword">enum</span> 枚举名称 &#123;</span><br><span class="line">实例<span class="number">1</span>,实例<span class="number">2</span>，实例<span class="number">3</span>,...实例n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line">LOW(<span class="number">1</span>), MEDIUM(<span class="number">2</span>), HIGH(<span class="number">3</span>), URGENT(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> levelValue;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Level</span><span class="params">(<span class="keyword">int</span> levelValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.levelValue = levelValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevelValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> levelValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;<span class="comment">//这样的方式更常用，通过字面意思就能理解枚举中常量的含义</span></span><br><span class="line">LOW, MEDIUM, HIGH, URGENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的主要方法"><a href="#枚举类的主要方法" class="headerlink" title="枚举类的主要方法"></a>枚举类的主要方法</h3><p>Enum<font color =red>抽象类</font>常见方法</p><p>Enum是所有Java语言枚举类型的公共基本类，以下是它的常见方法：</p><table><thead><tr><th align="center">变量和类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>protected Object</code></td><td align="center"><code>clone()</code></td><td align="center">抛出CloneNotSupportedException。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>compareTo(E o)</code></td><td align="center">将此枚举与指定的对象进行比较。</td></tr><tr><td align="center"><code>boolean</code></td><td align="center"><code>equals(Object other)</code></td><td align="center">如果指定的对象等于此枚举常量，则返回true。</td></tr><tr><td align="center"><code>Class&lt;?&gt;</code></td><td align="center"><code>getDeclaringClass()</code></td><td align="center">返回与此枚举常量的枚举类型对应的Class对象。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>hashCode()</code></td><td align="center">返回此枚举常量的哈希码。</td></tr><tr><td align="center"><code>String</code></td><td align="center"><code>name()</code></td><td align="center">返回此枚举常量的名称，与其枚举声明中声明的完全相同。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>ordinal()</code></td><td align="center">返回此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）。</td></tr><tr><td align="center"><code>String</code></td><td align="center"><code>toString()</code></td><td align="center">返回声明中包含的此枚举常量的名称。</td></tr><tr><td align="center"><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td><td align="center"><code>valueOf(Class&lt;T&gt; enumType, String name)</code></td><td align="center">返回具有指定名称的指定枚举类型的枚举常量。</td></tr></tbody></table><blockquote><p>  以上方法中，只有toString()方法可以被重写</p></blockquote><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h3><p>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。<br>每个枚举对象，都可以实现自己的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LShow</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level implements LShow&#123;</span><br><span class="line">LOW&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,MEDIUM&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,HIGH&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>一旦定义了枚举，最好不要妄图修改里面的值，除非修改是必要的。</li><li>枚举类默认继承的是java.lang.Enum类而不是Object类</li><li>枚举类不能有子类，因为其枚举类默认被final修饰</li><li>只能有private构造方法</li><li>switch中使用枚举时，直接使用常量名，不用携带类名</li><li>不能定义name属性，因为自带name属性</li><li>不要为枚举类中的属性提供set方法，不符合枚举最初设计初衷。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和注释不同，Java 标注可以通过反射获取标<br>注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行<br>时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>主要用于：编译格式检查、反射中解析、生成帮助文档、跟踪代码依赖等</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li><p><code>@Override</code>： 重写 </p><ul><li>定义在java.lang.Override</li></ul></li><li><p><code>@Deprecated</code>：废弃 </p><ul><li>定义在java.lang.Deprecated</li></ul></li><li><p><code>@SafeVarargs</code></p><ul><li>Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li></ul></li><li><p><code>@FunctionalInterface</code>： 函数式接口 </p><ul><li>Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li><p><code>@Repeatable</code>：标识某注解可以在同一个声明上使用多次</p></li><li><p>Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p></li><li><p><code>SuppressWarnings()</code>  抑制编译时的警告信息。 </p><ul><li><p>定义在java.lang.SuppressWarnings</p></li><li><p>三种使用方式</p><ul><li><code>@SuppressWarnings(&quot;unchecked&quot;)</code> ： 抑制单类型的警告</li><li><code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code>：抑制多类型的警告</li><li><code>@SuppressWarnings(&quot;all&quot;)</code>：抑制所有类型的警告</li></ul></li><li><p>参数列表：</p><ul><li><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td></tr><tr><td>null</td><td>忽略对null的操作</td></tr><tr><td>rawtypes</td><td>使用generics时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是<strong>作用在其他注解</strong>的注解。有下面几种：</p><ul><li><p><code>@Retention</code>- 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p></li><li><p><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</p></li><li><p><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</p></li><li><p><code>@Inherited</code> - 标记这个注解是自动继承的</p><ul><li>子类会继承父类使用的注解中被<code>@Inherited</code>修饰的注解</li></ul><ol start="2"><li>接口继承关系中，子接口不会继承父接口中的任何注解，不管父接口中使用的注解有没有<br> 被<code>@Inherited</code>修饰</li><li>类实现接口时不会继承任何接口中定义的注解</li></ol></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="注解架构"><a href="#注解架构" class="headerlink" title="注解架构"></a>注解架构</h4><p><img src="https://i.loli.net/2020/10/26/e5pqFSIxH2NdlUn.png" alt=""></p><ul><li><p><strong><code>Annotation</code>与<code>RetentionPolicy</code> 、<code>ElementType</code> 。</strong></p><p>每 1 个 <code>Annotation</code> 对象，都会有<strong>唯一的 <code>RetentionPolicy</code> 属性，有 1~n个<code>ElementType</code>属性</strong>。</p></li><li><p><strong><code>ElementType</code>(注解的用途类型)</strong></p><p>“每 1 个 <code>Annotation</code>“ 都与 “1～n 个 <code>ElementType</code>“ 关联。当 <code>Annotation</code> 与某个 <code>ElementType</code> 关联时，就意味着：<code>Annotation</code>有了某种用途。例如，若一个 <code>Annotation</code> 对象是 <code>METHOD</code> 类型，则该<code>Annotation</code> 只能用来修饰方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">TYPE, <span class="comment">// 类、接口（包括注释类型）或枚举声明 </span></span><br><span class="line">FIELD,  <span class="comment">// 字段声明（包括枚举常量）</span></span><br><span class="line">METHOD, <span class="comment">// 方法声明 </span></span><br><span class="line">PARAMETER,  <span class="comment">// 参数声明 </span></span><br><span class="line">CONSTRUCTOR,  <span class="comment">// 构造方法声明 </span></span><br><span class="line">LOCAL_VARIABLE, <span class="comment">// 局部变量声明 </span></span><br><span class="line">ANNOTATION_TYPE,<span class="comment">// 注释类型声明 </span></span><br><span class="line">PACKAGE <span class="comment">// 包声明 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>RetentionPolicy</code>（注解作用域策略）</strong>。</p><p>“每 1 个 <code>Annotation</code>“ 都与 “1 个 <code>RetentionPolicy</code>“ 关联。</p><ul><li>若 <code>Annotation</code> 的类型为 <code>SOURCE</code>，则意味着：<code>Annotation</code> 仅存在于编译器处理期间，编译器处理完之后，该<code>Annotation</code> 就没用了。 例如，”<code>@Override</code>“ 标志就是一个 <code>Annotation</code>。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”<code>@Override</code>“ 就没有任何作用了。</li><li>若 <code>Annotation</code> 的类型为 <code>CLASS</code>，则意味着：编译器将 <code>Annotation</code> 存储于类对应的 <code>.class</code>文件中，它是 <code>Annotation</code> 的默认行为。</li><li>若 <code>Annotation</code> 的类型为 <code>RUNTIME</code>，则意味着：编译器将 <code>Annotation</code> 存储于 <code>.class</code> 文件中，并且可由JVM读入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">SOURCE, <span class="comment">//Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了</span></span><br><span class="line">CLASS, <span class="comment">//编译器将Annotation存储于类对应的.class文件中。默认行为</span></span><br><span class="line">RUNTIME <span class="comment">//编译器将Annotation存储于class文件中，并且可由JVM读入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义格式-1"><a href="#定义格式-1" class="headerlink" title="定义格式"></a>定义格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> 自定义注解名&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意事项</p><ol><li>定义的注解，自动继承了java.lang.annotation.Annotation接口</li><li><strong>注解中的每一个方法，实际是声明的注解配置参数</strong><ul><li>方法的名称就是配置参数的名称</li><li>方法的返回值类型，就是配置参数的类型。只能是：基本类型/Class/String/enum</li></ul></li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、 0 作为默认值。</li></ol></blockquote><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">参数类型 参数名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的作用是定义一个 <code>Annotation</code>，我们可以在代码中通过 “<code>@MyAnnotation1</code>“ 来使用它。<br><code>@Documented</code>， <code>@Target</code>，<code>@Retention</code>，<code>@interface</code> 都是来修饰 <code>MyAnnotation1</code> 的。含义：</p><ul><li><p><code>@interface</code></p><p>使用 <code>@interface</code> 定义注解时，意味着它实现了 <code>java.lang.annotation.Annotation</code> 接口，即该注解就是<code>一个Annotation</code>。</p><blockquote><p>  <font color = red>定义<code>Annotation</code> 时，<code>@interface</code> 是必须的。</font></p><p>  注意：它和我们通常的 <code>implemented</code> 实现接口的方法不同。<code>Annotation</code> 接口的实现细节都由编译器完成。通过 <code>@interface</code> 定义注解后，该注解不能继承其他的注解或接口。</p></blockquote></li><li><p><code>@Documented</code></p><p>类和方法的 <code>Annotation</code> 在缺省情况下是不出现在 <code>javadoc</code> 中的。如果使用 <code>@Documented</code> 修饰该<br><code>Annotation</code>，则表示它可以出现在 <code>javadoc</code> 中。</p><blockquote><p>  定义 <code>Annotation</code> 时，<strong><code>@Documented</code>可有可无</strong>；若没有定义，则 <code>Annotation</code> 不会出现在 <code>javadoc</code>中。</p></blockquote></li><li><p><code>@Target(ElementType.TYPE)</code></p><p><code>ElementType</code> 是 <code>Annotation</code> 的类型属性。而 <code>@Target</code> 的作用，就是来指定<code>Annotation</code> 的类型属性的。</p><p><code>@Target(ElementType.TYPE)</code> 的意思就是指定该 <code>Annotation</code> 的类型是 <code>ElementType.TYPE</code>。这就意味着，<code>MyAnnotation1</code> 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><blockquote><p>  定义 <code>Annotation</code> 时，<strong><code>@Target</code> 可有可无</strong>。若有 <code>@Target</code>，则该 <code>Annotation</code> 只能用于它所指定的地方；若没有 <code>@Target</code>，则该 <code>Annotation</code> 可以用于任何地方。</p></blockquote></li><li><p><code>@Retention(RetentionPolicy.RUNTIME)</code></p><p><code>RetentionPolicy</code> 是 <code>Annotation</code> 的策略属性，而 <code>@Retention</code> 的作用，就是指定<code>Annotation</code> 的策略属性。</p><p><code>@Retention(RetentionPolicy.RUNTIME)</code> 的意思就是指定该 <code>Annotation</code> 的策略是<br><code>RetentionPolicy.RUNTIME</code>。这就意味着，编译器会将该 <code>Annotation</code> 信息保留在 <code>.class</code>文件中，并且能被JVM虚拟机读取。</p><blockquote><p>  定义 <code>Annotation</code> 时，<code>@Retention</code>可有可无。若没有 <code>@Retention</code>，则默认是<br>  <code>RetentionPolicy.CLASS</code>。</p></blockquote></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990?fr=aladdin" target="_blank" rel="noopener">JAVA反射机制</a>是在运行状态中，获取任意一个类的结构 、 创建对象 、得到方法、执行方法 、属性，这种在运行状态动态获取信息以及动态调用对象方法的功能被称为java语言的反射机制。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java类加载器（Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p><p>java默认有三种类加载器:<code>BootstrapClassLoader</code>、<code>ExtensionClassLoader</code>、<code>App ClassLoader</code>。</p><ul><li><p><strong>BootstrapClassLoader（引导启动类加载器）：</strong><br>嵌在JVM内核中的加载器，该加载器是用C++语言（原生语言）写的，主要负载加载JAVA_HOME/lib下的类库，引导启动类加载器无法被应用程序直接使用。</p></li><li><p><strong>ExtensionClassLoader（扩展类加载器）</strong>：<br>ExtensionClassLoader是用JAVA编写，且它的父类加载器是Bootstrap。</p><p>是由sun.misc.Launcher$ExtClassLoader实现的，主要加载JAVA_HOME/lib/ext目录中的类库。</p></li><li><p><strong>App ClassLoader（应用类加载器）</strong>：<br>App ClassLoader是应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文<br>件。它的父加载器为Ext ClassLoader</p></li></ul><p><img src="https://i.loli.net/2020/10/26/TGtjSkCnMwp8qUO.png" alt=""></p><blockquote><p>  类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。</p><p>  <strong>委派</strong></p><p>  双亲委派模型：<font color = red>如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成</font>。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。委派的好处就是避免有些类被重复加载。</p></blockquote><blockquote><p>  <strong>加载配置文件</strong></p><p>  如果我们的项目下有source文件夹，类.class.getClassLoader().getResourceAsStream(文件名)加载的是source文件夹下的文件，前提是将文件夹定义为Resources Root</p><p>  <img src="https://i.loli.net/2020/10/26/4THGmUu6PEno3qk.png" alt="image-20201026212548653"></p><p>  <img src="https://i.loli.net/2020/10/26/JqeIEhX34APUScv.png" alt=""></p></blockquote><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><p>要想了解一个类，必须先要获取到该类的字节码文件对象。在Java中，每一个字节码文件，被加载到内存后，都存在一个对应的Class类型的对象</p><p><strong>得到Class的几种方式</strong></p><ol><li><p>如果在编写代码时, 知道类的名称, 且类已经存在, 可以通过下面代码得到一个类的 类对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.类名<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果拥有类的对象, 可以通过下面代码得到一个类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class 对象.getClass()</span><br></pre></td></tr></table></figure></li><li><p>如果在编写代码时, 知道类的名称 , 可以通过下面代码得到一个类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"包名.类名"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>上述的三种方式, 在调用时, 如果类在内存中不存在, 则会加载到内存! 如果类已经在内存中存在, 不会重复加载, 而是重复利用!</p><p><img src="https://i.loli.net/2020/10/26/2X4A53NFvROnwGx.png" alt=""></p><blockquote><p>  (一个class文件 在内存中不会存在两个类对象 )</p><p>  特殊的类对象</p><ul><li>基本数据类型的类对象:<ul><li>基本数据类型.class</li><li>包装类.type</li></ul></li><li>基本数据类型包装类对象:<ul><li>包装类.class</li></ul></li></ul></blockquote><h3 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h3><p><strong>通过class对象 获取一个类的构造方法</strong></p><ol><li><p>通过指定的参数类型, 获取指定的单个构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getConstructor(参数类型的<span class="class"><span class="keyword">class</span>对象数组)</span></span><br></pre></td></tr></table></figure><p> 例如，构造方法如下: </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(String name,<span class="keyword">int</span> age)</span><br></pre></td></tr></table></figure><p> 得到这个构造方法的代码如下:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = p.getClass().getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取所有权限的单个构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructor(参数类型的<span class="class"><span class="keyword">class</span>对象数组)</span></span><br></pre></td></tr></table></figure></li><li><p>获取所有权限的构造方法数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructors();</span><br></pre></td></tr></table></figure></li></ol><p><strong>Constructor 创建对象</strong></p><p>常用方法:</p><ul><li><p><code>newInstance(Object... para)</code></p><p>调用这个构造方法, 把对应的对象创建出来<br>参数: 是一个Object类型可变参数, 传递的参数顺序 必须匹配构造方法中形式参数列表的顺序!</p></li><li><p><code>setAccessible(boolean flag)</code><br>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/OUb4plBsyCr7gX2.png" alt=""></p><h3 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h3><p><strong>通过class对象获取一个类的方法</strong></p><ol><li><p>根据参数列表的类型和方法名, 得到一个方法(public修饰的)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMethod(String methodName , <span class="class"><span class="keyword">class</span>... <span class="title">clss</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>得到一个类的所有方法 (public修饰的)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMethods()</span><br></pre></td></tr></table></figure></li><li><p>根据参数列表的类型和方法名, 得到一个方法(除继承以外所有的:包含私有，公有， 保护， 默认)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethod(String methodName , <span class="class"><span class="keyword">class</span>... <span class="title">clss</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>得到一个类的所有方法 (除继承以外所有的:包含私有，公有， 保护， 默认)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethods()</span><br></pre></td></tr></table></figure></li></ol><p><strong>Method 执行方法</strong></p><ul><li><p><code>invoke(Object o,Object... para)</code></p><p>参数1. 要调用方法的对象<br>参数2. 要传递的参数列表</p></li><li><p><code>getName()</code><br>获取方法的方法名称</p></li><li><p><code>setAccessible(boolean flag)</code><br>如果flag为true 则{表示忽略访问权限检查 !(可以访问任何权限的方法)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/u3T6tlMyavn59Kf.png" alt=""></p><h3 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h3><p><strong>通过class对象 获取一个类的属性</strong></p><ol><li><p>根据属性的名称, 获取一个属性对象 (所有属性)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredField(String filedName)</span><br></pre></td></tr></table></figure></li><li><p>获取所有属性(所有权限)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredFields()</span><br></pre></td></tr></table></figure></li><li><p>根据属性的名称, 获取一个属性对象 (public属性)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getField(String filedName)</span><br></pre></td></tr></table></figure></li><li><p>获取所有属性 (public)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFields()</span><br></pre></td></tr></table></figure></li></ol><p><strong>Field 属性的对象类型</strong></p><p>常用方法:</p><ul><li><p><code>get(Object o)</code></p><p>参数: 要获取属性的对象，获取指定对象的此属性值</p></li><li><p><code>set(Object o , Object value)</code></p><p>参数1.要设置属性值的对象，参数2. 要设置的值。设置指定对象的属性的值</p></li><li><p><code>getName()</code><br>获取属性的名称</p></li><li><p><code>setAccessible(boolean flag)</code></p><p>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的属性)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/JzatTMCxEkdjfZw.png" alt=""></p><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><p><strong>获取类/属性/方法的全部注解对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = Class/Field/Method.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据类型获取类/属性/方法的注解对象</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解类型 对象名 = (注解类型) c.getAnnotation(注解类型<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/26/ZuIB4gvK5yWfUxD.png" alt=""></p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>内省即基于反射 ，java所提供的一套应用到JavaBean的API。</p><blockquote><p>  一个定义在包中的类 ，拥有无参构造器，所有属性私有，所有属性提供get/set方法，实现了序列化接口。这种类, 我们称其为 bean类。</p><p>  Java提供了一套java.beans包的api ，对反射的操作，进行了封装!</p></blockquote><h3 id="Introspector"><a href="#Introspector" class="headerlink" title="Introspector"></a>Introspector</h3><p>获取Bean类信息，方法:</p><p><code>BeanInfo getBeanInfo(Class cls)</code> :通过传入的类信息, 得到这个Bean类的封装对象.</p><h3 id="BeanInfo"><a href="#BeanInfo" class="headerlink" title="BeanInfo"></a>BeanInfo</h3><p>常用的方法:</p><p><code>MethodDescriptor[] getPropertyDescriptors()</code>:获取bean类的 get/set方法 数组</p><h3 id="MethodDescriptor"><a href="#MethodDescriptor" class="headerlink" title="MethodDescriptor"></a>MethodDescriptor</h3><p>常用方法:</p><p><code>Method getReadMethod()</code>：获取一个get方法</p><p><code>Method getWriteMethod()</code>：获取一个set方法</p><p><font color = red>有可能返回null 注意加判断!</font></p><p><img src="https://i.loli.net/2020/10/26/8UqRoVuAdaIewJ6.png" alt="image-20201026234226051"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;JDK
      
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XML和JSON的使用（java）</title>
    <link href="https://www.pengspace.top/2020/10/24/XML%E5%92%8CJSON%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88java%EF%BC%89/"/>
    <id>https://www.pengspace.top/2020/10/24/XML%E5%92%8CJSON%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88java%EF%BC%89/</id>
    <published>2020-10-24T08:24:49.000Z</published>
    <updated>2020-11-16T11:26:06.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fromtitle=xml&fromid=86251&fr=aladdin" target="_blank" rel="noopener">XML</a>全称可扩展标记语言（eXtensible Markup Language）。是一种用于标记电子文件使其具有结构性的标记语言。</p><a id="more"></a><blockquote><p>  在电子计算机中，标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。是Internet环境中跨平台的、依赖于内容的技术，也是当今处理分布式结构信息的有效工具。早在1998年，W3C就发布了XML1.0规范，使用它来简化Internet的文档信息传输。</p></blockquote><p><strong>特性:</strong></p><ol><li>xml具有平台无关性, 是一门独立的标记语言.</li><li>xml具有自我描述性</li></ol><p><strong>用途</strong></p><ol><li>网络数据传输</li><li>数据存储</li><li>配置文件</li></ol><blockquote><p>  .XML文件是保存XML数据的一种方式，XML数据也可以以其他的方式存在（如在内存中构建XML数据）。不要将XML语言狭隘的理解成XML文件。</p></blockquote><p>###XML语法</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>在XML文档开头，要先写XML文档声明，格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br></pre></td></tr></table></figure><p>XML文档正文都是由一个个的<strong>标记</strong>组成的，包含：</p><ul><li>开始标记(开放标记): &lt;标记名称&gt;</li><li>结束标记(闭合标记): &lt;/标记名称&gt;</li><li>标记内容: 开始标记与结束标记之间 ，是标记的内容。</li></ul><blockquote><p>  标记名称: 自定义名称，必须遵循以下命名规则：</p><ol><li>名称可以含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字符 “xml”（或者 XML、Xml）开始</li><li>名称不能包含空格，不能包含冒号（:）</li><li>名称区分大小写</li></ol></blockquote><p>例如 ,我们通过标记, 描述一个名字:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>答案<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>一个XML文档中，必须有且且仅允许有一个根标记。</p></li><li><p>标记可以嵌套, 但是不允许交。</p></li><li><p>标记名称 允许重复</p></li><li><p>标记的层级称呼 (子标记，父标记 ，兄弟标记，后代标记 ，祖先标记)，例如下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">length</span>&gt;</span>180cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">length</span>&gt;</span>200cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><p>name是person的子标记，是person的后代标记，是persons的后代标记，是length的兄弟标记。person是name的父标记。persons是name的祖先标记。</p></li><li><p>标记除了开始和结束 , 还可以包含属性。标记中的属性，在标记开始时描述，由属性名和属性值组成。<br>在开始标记中, 描述属性，可以包含0-n个属性，每一个属性是一个键值对!<br>属性名不允许重复 ，键与值之间使用等号连接, 多个属性之间使用空格分割，属性值 必须被引号引住。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"10001"</span> <span class="attr">groupid</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以在XML文档中写注释，但是不能写在文档声明前，不能嵌套注释。<br>格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="语法进阶CDATA"><a href="#语法进阶CDATA" class="headerlink" title="语法进阶CDATA"></a>语法进阶CDATA</h4><p>CDATA 是不会被 XML 解析器解析的文本数据。像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的。</p><blockquote><p>  “&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。</p><p>  “&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始。</p></blockquote><p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。定义格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[脚本代码]]&gt;</span><br></pre></td></tr></table></figure><h3 id="Java解析XML"><a href="#Java解析XML" class="headerlink" title="Java解析XML"></a>Java解析XML</h3><p>在java中，XML可以通过下面四种方式解析</p><ol><li>SAX解析</li><li>DOM解析</li><li>JDOM解析</li><li>DOM4J解析</li></ol><p>其实也可以说成SAX和DOM两种解析方式，因为后面两种也属于DOM解析，是由DOM解析的基础上扩展来的，只是用与Java。</p><h4 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h4><p>解析方式是事件驱动机制 !</p><p>SAX解析器，<strong>逐行读取</strong>XML文件进行解析 ，每当解析到一个标签的<strong>开始/结束/内容/属性</strong>时，触发事件。我们可以编写程序在这些事件发生时，进行相应的处理。</p><blockquote><p>  <strong>优点：</strong></p><ol><li>分析能够立即开始，而不是等待所有的数据被处理</li><li>逐行加载，节省内存。有助于解析大于系统内存的文档</li><li>有时不必解析整个文档，它可以在某个条件得到满足时停止解析。</li></ol><p>  <strong>缺点：</strong></p><ol><li>单向解析，无法定位文档层次，无法同时访问同一文档的不同部分数据(因为逐行解析，当解析第n行时，第n-1行已经被释放了，无法再进行操作了)。</li><li>无法得知事件发生时元素的层次，只能自己维护节点的父/子关系.</li><li>只读解析方式，无法修改XML文档的内容。</li></ol></blockquote><h4 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h4><p>是用与平台和语言无关的方式表示XML文档的官方W3C标准，分析该结构通常需要<strong>加载整个文档</strong>和内存中建立文档树模型。程序员可以通过操作文档树，来完成数据的获取、修改、删除等.</p><blockquote><p>  <strong>优点:</strong></p><ol><li>文档在内存中加载，允许对数据和结构做出更改.</li><li>访问是双向的，可以在任何时候在树中双向解析数据。</li></ol><p>  <strong>缺点:</strong></p><ol><li>文档全部加载在内存中，消耗资源大.</li></ol></blockquote><h4 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h4><p>目的是解析为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。</p><blockquote><p>  优点:</p><ol><li><p>使用具体类而不使用接口，简化了DOM的API。</p></li><li><p>大量使用了Java集合类，方便了Java开发人员。</p><p>缺点：</p></li><li><p>没有较好的灵活性。</p></li><li><p>性能不是那么优异。</p></li></ol></blockquote><h4 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h4><p>它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项。</p><p>DOM4J是一个非常优秀的Java XML API，具有性能优异、灵活性好、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML。</p><h5 id="DOM4J解析XML"><a href="#DOM4J解析XML" class="headerlink" title="DOM4J解析XML"></a>DOM4J解析XML</h5><p><strong>步骤:</strong></p><ol><li><p>引入DOM4j的jar包 dom4j.jar</p></li><li><p>创建一个指向XML文件的输入流</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"xml文件的地址"</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建一个XML读取工具对象<code>SAXReader</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXReader sr = <span class="keyword">new</span> SAXReader();</span><br></pre></td></tr></table></figure></li><li><p>使用读取工具对象，读取XML文档的输入流， 并得到文档对象<code>Document</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document doc = sr.read(fis);</span><br></pre></td></tr></table></figure></li><li><p>通过文档对象, 获取XML文档中的根元素对象 <code>Element root</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.getRootElement();</span><br></pre></td></tr></table></figure></li></ol><p><strong>文档对象 <code>Document</code></strong></p><p>指的是加载到内存的 整个XML文档。常用方法:</p><ol><li><p>通过文档对象, 获取XML文档中的根元素对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.getRootElement();</span><br></pre></td></tr></table></figure></li><li><p>添加根节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.addElement(<span class="string">"根节点名称"</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>元素对象 <code>Element</code></strong></p><p>指的是XML文档中的单个节点。常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getName()</code></td><td>获取当前节点的标记名称</td></tr><tr><td><code>String getText()</code></td><td>获取节点内容</td></tr><tr><td><code>void setText(String s)</code></td><td>设置节点内容</td></tr><tr><td><code>String attributeValue(String s)</code></td><td>获取节点的属性值，s表示属性名称</td></tr><tr><td><code>void addAttribute(String key,String value)</code></td><td>添加属性 （key属性名，value属性值）</td></tr><tr><td><code>Element element(String name)</code></td><td>根据子节点名称获取匹配名称的第一个子节点对象</td></tr><tr><td><code>List&lt;Element&gt; elements()</code></td><td>获取所有的子节点对象</td></tr><tr><td><code>String elementText(String s)</code></td><td>返回子节点内容，s表示子标签名称</td></tr><tr><td><code>Element addElement(String name)</code></td><td>添加子节点  （name子节点名称）</td></tr></tbody></table><p><strong>解析本地文件案例</strong></p><p><img src="https://i.loli.net/2020/10/24/DWNRyanEpfSKIt9.png" alt=""></p><p><strong>解析网络文件案例</strong></p><p><img src="https://i.loli.net/2020/10/24/yR6wnKSqAjibEgI.png" alt=""></p><h5 id="DOM4J-XPATH解析XML"><a href="#DOM4J-XPATH解析XML" class="headerlink" title="DOM4J - XPATH解析XML"></a>DOM4J - XPATH解析XML</h5><p>XPATH就是通过路径快速的查找一个或一组元素</p><table><thead><tr><th>标记</th><th>解释</th></tr></thead><tbody><tr><td>/</td><td>从根节点开找</td></tr><tr><td>//</td><td>查找后代节点</td></tr><tr><td>.</td><td>查找当前节点</td></tr><tr><td>…</td><td>查找父节点</td></tr><tr><td>@</td><td>选择属性，属性使用方式:<br>[@属性名=‘值’] <br>[@属性名&gt;‘值’]<br>[@属性名&lt;‘值’] <br>[@属性名!=‘值’]</td></tr></tbody></table><p>例如：在我们解析本地文件案例中有一个books.xml文件，如果我们想找到 “三国演义”这个元素，XPATH 路径k可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//book[@id='1001']//name</span><br></pre></td></tr></table></figure><p>通过Node类的两个方法, 来完成查找(Node是 Document 与 Element 的父接口)</p><p>方法1，根据路径表达式， 查找匹配的单个节点，如果结果有多个，只取第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node e = selectSingleNode(<span class="string">"路径表达式"</span>);</span><br></pre></td></tr></table></figure><p>方法2，根据路径表达式， 查找匹配的所有节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Node&gt; es = selectNodes(<span class="string">"路径表达式"</span>);</span><br></pre></td></tr></table></figure><p>例子：</p><p><img src="https://i.loli.net/2020/10/24/dptXgi5PVfseMKL.png" alt=""></p><p><img src="https://i.loli.net/2020/10/24/IXvg15HAyc8KQ4J.png" alt="image-20201024011319670"></p><h3 id="Java生成XML"><a href="#Java生成XML" class="headerlink" title="Java生成XML"></a>Java生成XML</h3><p><strong>步骤:</strong></p><ol><li><p>通过文档帮助器 (<code>DocumentHelper</code>) ，创建空的文档对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document doc = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></li><li><p>通过文档对象，向其中添加根节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.addElement(<span class="string">"根节点名称"</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过根节点对象root , 丰富我们的子节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element e = root.addElement(<span class="string">"元素名称"</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建一个文件输出流 ,用于存储XML文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"要存储的位置"</span>);</span><br></pre></td></tr></table></figure></li><li><p>将文件输出流, 转换为XML文档输出流</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLWriter xw = <span class="keyword">new</span> XMLWriter(fos);</span><br></pre></td></tr></table></figure></li><li><p>写出文档</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xw.write(doc);</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xw.close();</span><br></pre></td></tr></table></figure></li></ol><p><strong>例子</strong></p><p><img src="https://i.loli.net/2020/10/24/wJnlYCycOIZ2jVk.png" alt="image-20201024014247166"></p><p>####XStream的使用</p><p>快速的将Java中的对象, 转换为 XML字符串.</p><p>使用步骤:</p><ol><li><p>创建XStream 对象</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XStream x</span> = new XStream();</span><br></pre></td></tr></table></figure></li><li><p>修改类生成的节点名称 (默认节点名称为 包名.类名)</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="keyword">alias</span>(<span class="string">"节点名称"</span>,类名<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure></li><li><p>传入对象 , 生成XML字符串</p> <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">xml</span>字符串 = x.toXML(对象);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p><img src="https://i.loli.net/2020/10/24/BMce4ZkQX85qbNi.png" alt="image-20201024013927345"></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin" target="_blank" rel="noopener">JSON</a>全称JavaScript Object Notation ，JS对象简谱 ，是一种轻量级的数据交换格式。</p><blockquote><p>  它基于 <a href="https://baike.baidu.com/item/ECMAScript" target="_blank" rel="noopener">ECMAScript</a> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>  JSON是[Douglas Crockford](<a href="https://baike.baidu.com/item/Douglas" target="_blank" rel="noopener">https://baike.baidu.com/item/Douglas</a> Crockford/5960317)在2001年开始推广使用的数据格式，在2005年-2006年正式成为主流的数据格式，雅虎和谷歌就在那时候开始广泛地使用JSON格式。</p></blockquote><h3 id="json语法"><a href="#json语法" class="headerlink" title="json语法"></a>json语法</h3><blockquote><p>  该部分内容参考自<a href="https://www.sojson.com/json/json_syntax.html" target="_blank" rel="noopener">https://www.sojson.com/json/json_syntax.html</a></p><p>  版权所属：SOJSON（原创文章）</p><p>  原文地址：<a href="https://www.sojson.com/json/json_syntax.html" target="_blank" rel="noopener">https://www.sojson.com/json/json_syntax.html</a></p></blockquote><p><strong>json 语法规则</strong></p><ul><li><strong>数据在名称/值对中</strong>，也就是我们常说的键值对，用逗号分隔</li><li><strong>花括号{}保存对象</strong></li><li><strong>方括号[]保存数组</strong></li></ul><p><strong>JSON 数据</strong>的书写格式是：<code>{Key:Value}</code>、<code>{Key:Array}</code>。前面是键，中间是英文的“:”（冒号），然后是值。但是注意的是如果是字符串，严格来说都是要用英文双引号引起来的。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"answer"</span>&#125;</span><br></pre></td></tr></table></figure><p>JSON数据的值可以是 <strong>数字（整数或浮点数）、字符串（在双引号中）、逻辑值（<code>true</code> 或 <code>false</code>）、数组（在方括号中）、对象（在花括号中）、<code>null</code></strong>。</p><p><strong>JSON对象</strong>在花括号中，对象可以包含多个名称/值对，如下代码所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"answer"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JSON数组</strong>在方括号（”[]”）中书写，数组可包含多个对象，如下“student”描述</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"student"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"answer"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"21"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"brian"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"20"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"joe"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"25"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，对象 “student” 是包含三个对象的数组。每个对象代表一条关于一个学生（姓名和年龄）的记录。</p><h3 id="Java解析转换JSON"><a href="#Java解析转换JSON" class="headerlink" title="Java解析转换JSON"></a>Java解析转换JSON</h3><blockquote><p>  将Java中的对象快速的转换为JSON格式的字符串。</p><p>  将JSON格式的字符串, 转换为Java的对象。</p></blockquote><p>Java官方未提供官方的json解析工具，json的解析借助第三方工具完成。常见的第三方工具有谷歌的<strong>Gson</strong>和阿里巴巴的<strong>fastjson</strong>。在使用前都要先导入jar包，可以从某hub上下载。</p><p><img src="https://i.loli.net/2020/10/24/OxXGZVTL7avnmEk.png" alt=""></p><h4 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h4><p><strong>将对象转换为JSON字符串</strong>，在需要转换JSON字符串的位置编写如下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="keyword">new</span> Gson().toJSON(要转换的对象);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/axH4XYOTv9MK8Nq.png" alt=""></p><p><strong>将JSON字符串转换为对象</strong>，在需要转换Java对象的位置，编写如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 = <span class="keyword">new</span> Gson().fromJson(JSON字符串,对象类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/CXxaiUnwAqPYEOD.png" alt=""></p><h4 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h4><p><strong>将对象转换为JSON字符串</strong>，在需要转换JSON字符串的位置编写如下代码即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json=JSON.toJSONString(要转换的对象);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/lRdcx8KVgMz69yp.png" alt=""></p><p><strong>将JSON字符串转换为对象</strong>，在需要转换Java对象的位置, 编写如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名=JSON.parseObject(JSON字符串, 类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">List&lt;类型&gt; list=JSON.parseArray(JSON字符串,类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/VE1laqAPfMgYvcG.png" alt=""></p><p><img src="https://i.loli.net/2020/10/24/eDRPWEik5fpCO2s.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fromtitle=xml&amp;fromid=86251&amp;fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XML&lt;/a&gt;全称可扩展标记语言（eXtensible Markup Language）。是一种用于标记电子文件使其具有结构性的标记语言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="XML" scheme="https://www.pengspace.top/tags/XML/"/>
    
      <category term="JSON" scheme="https://www.pengspace.top/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://www.pengspace.top/2020/10/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.pengspace.top/2020/10/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-24T08:23:00.000Z</published>
    <updated>2020-11-16T11:26:27.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><p>==多线程：栈空间独立，堆内存共享==</p><p>多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，一个进程可能包含了多个同时执行的线程。</p><a id="more"></a><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li><strong>进程</strong>：<ul><li>正在运行的应用程序：是指一个内存中运行的应用程序，<strong>每个进程都有一个独立的内存空间</strong>，即每个进程都有着自己的堆、栈等且是互不共享的。</li></ul></li><li><strong>线程</strong>：<ul><li>进程中的一个<strong>执行路径</strong>（一段程序从执行到结束的整个过程），共享一个内存空间，线程之间可以自由切换，并发执行，<font color=red>一个进程最少有一个线程</font></li><li>线程实际上是在进程的基础上进一步划分的，一个进程执行后，里面的若干执行路径又可以划分为若干个线程</li></ul></li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol><li><strong>分时调度</strong></li></ol><ul><li>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li></ul><ol start="2"><li><strong>抢占式调度</strong></li></ol><ul><li>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，<strong>Java使用的为抢占式调度</strong>。</li><li>CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核心而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉很快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</li></ul><h3 id="同步与异步-amp-并发与并行"><a href="#同步与异步-amp-并发与并行" class="headerlink" title="同步与异步&amp;并发与并行"></a>同步与异步&amp;并发与并行</h3><blockquote><p>  <strong>同步</strong>：排队执行，效率低但安全</p><p>  <strong>异步</strong>：同时执行，效率高但数据不安全</p></blockquote><blockquote><p>  <strong>并发</strong>：指两个或多个事件在<font color=red>同一个时间段内</font>发生。</p><p>  <strong>并行</strong>：指两个或多个事件在<font color=red>同一时刻</font>发生（同时发生）。</p></blockquote><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>步骤：</p><ol><li><p>创建一个自定义类并继承Thread类；</p></li><li><p>重写run()方法，创建新的执行任务（通过thread对象的start()方法启动任务，一般不直接调用run()方法）</p></li><li><p>创建自定义类对象实例，调用start()，让线程执行</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//run()方法就是线程要执行的任务的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ThreadTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();<span class="comment">//启动线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MainThread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>可以看到顺序并不统一，两个线程在交替执行而且各自所占的时间不完全相同，这是线程在抢时间片，谁先抢到谁就执行。</p><p><img src="https://i.loli.net/2020/10/20/t4hNj7XJWOHBuvr.png" alt="image-20201020195837780"></p><blockquote><p>  <strong>时序图：</strong></p><p>  <img src="https://i.loli.net/2020/10/20/ZeTkrMvRzSK8t3F.png" alt="image-20201020202118525"></p><p>  运行过程中子线程任务中调用的方法都在子线程中运行</p></blockquote><blockquote><p>  在上述代码中。如果Thread对象只需要调用1次，也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"MainThread"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>创建一个自定义类实现Runnable接口，并实现其抽象方法run()，编写线程要执行的任务</li><li>创建自定义类对象实例</li><li>用Thread类创建一个对象实例，并将第二步中的自定义类对象实例作为参数传给其构造函数</li><li>调用Thread类实例的start()方法执行线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RunnableTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MainRunnable"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行效果应该跟上面继承Thread类实现多线程效果差不多。</span></span><br></pre></td></tr></table></figure><blockquote><p>  上述代码也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"MainRunnable"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>==上面两种方式的比较==</strong></p><p>  <strong>继承Thread类</strong>：</p><ul><li><p>优点：直接使用Thread类中的方法，代码简单</p></li><li><p>弊端：如果已有父类，不可用（Java不可多继承)</p></li><li><p><em>实现Runnable接口（更常用）*</em>:</p><p>与继承Threadl类相比具有以下优势：</p></li><li><p>通过创建任务，给线程分配任务实现多线程，更适合多个线程同时执行相同任务的情况</p></li><li><p>可以避免单继承带来的局限性（Java允许实现多个接口，但不能继承多个父类）</p></li><li><p>任务和线程分离，提高程序健壮性</p></li><li><p>后续学到的线程池技术，它只接收Runnable类型任务，不接收Thread类型线程</p></li></ul></blockquote><blockquote><p>  <strong>==Thread类API==</strong></p><ol><li><p>常用构造方法</p><table><thead><tr><th>构造器</th><th>描述</th></tr></thead><tbody><tr><td><code>Thread()</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target, String name)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(String name)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr></tbody></table></li><li><p>常用其他方法</p><table><thead><tr><th align="left">变量和类型</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>long</code></td><td align="left"><code>getId()</code></td><td align="left">返回此Thread的标识符。</td></tr><tr><td align="left"><code>String</code></td><td align="left"><code>getName()</code></td><td align="left">返回此线程的名称。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>getPriority()</code></td><td align="left">返回此线程的优先级。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>setPriority(int newPriority)</code></td><td align="left">更改此线程的优先级。</td></tr><tr><td align="left"><code>Thread.State</code></td><td align="left"><code>getState()</code></td><td align="left">返回此线程的状态。</td></tr><tr><td align="left"><code>static Thread</code></td><td align="left"><code>currentThread()</code></td><td align="left">返回对当前正在执行的线程对象的引用。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>start()</code></td><td align="left">导致此线程开始执行; Java虚拟机调用此线程的<code>run</code>方法。</td></tr><tr><td align="left"><code>static void</code></td><td align="left"><code>sleep(long millis)</code></td><td align="left">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。</td></tr><tr><td align="left"><code>static void</code></td><td align="left"><code>sleep(long millis, int nanos)</code></td><td align="left">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>setDaemon(boolean on)</code></td><td align="left">将此线程标记为 daemon线程或用户线程。</td></tr></tbody></table></li><li><p>特殊字段：控制线程抢到时间片的几率</p><table><thead><tr><th>变量和类型</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>static int</code></td><td><code>MAX_PRIORITY</code></td><td>线程可以拥有的最大优先级。</td></tr><tr><td><code>static int</code></td><td><code>MIN_PRIORITY</code></td><td>线程可以拥有的最低优先级。</td></tr><tr><td><code>static int</code></td><td><code>NORM_PRIORITY</code></td><td>分配给线程的默认优先级。</td></tr></tbody></table><p>其他的可以参考Java的API手册</p></li></ol></blockquote><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>Callable接口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>创建一个自定义类实现Callable接口，并实现其抽象方法call()，编写线程要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建FutureTask对象 , 并传入第一步编写的Callable类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br></pre></td></tr></table></figure></li><li><p>通过Thread，启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(future).start();</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyCallable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyCallable:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CallableTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCallable&lt;String&gt; mc = <span class="keyword">new</span> MyCallable&lt;&gt; ();</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt; (mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  上述代码也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyCallable:"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)).start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>Runnable 与 Callable比较</strong></p><ul><li><p>相同点：</p><ul><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ul></li><li><p>不同点</p><ul><li>Runnable没有返回值；Callable可以返回执行结果</li><li>Callable接口的call()允许抛出异常；Runnable的run()不能抛出</li></ul><p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执<br>行，如果不调用不会阻塞。</p></li></ul></blockquote><h2 id="多线程的应用实例"><a href="#多线程的应用实例" class="headerlink" title="多线程的应用实例"></a>多线程的应用实例</h2><h3 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h3><p><code>currentThread()</code> 可以获取当前正在执行的线程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//获取当前线程对象的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GetThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//获取当前线程对象的名称</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(),<span class="string">"answer"</span>).start();<span class="comment">//给线程指定一个名称 (方法一)</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.setName(<span class="string">"anotherWay"</span>);<span class="comment">//给线程指定一个名称 (方法二)</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2020/10/20/DFz1sN5h2wUqyBG.png" alt="image-20201020213805266"></p><h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h3><p><code>sleep(long millis)</code>是Thread类的静态方法，类名直接调用即可，单位ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：每隔1秒打印一个数字。</p><p><img src="https://i.loli.net/2020/10/20/pIqfd5TD2waWtXo.gif" alt=""></p><blockquote><p>  <strong>线程阻塞</strong>：所有较耗时的操作都能称为阻塞。也叫耗时操作。</p></blockquote><h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>一个线程是一个独立的执行路径，它是否应该结束，<strong>由其自身决定</strong>。</p><p>因为线程执行过程会有很多资源需要使用或释放，如果干涉它的结束，很可能导致资源没能来得及释放，一直占用，从而产生无法回收的内存垃圾。</p><p>Java以前提供stop()方法可以结束线程，现在已经过时(不再使用)。现在出了新的方法，<strong>给线程打中断标记</strong>（<code>interrupt</code>）来控制它的结束。</p><p>具体方法就是 调用<code>interrupt()</code>方法，子线程执行时捕获中断异常，并在catch块中，添加处理释放资源的代码。</p><p>如下代码所示：main线程执行完后不管子线程是否执行完都中断掉它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务：打印1-10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//发现中断标记，进入catch块中，进行释放资源处理</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"：发现中断标记，我自杀了"</span>);</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//为了演示，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InterruptTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t1.setName(<span class="string">"myThread"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//main线程 打印1-5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt(); <span class="comment">//给线程t1添加中断标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2020/10/20/7vUXIGJWRbj4tTH.png" alt=""></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为<strong>守护线程</strong>和<strong>用户线程</strong></p><ul><li><strong>用户线程</strong>：当一个进程不包含任何存活的用户线程时，进行结束。</li><li><strong>守护线程</strong>：守护用户线程，当最后一个用户线程结束时，所有守护线程自动死亡。</li></ul><p>直接创建的都是用户线程，</p><p>设置线程为守护线程：在启动之前设置 ，语法为：<code>线程对象.setDaemon(true);</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务：打印1-10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//为了演示，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InterruptTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t1.setName(<span class="string">"myThread"</span>);</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置t1为守护线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//main线程 打印1-5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/20/YDGyOnPhEL3eXNz.png" alt=""></p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>我们先来看个例子：三个窗口（线程）同时卖5张票。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable run = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;  <span class="comment">//票数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//卖票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在卖票"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"出票成功,余票："</span>+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="https://i.loli.net/2020/10/21/g31kZ6c4FnywoqQ.png" alt=""></p><p>我们看到余票出现了负数，显然这是不合理的，这就是线程不安全导致的。出现这种情况的原因：线程争抢，导致线程不安全。 多线程在进行同一卖票任务时，没人干涉，各个窗口疯狂买票，最终导致卖的票超出总票数，余票出现负数。</p><p><font color=red><strong>线程不安全的原因：</strong></font></p><p>当多线程并发访问<strong>临界资源</strong>时，如果破坏<strong>原子操作</strong>，可能会造成数据不一致。</p><ul><li>临界资源：共享资源（同一对象），一次仅允许一个线程使用，才可保证其正确性。</li><li>原子操作：不可分割的多步操作，被视作一个整体，其顺序和步骤不可打乱或缺省。</li></ul><p>多个线程争抢同一个数据，使得数据在判断和使用时出现不一致的情况。那如何解决呢？</p><p>解决方法：保证一段数据同时只能被一个线程使用（排队使用），也就是线程同步，给线程加锁（synchronized）</p><p>我们有以下三种方法解决线程不安全的问题：同步代码块、同步方法、显示锁</p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</p><p>多个同步代码块如果使用<strong>相同的锁对象</strong>, 那么他们就是同步的</p><p>语法格式：<code>synchronized(锁对象) {}</code></p><p>任何对象都可以作为<strong>锁对象</strong>存在。</p><p>还以上面卖票的代码为例，给卖票的线程加锁</p><p><img src="https://i.loli.net/2020/10/21/fcxmMsCzRarQS8P.png" alt="image-20201021174518339"></p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>以方法为单位进行加锁。把synchronized关键字修饰在方法中。</p><p>还以上面卖票的代码为例，写一个synchronized修饰的方法sale()执行卖票任务，</p><p><img src="https://i.loli.net/2020/10/21/SoCgaNvHtdc6GwX.png" alt=""></p><h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><blockquote><p>  上面三种方法中，同步代码块和同步代码都是隐式锁</p></blockquote><p><code>Lock l = new ReentrantLock()</code>：自己创建一把锁</p><p><code>lock()</code>：加锁             <code>unlock()</code>：解锁</p><p>还以上面卖票的代码为例</p><p><img src="https://i.loli.net/2020/10/21/MdGWmJql95V1uEX.png" alt=""></p><blockquote><p>  <strong>显式锁和隐式锁的区别：</strong></p><table><thead><tr><th>区别</th><th>synchronized</th><th>lock</th></tr></thead><tbody><tr><td>原始构成</td><td>Java关键字，由JVM维护，是JVM层面的锁</td><td>JDK1.5之后的类，使用lock是在调用API，是API层面的锁</td></tr><tr><td>使用方式</td><td>隐式锁，不需要手动获取和释放锁，只需要写synchronized，不用进行其他操作</td><td>显式锁，需要手动获取和释放锁，如果没有释放锁，可能会出现死锁</td></tr><tr><td>等待中断</td><td>不会中断，除非抛出异常或正常运行完成</td><td>可以中断，1：调用设置超时方法tryLock(long timeout ,timeUnit unit)；2：调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断</td></tr><tr><td>加锁公平</td><td><strong>非公平锁</strong></td><td>可以是<strong>公平锁</strong>也可以是<strong>非公平锁</strong>，默认是非公平锁。可以在其构造方法传入Boolean值，true公平锁，false非公平锁</td></tr><tr><td>绑定多个条件</td><td>没有。不能精确唤醒线程，要么随机唤醒一个线程，要么唤醒所有等待线程</td><td>用来实现分组唤醒需要唤醒的线程，可以精确唤醒线程</td></tr><tr><td>性能</td><td>JDK1.5时性能较低，JDK1.6时性能优化，与lock相较无异</td><td>JDK1.5时性能更高，JDK1.6时synchronized优化赶上lock</td></tr><tr><td>加锁方式</td><td>线程获取独占锁（CPU悲观锁机制），只能依靠阻塞等待线程释放锁。在CPU转换线程阻塞时会引起线程上下文切换，当竞争锁的线程过多时，会引起CPU频繁上下文切换导致效率低下</td><td>使用乐观锁机制（CAS操作 Computer and Swap），假设不会发生冲突，一旦发生冲突失败就重试，直到成功为止。</td></tr></tbody></table><p>  <strong>公平锁</strong>：先来先得，排队执行</p><p>  <strong>非公平锁</strong>：抢占式的，谁抢到是谁的</p></blockquote><blockquote><p>  更多关于线程安全的问题可以看下面这篇文章</p><p>  <a href="https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA" target="_blank" rel="noopener">如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏)</a></p></blockquote><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a><font color=red>线程死锁</font></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>当两个或两个以上的线程在执行过程中，因为争夺资源而造成的一种相互等待的状态，由于存在一种环路的锁依赖关系而永远地等待下去，如果没有外部干涉，他们将永远等待下去，此时的这个状态称之为死锁。</p><p>多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处于阻塞的假死状态，形成死锁。</p><p>举个例子，如下图所示，在线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远地等待下去，这种情况就是死锁形式。</p><p><img src="https://i.loli.net/2020/10/21/oC9p8qRF7h1d4DS.png" alt=""></p><p><strong>死锁产生的条件：</strong></p><ul><li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。</li><li><strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{A，B，C，···，Z} 中的A正在等待一个B占用的资源；B正在等待C占用的资源，……，Z正在等待已被A占用的资源。</li></ul><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ol><li><p>按顺序加锁：如果每个线程都按同一个的加锁顺序这样就不会出现死锁。</p></li><li><p>给锁加时限：每个线程获取锁的时候加上个时限，如果超过某个时间就放弃锁。</p></li><li><p>死锁检测：按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。</p></li></ol><blockquote><p>  更多关于线程死锁的问题可以看下面这篇文章，以上内容也是来自这篇文章：</p><p>  <a href="https://mp.weixin.qq.com/s/kvvJ9_xKaOMobaX7PZ5VCQ" target="_blank" rel="noopener">多线程 死锁详解</a></p></blockquote><h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><p>Object方法中提供了一些线程间相互通信的方法</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>notify()</code></td><td>唤醒正在此对象监视器上等待的单个线程。</td></tr><tr><td><code>void</code></td><td><code>notifyAll()</code></td><td>唤醒等待此对象监视器的所有线程。</td></tr><tr><td><code>void</code></td><td><code>wait()</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 。</td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis)</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 ，或者直到经过一定量的实时。</td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis,  int nanos)</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 ，或者直到经过一定量的实时。</td></tr></tbody></table><p><strong>什么时候需要通信</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，如果我们希望他们有规律的执行, 就可以使用通信。</p><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><blockquote><p>  看下面代码，有Cooker类，Waiter类，Food类</p><p>  厨师cooker为生产者线程，服务员waiter为消费者线程，食物food为生产与消费的物品；</p><p>  假设目前只有一个厨师，一个服务员，一个盘子。理想状态是：厨师生产一份饭菜，服务员端走一份，且饭菜的属性未发生错乱；</p><p>  厨师可以制作两种口味的饭菜，制作100次；</p><p>  服务员可以端走饭菜100次；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Food();</span><br><span class="line">        <span class="keyword">new</span> Cooker(f).start();</span><br><span class="line">        <span class="keyword">new</span> Waiter(f).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cooker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//生产者线程</span></span><br><span class="line">        <span class="keyword">private</span> Food f;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cooker</span><span class="params">(Food f)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.f = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//生产100个菜</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    f.setNameAndTaste(<span class="string">"菜1"</span>,<span class="string">"味道1"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.setNameAndTaste(<span class="string">"菜2"</span>,<span class="string">"味道2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="keyword">private</span> Food f;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(Food f)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.f = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                f.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String taste;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameAndTaste</span><span class="params">(String name,String taste)</span></span>&#123;<span class="comment">//生产</span></span><br><span class="line">            <span class="keyword">this</span>.name = name;<span class="comment">//先设定名称</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//为使线效果明显，中间休眠一段时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.taste = taste;<span class="comment">//休眠后设定味道</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123; <span class="comment">//消费</span></span><br><span class="line">            System.out.println(<span class="string">"服务员端走的菜名称是："</span> + name + <span class="string">"，味道："</span> + taste);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/21/CAYzM4DNI36Pg7V.png" alt=""></p><p>原因：我们在设定菜名和味道的<code>setNameAndTaste</code>方法中,先设定名称，然后休眠一段时间，再设定的味道，中间休眠的那段时间很可能发生时间片丢失，使得菜属性产生混乱。</p><p><strong>解决方式一</strong>：</p><p>为了防止在生产过程中setNameAndTaste出现时间片切换，可以用synchronized修饰此方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setNameAndTaste</span><span class="params">(String name,String taste)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  <span class="comment">// 消费</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/21/HhAMOSIL9Ymn3lE.png" alt=""></p><p>可以看出，依然不符合实际情况，这是因为synchronized只是确保了方法内部不会发生线程切换，但并不能保证生产一个消费一个的逻辑关系</p><p><strong>解决方式二</strong>：</p><p>在解决方案一的基础上，进行线程之间的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//默认为true，表示可以做饭</span></span><br></pre></td></tr></table></figure><p>厨师做完饭后喊醒服务员，自己睡着。服务员送完饭后喊醒厨师，自己睡着；将Food类左如下修改</p><p><img src="https://i.loli.net/2020/10/21/flHwKZ9nbGrg8mT.png" alt=""></p><p>运行结果，做一道菜，端走一道。</p><p><img src="https://i.loli.net/2020/10/21/m7pIQqgSCZz59HG.png" alt="image-20201021210352200"></p><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>Enum Thread.State描述了六种线程的状态，如下表所示</p><table><thead><tr><th>Enum Constant</th><th>描述</th></tr></thead><tbody><tr><td><code>BLOCKED</code></td><td>线程的线程状态被阻塞等待监视器锁定。(阻塞)</td></tr><tr><td><code>NEW</code></td><td>尚未启动的线程的线程状态。(创建)</td></tr><tr><td><code>RUNNABLE</code></td><td>可运行线程的线程状态。（就绪和运行）</td></tr><tr><td><code>TERMINATED</code></td><td>终止线程的线程状态。（消亡）</td></tr><tr><td><code>TIMED_WAITING</code></td><td>具有指定等待时间的等待线程的线程状态。(有限期等待)</td></tr><tr><td><code>WAITING</code></td><td>等待线程的线程状态。(无限期等待)</td></tr></tbody></table><h2 id="线程池Executors"><a href="#线程池Executors" class="headerlink" title="线程池Executors"></a>线程池Executors</h2><blockquote><p>  普通线程的执行流程:</p><p>  创建线程 → 创建任务 → 执行任务 → 关闭线程</p><p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低 系统的效率，因为频繁创建线程和销毁线程需要时间。 线程池就是一个容纳多个线程的容器，池中的线程可以反复使用，省去了频繁创建和销毁线程对象的操作，节省了大量的时间和资源。</p></blockquote><p>线程池的好处</p><ul><li>降低资源消耗。</li><li>提高响应速度。</li><li>提高线程的可管理性。</li></ul><p>Java中有四种线程池(ExecutorService)：缓存线程池、定长线程池、单线程线程池、周期性任务定长线程池</p><h3 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h3><p>长度无限制</p><p>执行流程:</p><ol><li><p>判断线程池是否存在空闲线程</p></li><li><p>存在则使用</p></li><li><p>不存在,则创建线程 并放入线程池, 然后使用</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool(); <span class="comment">//获取缓存线程池对象</span></span><br><span class="line"><span class="comment">//向线程池中 加入 新的任务</span></span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="定长线程池"><a href="#定长线程池" class="headerlink" title="定长线程池"></a>定长线程池</h3><p>长度是指定的数值</p><p>步骤：</p><ol><li>判断线程池是否存在空闲线程</li><li>存在则使用</li><li>不存在空闲线程，线程池未满的情况下,则创建线程 并放入线程池, 然后使用</li><li>不存在空闲线程，且线程池已满的情况下,则等待线程池存在空闲线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="单线程线程池"><a href="#单线程线程池" class="headerlink" title="单线程线程池"></a>单线程线程池</h3><p>步骤：</p><ol><li>判断线程池的那个线程是否空闲</li><li>空闲则使用</li><li>不空闲则等待池中的单个线程空闲后使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="周期性任务定长线程池"><a href="#周期性任务定长线程池" class="headerlink" title="周期性任务定长线程池"></a>周期性任务定长线程池</h3><p>步骤：</p><ol><li>判断线程池是否存在空闲线程</li><li>存在则使用</li><li>不存在空闲线程，且线程池未满的情况下，则创建线程，并放入线程池后使用</li><li>不存在空闲线程，且线程池已满的情况下，则等待线程池存在空闲线程</li></ol><p>周期性任务执行时：定时执行, 当某个时机触发时, 自动执行某任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定时执行</span></span><br><span class="line"><span class="comment">* 参数1. runnable类型的任务</span></span><br><span class="line"><span class="comment">* 参数2. 时长数字   5 </span></span><br><span class="line"><span class="comment">* 参数3. 时长数字的单位 TimeUnit.SECONDS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">service.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 周期执行</span></span><br><span class="line"><span class="comment">* 参数1. runnable类型的任务</span></span><br><span class="line"><span class="comment">* 参数2. 时长数字(延迟执行的时长)5</span></span><br><span class="line"><span class="comment">* 参数3. 周期时长(每次执行的间隔时间) 2</span></span><br><span class="line"><span class="comment">* 参数4. 时长数字的单位  TimeUnit.SECONDS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">5</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程概述&quot;&gt;&lt;a href=&quot;#多线程概述&quot; class=&quot;headerlink&quot; title=&quot;多线程概述&quot;&gt;&lt;/a&gt;多线程概述&lt;/h2&gt;&lt;p&gt;==多线程：栈空间独立，堆内存共享==&lt;/p&gt;
&lt;p&gt;多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，一个进程可能包含了多个同时执行的线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.pengspace.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://www.pengspace.top/2020/10/24/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.pengspace.top/2020/10/24/Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-10-24T08:21:15.000Z</published>
    <updated>2020-11-16T11:27:08.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><a id="more"></a><blockquote><p>  <strong>注意：</strong></p><p>  在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p>  <strong>作用：</strong></p><ol><li>提高代码复用率</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ol></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassName&lt;String&gt; val1 = <span class="keyword">new</span> ClassName&lt;&gt; ();     <span class="comment">//在使用时指定为具体的类型</span></span><br><span class="line">        val1.setData(<span class="string">""</span>);</span><br><span class="line">        ClassName&lt;Integer&gt; val2 = <span class="keyword">new</span> ClassName&lt;&gt; ();</span><br><span class="line">        val2.setData(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口时，可以选择指定泛型类型，也可以选择不指定， 如下：</span></span><br><span class="line"><span class="comment">//指定类型：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String text;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不指定类型：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T 方法名(T a, T b) &#123;&#125;<span class="comment">//T只在方法内有效</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"haha"</span>);</span><br><span class="line">        print(<span class="number">11212</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a)</span></span>&#123;<span class="comment">//方法内的泛型只在方法内有效</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制泛型类型"><a href="#限制泛型类型" class="headerlink" title="限制泛型类型"></a>限制泛型类型</h3><p>在使用泛型时， 可以指定泛型的限定区域 ，</p><ul><li>例如： 必须是某某类的子类或 某某接口的实现类，格式：<br>  <code>&lt;T extends 类或接口1 &amp; 接口2&gt;</code></li></ul><p><img src="https://i.loli.net/2020/10/13/CjxYoEDT42qc8KR.png" alt="image-20201013115930582"></p><h3 id="泛型中的通配符"><a href="#泛型中的通配符" class="headerlink" title="泛型中的通配符"></a>泛型中的通配符</h3><p>类型通配符是使用<code>?</code>代替方法具体的类型实参。</p><ol><li><code>&lt;? extends Parent&gt;</code> 指定了泛型类型的上届</li><li><code>&lt;? super Child&gt;</code>  指定了泛型类型的下届</li><li><code>&lt;?&gt;</code> 指定了没有限制的泛型类型</li></ol><p><img src="https://i.loli.net/2020/10/13/J2DuWzcF4KIa5tl.png" alt=""></p><blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>  如果需要 ，我们可以指定多个泛型，中间用 <code>,</code>隔开即可</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">T</span>,<span class="title">E</span>,<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data1;</span><br><span class="line">   <span class="keyword">private</span> E data2;</span><br><span class="line"><span class="keyword">private</span> A data3;</span><br><span class="line">   <span class="keyword">private</span> B data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="https://www.pengspace.top/2020/10/11/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://www.pengspace.top/2020/10/11/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2020-10-11T06:24:00.000Z</published>
    <updated>2020-10-11T06:26:34.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>异常是在程序中导致程序中断运行的一种指令流。</p><p>先来看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算开始 ============="</span>) ;</span><br><span class="line">        System.out.println(i + <span class="string">"/"</span> + j + <span class="string">"="</span> + i / j);</span><br><span class="line">        System.out.println(<span class="string">"============= 计算结束 ============="</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">============= 计算开始 =============</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at ExceptionDemo01.main(ExceptionDemo01.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>以上的代码在<code>System.out.println(i + &quot;/&quot; + j + &quot;=&quot; + i / j);</code>位置处产生了异常<code>ArithmeticException(算术异常)</code>，一旦产生异常之后，异常之后的语句将不再执行了，所以现在的程序并没有正确的执行完毕之后就退出了。</p><p>那么，为了保证程序出现异常之后仍然可以正确的执行完毕，所以要采用异常的处理机制。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果要想对异常进行处理，则必须采用标准的处理格式，处理格式语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 有可能发生异常的代码段</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 对象名<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 对象名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125; ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 异常的统一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将开头的代码用try-catch处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算开始 ============="</span>) ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(i+ <span class="string">"/"</span> + j + <span class="string">"="</span> + i /j);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"除数不能为0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算结束 ============="</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">============= 计算开始 =============</span><br><span class="line">除数不能为0</span><br><span class="line">============= 计算结束 =============</span><br></pre></td></tr></table></figure><h3 id="try-catch的处理流程"><a href="#try-catch的处理流程" class="headerlink" title="try+catch的处理流程"></a>try+catch的处理流程</h3><p>1、 一旦产生异常，则系统会自动产生一个异常类的实例化对象。</p><p>2、 那么，此时如果异常发生在try语句，则会自动找到匹配的catch语句执行，如果没有在try语句中，则会将异常抛出，抛给调用方法者</p><p>3、 所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功，则表示由此catch进行处理。</p><p><img src="https://i.loli.net/2020/10/10/bVzw1mud4eif7ot.png" alt=""></p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>在进行异常的处理之后，在异常的处理格式中还有一个finally语句，那么此语句将作为异常的统一出口，<span style="color:red">不管是否产生了异常，最终<strong>必然都要</strong>执行此段代码</span>。</p><blockquote><p>  finally例子1：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(<span class="number">1</span>);</span><br><span class="line">           System.out.println(<span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"finally代码块中的内容"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  运行测试结果：说明即使在try和catch中return，在准备返回值与跳出函数之间，仍然会执行finally中的语句</p><p>  <img src="https://i.loli.net/2020/10/10/x5eOw9uGgMRCEdZ.png" alt="image-20201010164546702"></p><p>  finally例子2：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Person p = testFinally();</span><br><span class="line">       System.out.println(p.age);<span class="comment">//28</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">testFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Person p = <span class="keyword">new</span> Person();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           p.age = <span class="number">18</span>;</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           p.age = <span class="number">28</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  finally例子3：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = testFinally();</span><br><span class="line">       System.out.println(a);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> a;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           a = <span class="number">20</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  注意例子2和例子3，我们 testFinally() 方法一个返回的是引用数据类型，一个返回的是基本数据类型。例子3中返回非引用数据类型时return 备份的就是数据10，所以运行结果是10，不过此时栈中a的数据还是被改成20了。而在例子2中，我们return备份的是引用类型对象 p 在堆中的地址，存放在堆中那个地址的age被改为了28，当我们return 通过地址去找age时，就是会返回28。</p></blockquote><h3 id="异常处理真实场景举例"><a href="#异常处理真实场景举例" class="headerlink" title="异常处理真实场景举例"></a>异常处理真实场景举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = menu();</span><br><span class="line">        System.out.println(<span class="string">"您选择的序号是"</span> + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请根据提示，选择功能序号："</span>);</span><br><span class="line">        System.out.println(<span class="string">"0.退出\n1.增\n2.删\n3.改"</span>);</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = input.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (num&lt;<span class="number">0</span> || num&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"输入的序号必须是：0/1/2/3"</span>);</span><br><span class="line">                <span class="keyword">return</span> menu();<span class="comment">//如果数字范围超过预期，递归重新调用此函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入必须是数字"</span>);</span><br><span class="line">            <span class="keyword">return</span> menu();  <span class="comment">//如果输入非数字，递归重新调用此函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果测试：</p><p><img src="https://i.loli.net/2020/10/10/lKxIRXjcQ4SzuGh.png" alt="image-20201010161246734"></p><h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p>异常指的是Exception ， Exception类， 在Java中存在一个父类Throwable（可能的抛出）</p><p>Throwable存在两个子类：</p><ol><li>Error：表示的是错误，是JVM发出的错误操作,只能尽量避免，无法用代码处理。</li><li>Exception：一般表示所有程序中的错误，所以一般在程序中将进行try…catch的处理。</li></ol><p><img src="https://i.loli.net/2020/10/10/5WiUkG6aMdAOwYo.png" alt=""></p><blockquote><p>  多异常捕获的注意点：</p><ol><li><p>捕获更粗的异常不能放在捕获更细的异常之前。</p></li><li><p>如果为了方便，则可以将所有的异常都使用Exception进行捕获。</p><p>特殊的多异常捕获写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> |异常类型<span class="number">2</span> 对象名)&#123;</span><br><span class="line"><span class="comment">//表示此块用于处理异常类型1 和 异常类型2 的异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">"请输入一个数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> x = input.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"请再输入一个数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> y = input.nextInt();</span><br><span class="line">            System.out.println(x/y);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException | ArithmeticException e) &#123;<span class="comment">//格式一</span></span><br><span class="line">            System.out.println(<span class="string">"输入错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         catch(RuntimeException e（或Exception e）)&#123;//扩大异常的形态范围来捕获 ，格式二</span></span><br><span class="line"><span class="comment">         System.out.println("输入错误");</span></span><br><span class="line"><span class="comment">         &#125; </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"程序执行完毕，正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="throws和throw关键字"><a href="#throws和throw关键字" class="headerlink" title="throws和throw关键字"></a>throws和throw关键字</h2><p>###throws</p><p>在程序中异常的基本处理已经掌握了，但是随异常一起的还有一个称为throws关键字，此关键字主要在方法的声明上使用，表示方法中不处理异常，而交给调用处处理。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值 方法名称()<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是因为传入的参数导致异常的发生，则可以通过throws抛出异常。通常是谁调用谁处理；</p><p>如下代码，只有传入参数出错，程序才会出错。</p><p><img src="https://i.loli.net/2020/10/10/XwxopzQTY85asmi.png" alt="image-20201010184935241"></p><p>我们可以用谁调用谁处理的策略，使用throws关键字来处理异常</p><p><img src="https://i.loli.net/2020/10/10/t2qHGzpw1Lgfr7s.png" alt="image-20201010191247867"></p><p>###throw</p><p>throw关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出的就是一个异常类的实例化对象，那么此对象也可以由throw直接抛出。（真正应用时，自己造异常还是比较麻烦的，之前加判断也可以出现相同的效果，所以用的较少）</p><p>代码： <code>throw new Exception(&quot;抛着玩的。&quot;);</code></p><p>看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setAge(-<span class="number">1</span>);<span class="comment">//传入非法参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="comment">//处理异常时机：谁调用谁处理</span></span><br><span class="line">        <span class="comment">//之前在设计此函数时，当用户输入了不合理时，自动设为1，</span></span><br><span class="line">        <span class="comment">//但用户在没有任何提示的情况下，输入和实际展示不一致，者本身就是异常</span></span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="comment">//this.age = 1;</span></span><br><span class="line">            <span class="comment">//所以在发生异常时，需要告诉调用函数，发生了什么问题，而不是自己默默处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"年龄不合理"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2020/10/10/7ciUMJSWOrK5aE9.png" alt="image-20201010173420321"></p><h2 id="RuntimeExcepion与Exception的区别"><a href="#RuntimeExcepion与Exception的区别" class="headerlink" title="RuntimeExcepion与Exception的区别"></a>RuntimeExcepion与Exception的区别</h2><p>注意观察如下方法的源码：</p><p>Integer类：<code>public static int parseInt(String text)throws NumberFormatException</code></p><p>此方法抛出了异常， 但是使用时却不需要进行try…catch捕获处理，原因：</p><p>因为<code>NumberFormatException</code>并不是<code>Exception</code>的直接子类，而是<code>RuntimeException</code>的子类，<span style="color:red">只要是<code>RuntimeException</code>的子类，则表示程序在操作的时候可以不必使用try…catch进行处理，如果有异常发生，则由JVM进行处理。</span>当然，也可以通过try…catch处理。</p><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><blockquote><p>  编写一个类， 继承Exception，并重写一参构造方法 即可完成自定义<strong>受检异常</strong>类型。受检异常必须明确的处理或者抛出，否则编译不通过</p><p>  编写一个类， 继承RuntimeExcepion，并重写一参构造方法 即可完成自定义<strong>运行时异常（非受检异常）</strong>类型。</p><p>  例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123; <span class="comment">// 继承Exception，表示一个自定义异常类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg) ; <span class="comment">// 调用Exception中有一个参数的构造</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  自定义异常可以做很多事情， 例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg) ;</span><br><span class="line"><span class="comment">//在这里给维护人员发短信或邮件， 告知程序出现了BUG。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="异常处理常见题目"><a href="#异常处理常见题目" class="headerlink" title="异常处理常见题目"></a>异常处理常见题目</h2><ol><li><p><strong>try-catch-finally 中哪个部分可以省略？</strong></p><p>答： catch和finally可以省略其中一个 ， catch和finally不能同时省略<br>注意:格式上允许省略catch块, 但是发生异常时就不会捕获异常了,我们在开发中也不会这样去写代码.</p></li><li><p><strong>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></p><p>答：finally中的代码会执行</p><blockquote><p>  详解：</p><p>  ​        执行流程：</p><ol><li><p>先计算返回值， 并将返回值存储起来， 等待返回</p></li><li><p>执行finally代码块</p></li><li><p>将之前存储的返回值， 返回出去；</p><p>​       注意：</p></li><li><p>返回值是在finally运算之前就确定了，并且缓存了，不管finally对该值做任何的改变，返回的值都不会改变</p></li><li><p>finally代码中不建议包含return，因为程序会在上述的流程中提前退出，也就是说返回的值不是try或catch中的值</p></li><li><p>如果在try或catch中停止了JVM，则finally不会执行。例如停电，或通过如下代码退出<br>JVM：<code>System.exit(0);</code> </p></li></ol></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h2&gt;&lt;p&gt;异常是在程序中导致程序中断运行的一种指令流。&lt;/p&gt;
&lt;p&gt;先来看如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExceptionDemo&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;============= 计算开始 =============&quot;&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(i + &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; + j + &lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt; + i / j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;============= 计算结束 =============&quot;&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象高级</title>
    <link href="https://www.pengspace.top/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <id>https://www.pengspace.top/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</id>
    <published>2020-10-06T06:51:51.000Z</published>
    <updated>2020-10-06T07:02:49.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>有时候我们需要这样一个类，它不需要被实例化，也不需要实现完整的方法，它只是用来被继承的，用来限制子类的一个“规范”。这样的类我们就可以将它定义为<strong>抽象类</strong>，抽象类内的方法可以定义为<strong>抽象方法</strong>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">抽象类必须使用<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>声明</span></span><br><span class="line"><span class="class">一个抽象类中可以没有抽象方法。抽象方法必须写在抽象类或者接口中</span></span><br><span class="line"><span class="class">只声明而未实现的方法称为抽象方法（未实现是指：没有“</span>&#123;&#125;“方法体），抽象方法必须使用<span class="keyword">abstract</span>关键字声明。</span><br><span class="line">    </span><br><span class="line">格式：</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名();<span class="comment">//抽象方法，只声明而未实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>在抽象类的使用中有几个原则： </p><ul><li>抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字new完成。</li><li>一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则<strong>必须覆写(重写)</strong>抽象类中的全部抽象方法。</li></ul><p>常见的问题：</p><ul><li>抽象类不能使用final声明，因为final修饰的类是不能有子类的 ，而抽象类必须有子类才有意义。</li><li>抽象类能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的构造方法（默 认是无参的），之后再调用子类自己的构造方法。</li></ul></blockquote><h3 id="抽象类与普通类的区别"><a href="#抽象类与普通类的区别" class="headerlink" title="抽象类与普通类的区别"></a>抽象类与普通类的区别</h3><ol><li>抽象类必须用public或protected修饰(如果为private修饰，那么子类则无法继承，也就无法实现其抽象方法）。默认缺省为 public </li><li>抽象类不可以使用new关键字创建对象，但是在子类创建对象时，抽象父类也会被JVM实例化。 </li><li>如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为abstract类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;<span class="comment">//抽象类可以有构造方法</span></span><br><span class="line">        System.out.println(<span class="string">"抽象类的构造方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以定义Person对象变量，但它只能引用非抽象子类的对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以上代码的运行结果为：</span><br><span class="line">抽象类的构造方法执行了</span><br><span class="line">Student.run</span><br><span class="line">说明抽象类可以有构造方法，在new一个抽象类的非子类对象时，JVM会默认先执行抽象</span><br><span class="line">类的构造方法。虽然我们不能new抽象类对象，但我们可以通过子类来操作抽象类中的资源。</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的概念及定义"><a href="#接口的概念及定义" class="headerlink" title="接口的概念及定义"></a>接口的概念及定义</h3><p>如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接 口。 定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123; </span><br><span class="line">    全局常量 ; </span><br><span class="line">    抽象方法 ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>面向接口编程思想</strong></p><p>接口是定义（规范，约束）与实现（名实分离的原则）的分离的思想。 </p><p>优点：</p><ol><li>降低程序的耦合性 </li><li>易于程序的扩展 </li><li>有利于程序的维护</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因为接口本身都是由全局常量和抽象方法组成，所以接口中的成员定义可以简写： </span><br><span class="line"><span class="number">1</span>.全局常量编写时，可以省略 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 关键字，例如： </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">"内容"</span> ; </span><br><span class="line">简写后：</span><br><span class="line">String INFO = <span class="string">"内容"</span> ; </span><br><span class="line"><span class="number">2</span>.抽象方法编写时，可以省略 <span class="keyword">public</span> <span class="keyword">abstract</span> 关键字，例如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>; </span><br><span class="line">简写后：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><p>接口可以多实现，格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码称为接口的实现。那么如果一个类即要实现接口，又要继承抽象类的话，则按照以下的格式编写 即可： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">如果一个接口要想使用，必须依靠子类。 子类（如果不是抽象类的话）要实现接口中的所有抽象方法。</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int  AGE = 10; //简写全局常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;     <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口因为都是抽象部分， 不存在具体的实现， 所以允许多继承,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承相当于扩展了接口的方法</p><h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>JDK1.8之后规定，在接口中，可以定义default方法。例如，把Person中的say()方法改为default方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Li Ming"</span>);<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><ol><li>抽象类要被子类继承，接口要被类实现。 </li><li>接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。 </li><li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 </li><li>抽象类使用继承来使用， 无法多继承。 接口使用实现来使用， 可以多实现 </li><li>抽象类中可以包含static方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法） </li><li>接口不能有构造方法，但是抽象类可以有</li></ol><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Object类是所有类的父类（基类），如果一个类没有明确的继承某一个具体的类，则将默认继承Object类。例如我们定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>其实它被使用时 是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用Object可以接收任意的引用数据类型</strong></p></blockquote><h3 id="Object类中常用的方法"><a href="#Object类中常用的方法" class="headerlink" title="Object类中常用的方法"></a>Object类中常用的方法</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>建议重写Object中的toString方法。 此方法的作用：返回对象的字符串表示形式。</p><p>Object的toString方法， 返回对象的内存地址</p><p>类<code>Object</code>的<code>toString</code>方法返回一个字符串，该字符串由对象为实例的类的名称，字符“  <code>@</code> ”以及对象的哈希码的无符号十六进制表示形式组成。 换句话说，此方法返回一个等于值的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// getter和setter方法省略，若想放入ide中测试，请自行添加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p.toString());  <span class="comment">//top.oop.demo09.Person@27f674d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果不重写toString()，那打印的结果明显不能体现出我们所创建的对象的特征。所以建议在类中去重写toString()方法。</p><p>我们可以在Person中重写toString()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"这是一个人，他叫"</span> + <span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.age + <span class="string">"岁了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java  看上面toString中的Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出p1和p2的内容信息是完全一样的，但我们用 <code>==</code>比较时，会返回false。其实这也很好理解，每当我们new一个对象时就会在内存中开辟一块空间，也就是说p1和p2指向的是不同的内存地址，程序当然会判定他们不等。</p><p>但我们总需要对对象的信息进行比较，这时我们可以重写Object中的equals()方法来解决。不能直接用，直接用相当于还是在用<code>==</code> 比较。可以看Object中equals方法的源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议重写Object中的equals(Object obj)方法，此方法的作用：指示某个其他对象是否“等于”此对象。 </p><p>Object的equals方法：实现了对象上最具区别的可能等价关系; 也就是说，对于任何<strong>非空引用</strong>值x和y，当且仅当 x和y引用同一对象（ x == y具有值true ）时，此方法返回true 。 </p><blockquote><p>equals方法重写时的五个特性： </p><ul><li>自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 </li><li>对称性 ：对于任何非空引用值x和y，x.equals(y)应该返回true当且仅当y.equals(x)回报true 。</li><li>传递性 ：对于任何非空引用值x ，y和z ，如果x.equals(y)返回true且y.equals(z)返回true ，那么 x.equals(z)应该返回true 。 </li><li>一致性 ：对于任何非空引用值x和y ，多次调用x.equals(y)始终返回true或始终返回false ，前提是未修改对象上的equals比较中使用的信息。 </li><li>非空性 ：对于任何非空的参考值x ， x.equals(null)应该返回false 。</li></ul></blockquote><p>equals一般根据我们的业务进行重写，举个例子,我们可以在Person类中重写equals方法，当唯一标识符id相等时，我们就认为这两个对象相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;<span class="comment">//如果传入的对象为空，根据非空性，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;<span class="comment">//如果传入的对象与当前对像类型相同</span></span><br><span class="line">        Person p2 = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.id == p2.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以进行简化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传入的对象为空或与当前对象类型不同，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.id == p.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA 快捷键 <code>Alt+Inster</code>可以自动重写equals方法和toString方法</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 </p><p>广泛意义上的内部类一般来说包括这四种：</p><ol><li>成员内部类</li><li>局部内部类 </li><li>匿名内部类 </li><li>静态内部类</li></ol><p>###成员内部类</p><p><strong>定义：</strong>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">200</span>;<span class="comment">//与外部类同名的变量</span></span><br><span class="line">System.out.println(<span class="string">"x="</span>+ x);<span class="comment">// x = 200.0</span></span><br><span class="line">            System.out.println(<span class="string">"x="</span> + Outer.<span class="keyword">this</span>.x); <span class="comment">//访问外部类的同名成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure><p><strong>成员内部类的使用：</strong></p><p>以上面定义的Outer类为例，来看如何让使用它里面的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="number">100</span>);</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.say();    </span><br><span class="line">        <span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">         *x = 200.0</span></span><br><span class="line"><span class="comment">         *  x = 100.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###局部内部类 </p><p>局部内部类是<strong>定义在一个方法或者一个作用域里面的类</strong>，它和成员内部类的区别在于<strong>局部内部类的访问仅限</strong><br><strong>于方法内或者该作用域内</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> People <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123; <span class="comment">//局部内部类 定义在了getPerson方法内</span></span><br><span class="line"><span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及<br>static修饰符的。</p></blockquote><p>下面我们使用系统的某个API，来演示局部内部类的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Frame;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">"登录"</span>);<span class="comment">//新建一个窗体</span></span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);     <span class="comment">//设置是否显示</span></span><br><span class="line">        f.setSize(<span class="number">300</span>,<span class="number">200</span>); <span class="comment">//设置大小</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyWindowListener</span> <span class="keyword">implements</span> <span class="title">WindowListener</span> </span>&#123;  <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关闭窗口"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);<span class="comment">//关闭窗口操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MyWindowListener l = <span class="keyword">new</span> MyWindowListener();</span><br><span class="line">        f.addWindowListener(l);      <span class="comment">//窗口监听器,需要传入一个实现WindowListener接口的类类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类由于没有名字，只能使用一次。创建格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//匿名内部类的类体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。这个引用是隐式的。</p><blockquote><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><ol><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能<br> 继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li><strong>匿名内部类为局部内部类</strong>，所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li><li>和局部内部类一样，只能访问final型的局部变量，因为内部类会被单独编译成一个字节码文件，为了保障这个单独的文件中用到的内部类外部的变量与内部类外部的变量的值绝对一致，系统从规则上限制这个值不可以被更改。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//jdk1.8以后可以省略final</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;<span class="comment">//明显b不是final型的</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;   <span class="comment">//匿名内部类实现了Person接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的say方法"</span> + a);</span><br><span class="line">                <span class="comment">//System.out.println(b); //报错，局部内部类和匿名内部类不能访问非final型的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ha(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ha</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p><p>静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它<strong>不能使用外部类的非</strong><br><strong>static成员变量或者方法.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticInnerClass.y = <span class="number">100</span>;</span><br><span class="line">Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        inner.say();<span class="comment">//100.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//System.out.println(x); //报错,静态内部类不能访问外部类的非静态成员和方法</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在Java中有一个设计的原则“一切皆对象”，那么这样一来Java中的一些基本的数据类型，就完全不符合于这种设计思想，因为Java中的八种基本数据类型并不是引用数据类型，所以Java中为了解决这样的问题，引入了八种基本数据类型的包装类。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr></tbody></table><p>以上的八种包装类，可以将基本数据类型按照类的形式进行操作。</p><p>以上的八种包装类也分为两种大的类型：</p><ul><li>Number：Integer、Short、Long、Double、Float、Byte都是Number的子类表示是一个<br>  数字。</li><li>Object：Character、Boolean都是Object的直接子类。</li></ul><h3 id="装箱和拆箱操作"><a href="#装箱和拆箱操作" class="headerlink" title="装箱和拆箱操作"></a>装箱和拆箱操作</h3><p>以下以<code>Integer</code>和<code>Float</code>为例进行操作</p><p>将一个<strong>基本数据类型变为包装类，那么这样的操作称为装箱操作</strong>。</p><p>将一个<strong>包装类变为一个基本数据类型，这样的操作称为拆箱操作</strong>，</p><p>因为所有的数值型的包装类都是Number的子类，Number的类中定义了如下的操作方法，以下的全部方法都<br>是进行拆箱的操作。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public byte byteValue()</td><td>用于Byte-&gt;byte</td></tr><tr><td>public abstract double doubleValue()</td><td>用于Double-&gt;double</td></tr><tr><td>public abstract float floatValue()</td><td>用于Float-&gt;float</td></tr><tr><td>public abstract int intValue()</td><td>用于Integer-&gt;int</td></tr><tr><td>public abstract long longValue()</td><td>用于Long-&gt;long</td></tr><tr><td>public short shortValue()</td><td>用于Short-&gt;short</td></tr></tbody></table><p><strong>装箱操作：</strong></p><p>在JDK1.4之前 ，如果要想装箱，直接使用各个包装类的构造方法即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span> ; <span class="comment">// 基本数据类型</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Integer(temp) ; <span class="comment">// 将基本数据类型变为包装类</span></span><br></pre></td></tr></table></figure><p>在JDK1.5，Java新增了自动装箱和自动拆箱，而且可以直接通过包装类进行四则运算和自增自减操作。例<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Float f = <span class="number">10.3f</span> ; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">float</span> x = f ; <span class="comment">// 自动拆箱</span></span><br><span class="line">System.out.println(f * f) ; <span class="comment">// 直接利用包装类完成</span></span><br><span class="line">System.out.println(x * x) ; <span class="comment">// 直接利用包装类完成</span></span><br></pre></td></tr></table></figure><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>使用包装类还有一个很优秀的地方在于：可以将一个字符串变为指定的基本数据类型，此点一般在接收输入<br>数据上使用较多。<br>在<code>Integer</code>类中提供了以下的操作方法：<br>        <code>public static int parseInt(String s)</code> ：将String变为int型数据<br>在<code>Float</code>类中提供了以下的操作方法：<br>        <code>public static float parseFloat(String s)</code>：将String变为Float<br>在<code>Boolean</code> 类中提供了以下操作方法：<br>        <code>public static boolean parseBoolean(String s)</code>：将String变为boolean<br>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String text = input.nextLine();</span><br><span class="line">        <span class="keyword">int</span> x = Integer.parseInt(text);     <span class="comment">//转为int类型,便于运算</span></span><br><span class="line">        System.out.println(x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;有时候我们需要这样一个类，它不需要被实例化，也不需要实现完整的方法，它只是用来被继承的，用来限制子类的一个“规范”。这样的类我们就可以将它定义为&lt;strong&gt;抽象类&lt;/strong&gt;，抽象类内的方法可以定义为&lt;strong&gt;抽象方法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象进阶</title>
    <link href="https://www.pengspace.top/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
    <id>https://www.pengspace.top/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</id>
    <published>2020-10-04T06:12:29.000Z</published>
    <updated>2020-10-13T05:39:52.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>static关键字</strong></p><p>static表示“静态”的意思，可以用来修饰成员变量和成员方法。</p><p>static的主要作用在于创建独立于具体对象的域变量或者方法 </p><a id="more"></a><p>简单理解： </p><p>​        被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 并且不会因为对象的多次创建而在内存中建立多份数据</p><p><strong>注意</strong></p><ol><li><span style="color:red">静态成员在类加载时加载并初始化。</span> </li><li><span style="color:red">无论一个类存在多少个对象 , 静态的属性, 永远在内存中只有一份(可以理解为所有对象公用 ) </span></li><li><span style="color:red">在访问时：静态不能访问非静态 , 非静态可以访问静态 ! 静态资源的执行时机可能早于非静态资源,一定不会晚于非静态资源</span> </li></ol></blockquote><blockquote><p><strong>final关键字</strong></p><p>final表示“最终”的意思，可以用来修饰属性、变量、类和方法</p><p>final修饰的属性、变量就成为了常量，无法对其再次进行赋值。final 修饰的局部变量，只能赋值一次（可以先声明后赋值）；final修饰的成员属性，必须在声明时赋值！</p><p>全局常量：<code>public static final 数据类型 变量名</code></p><p>final修饰的类不可以被继承</p><p>final修饰的方法不能被子类重写</p></blockquote><blockquote><p><strong>代码块</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通代码块 </span><br><span class="line">在执行的流程中出现的代码块，我们称其为普通代码块。 </span><br><span class="line">构造代码块 </span><br><span class="line">在类中的成员代码块，我们称其为构造代码块，在每次对象创建时执行，执行在构造方法之前。 </span><br><span class="line">静态代码块</span><br><span class="line">在类中使用<span class="keyword">static</span>修饰的成员代码块，我们称其为静态代码块，在类加载时执行。 每次程序启动到关闭，只会执行一次的代码块。 </span><br><span class="line">同步代码块 </span><br><span class="line">在后续多线程技术中学习。 </span><br><span class="line"></span><br><span class="line">面试题： </span><br><span class="line">构造方法与构造代码块以及静态代码块的执行顺序：</span><br><span class="line">静态代码块 --&gt; 构造代码块 --&gt; 构造方法</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>mian()方法详解</strong></p><p><code>public static void main(String args[])</code> </p><p>以上的各个参数的含义如下： </p><p>​        public：表示公共的内容，可以被所有操作所调用 </p><p>​        static：表示方法是静态的，可以由类名称直接调用。</p><p>​        void：表示没有任何的返回值操作 </p><p>​        main：系统规定好的方法名称。如果main写错了或没有，会报错：NoSuchMethodError: main </p><p>​        String[] args：字符串数组，接收参数的</p></blockquote><h2 id="面向对象的三大特征（抽象）"><a href="#面向对象的三大特征（抽象）" class="headerlink" title="面向对象的三大特征（抽象）"></a>面向对象的三大特征（抽象）</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>该露的露，该藏的藏。我们程序设计要追求<span style="color:red">“高内聚，低耦合”</span>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉，低耦合就是仅暴漏少量的方法给外部使用。</p><p>封装(数据的隐藏)。通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称之为信息隐藏。</p><p>总之就是：<span style="color:red"><strong>属性私有，get/set</strong></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性：私有 private</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idNum;<span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些可以操纵私有属性的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set 设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//this关键字：this指当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNum</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idNum = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.idNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;<span class="number">120</span> || age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        stu1.setName(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(stu1.getName());</span><br><span class="line">        stu1.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Idea快捷方式   <kbd>Alt</kbd>+<kbd>Insert</kbd> : 自动生成get/set方法</p></blockquote><blockquote><p>在Java基础中，this关键字是一个最重要的概念。使用this关键字可以完成以下的操作：</p><ul><li>调用类中的属性 </li><li>调用类中的方法或构造方法</li><li>表示当前对象</li></ul></blockquote><blockquote><p><strong>权限修饰符</strong></p><table><thead><tr><th>修饰符</th><th>类</th><th>包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>如上表所示，public修饰的资源可以被其所在类，所在包，所在类的子类和其他包访问，protecte修饰的资源不可以被其他包访问，default修饰的资源只能被其所在类，所在包访问，而private修饰的资源只能被其所在类访问</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p><p><span style="color:red">Java中类只有单继承，多重继承，没有多继承！</span></p><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</p><p>private 类型的属性和方法不可被继承，也就是说子类不能调用父类私有的属性和方法。</p><p><strong>object</strong>类：在Java类，所有的类都默认直接或者间接继承Object类</p><p><strong>super</strong>：类似this,this指示的是当前对象，super指示的是其父类对象。通过supe，可以访问父类的构造方法、父类的属性和父类的方法。<span style="color:red">使用super调用了父类构造方法时，必须要在子类构造器的第一行</span></p><p>在我们创建子类对象时，内存中会先创建父类对象，再创建子类对象，子类会通过super关键字拥有父类的地址，来调用父类中可使用的属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">"Brian"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person父类的无参构造执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//隐藏代码：调用了父类的无参构造。若要写，必须要在子类构造器的第一行。如果父类没有无参构造，则super(参数...)不可被省略。</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Student子类的无参构造执行了"</span>);</span><br><span class="line">        <span class="comment">//super(); 错误。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ZhangSan"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//ZhangSan</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);<span class="comment">//Brian</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Person父类的无参构造执行了</span></span><br><span class="line"><span class="comment">Student子类的无参构造执行了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        张三</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">Brian</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test1();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Student</span></span><br><span class="line"><span class="comment">Student</span></span><br><span class="line"><span class="comment">Person</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">注意：</span></p><ol><li>super调用父类的构造方法，必须在子类构造方法的第一个！</li><li>super必须只能出现在子类的方法或者构造方法中！</li><li>super和this不能同时调用构造方法！</li></ol><p>super VS this</p><ul><li>代表的对象不同：<ul><li>this : 本身调用者这个对象</li><li>super : 代表父类对象的应用</li></ul></li><li>前提：<ul><li>this 没有继承也可以使用</li><li>super : 只能在继承条件下才能使用</li></ul></li><li>构造方法：<ul><li>this() : 本类的构造</li><li>super() :  父类的构造</li></ul></li></ul></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写:"></a>方法重写:</h4><p>规则：</p><ul><li><strong>参数列表必须完全与被重写方法的相同。</strong></li><li>一般情况下，<strong>返回值类型必须完全与被重写方法的返回值类型相同</strong>；当返回值为<strong>类类型</strong>时，重写的方法返回值可以不同，但<strong>必须是父类方法返回值的子类</strong>。</li><li><strong>访问权限不能比父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 和 private 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.A;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法:方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">    <span class="comment">//非静态方法:重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//结果：A-&gt;test()</span></span><br><span class="line">        <span class="comment">//父类的引用指向子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test(); <span class="comment">//子类重写了父类的方法结果：A-&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么需要重写？</strong></p><ol><li>父类的功能，子类不一定需要，或者不一定满足。</li></ol></blockquote><blockquote><p>Idea快捷方式   <kbd>Ctrl</kbd>+<kbd>H</kbd> : 显示继承关系</p></blockquote><blockquote><p><strong>重写（override）与重载（overload）的区别</strong></p><ol><li>重载发生在一个类中，重写发生在子父类中</li><li>重载参数列表必须不同，重写的参数列表必须相同</li><li>重载与返回值类型无关，重写的返回值类型必须一致或是父类的子类</li><li>重载与访问权限无关，重写中，子类的方法的访问权限不能小于父类中被重写方法的权限</li><li>重载与异常无关，重写的方法不能抛出新的异常，或者比被重写方法声明的更广泛的异常</li></ol></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式。一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p><p>多态存在的条件：</p><ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象  <code>Father f1 = new Son();</code></li></ul><blockquote><p><strong>注意：</strong></p><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系，若无，则会报异常(类型转换异常:ClassCastException)</li></ol></blockquote><blockquote><p>有些方法无法重写：</p><ol><li>static 方法  属于类，不属于实例对象</li><li>final </li><li>private 方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 父类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Person;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象的实际类型是确定的，可以指向的引用类型就不确定了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Person 父类，可以指向子类，但不能调用子类独有的方法</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();<span class="comment">//Person对象 </span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();  <span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        <span class="comment">// Student 能调用的方法都是自己的或者继承父类的！</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();<span class="comment">//Student对象</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">p1.run();<span class="comment">//run 执行Person类的方法</span></span><br><span class="line">        s2.run();<span class="comment">//son  子类重写了父类的方法，执行子类Student类的方法</span></span><br><span class="line">        s1.run();<span class="comment">//son</span></span><br><span class="line">        <span class="comment">//s2.eat(); 错误:s2的引用类型为Person类型 它不能调用子类独有的方法</span></span><br><span class="line">        s1.eat();<span class="comment">//eat 执行Student类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展： <code>instanceof</code>和类型转换</strong></p><p><strong><code>instanceof</code></strong></p><p>关键字  <code>instanceof</code> ： Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><p><strong>1. obj必须为引用类型，不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p>instanceof运算符只能用作对象的判断。</p><p><strong>2. obj 为 null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>关于 null 类型的描述在官方文档：<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1</a> 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte short int long float double char boolean,一种是引用类型，包括类、接口、数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的<strong>特殊符号</strong>。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2" target="_blank" rel="noopener">JavaSE规范</a> 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</p><p><strong>3. obj为class类的实例对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>4. obj为class接口的实现类</strong></p><p>集合中有个上层接口 List，其有个典型实现类 ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;    </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>或者反过来也是返回 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>5. obj为class类的直接或间接子类</strong></p><p>新建一个父类 Person，然后在创建它的一个子类 Man</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Man m1 = <span class="keyword">new</span> Man();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);<span class="comment">//false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意第一种情况， <code>p1 instanceof Man</code> ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。</p><h6 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h6><p>java的引用类型转换分为两种：</p><ol><li><p>向上类型转换，是小类型到大类型的转换 ，子类转换为父类，可能会丢失自己本来的一些方法</p></li><li><p>向下类型转换，是大类型到小类型的转换 (强制转换)  父类转化为子类</p><p> <strong>引用类型的强转条件</strong> : 把父类类型(直接父类+间接父类)  —&gt; 子类类型</p><p>  A x = (A)B;  只要B是A的父类,此句代码编译通过</p><p> <strong>强转的意义</strong>：把父类类型强转为子类类型，在编译期可以调用子类的字段与方法(父类的字段与方法子类都能直接继承，但是子类有的父类有可能没有)==&gt;强转之后，父类与子类的字段与方法都可以使用</p></li></ol><p>现存在一个Person类，Student子类和Teacher子类继承于Person父类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father class:run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son Student class:go"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个student对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();   <span class="comment">//使用子类引用实例化子类对象</span></span><br><span class="line"><span class="comment">//Teacher t = (Teacher)s;//不能转，因为Student 与 Teacher没有继承关系</span></span><br><span class="line">Person p = s; <span class="comment">//此时为向上引用转换，小类型转换为大类型，自动转换，并没有风险</span></span><br><span class="line"><span class="comment">//p.go(); //错误，Person引用类型不能调用子类独有的方法</span></span><br><span class="line">Person ps = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//Student s2 = (Student)ps;//引用类型的大转小，强制转换.</span></span><br></pre></td></tr></table></figure><p>向下引用转换应该先判断类型是否一致，利用java的instanceof关键字判断。instanceof运算符用法：判断是一个实例对象是否属于一个类，是返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Teacher) &#123;<span class="comment">//判断p2是否是Teacher类型的对象</span></span><br><span class="line">    Teacher tea = (Teacher)p2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Student) &#123;<span class="comment">//判断p2是否是Student类型的对象</span></span><br><span class="line">    Student stu = (Student)p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在实际项目中,p2的值可能是new Student()|new Teacher()|new Person(). 如果值是new Teacher()则把该对象p2强转为Teacher类型</span></span><br><span class="line"><span class="comment">问题：如何判断p2的值到底是new的哪个类对象？</span></span><br><span class="line"><span class="comment">方案：使用instanceof.       instanceof:判断指定变量是否是指定类型的对象。</span></span><br><span class="line"><span class="comment">当前场景：判断 p2 是否是 Teacher类型 的对象。</span></span><br><span class="line"><span class="comment">语法：指定变量 instanceof 指定类型。   返回false:不是指定类型的对象 ， 反之则反</span></span><br><span class="line"><span class="comment">在运行期有效。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是当子类实例对象统一放进父类引用对象数组时，若要使用子类中的方法，必须先向下转换类型为子类引用，不然编译器会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = &#123;</span><br><span class="line">    <span class="keyword">new</span> Student(),</span><br><span class="line">    <span class="keyword">new</span> Teacher()</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//people[0].go();   //报错</span></span><br><span class="line"><span class="keyword">if</span>(people[<span class="number">0</span>] <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    ((Student)people[<span class="number">0</span>]).go();<span class="comment">//son Student class:go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;static关键字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static表示“静态”的意思，可以用来修饰成员变量和成员方法。&lt;/p&gt;
&lt;p&gt;static的主要作用在于创建独立于具体对象的域变量或者方法 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础</title>
    <link href="https://www.pengspace.top/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.pengspace.top/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-30T04:17:29.000Z</published>
    <updated>2020-09-30T04:58:42.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h2><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p><strong>面向过程思想：</strong></p><ul><li>是把模型分解成一步一步的过程。步骤清晰简单，第一步做什么，第二步做什么……</li><li>面向过程适合处理一些较为简单的问题</li></ul><a id="more"></a><p><strong>面向对象思想：</strong></p><ul><li>物以类聚，<span style="color:red">分类</span>的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul><p><span style="color:red">对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路、来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</span></p><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向对象编程(Object-Oriented Progrsmming,OOP)是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p><strong>面向对象编程的本质就是：</strong><span style="color:red">以类的方式组织代码，以对象的形式封装数据。</span></p><p><strong>面向对象的核心思想：</strong></p><ul><li><p><strong>三大思想：</strong>面向对象思想从概念上讲分为以下三种OOA、OOD、OOP</p><ul><li>OOA：面向对象分析（Object Oriented Analysis） </li><li>OOD：面向对象设计（Object Oriented Design） </li><li>OOP：面向对象程序（Object Oriented Programming）</li></ul></li><li><p><strong>抽象</strong></p></li><li><p><strong>三大特性</strong></p><ul><li>封装性：所有的内容对外部不可见</li><li>继承性：将其他的功能继承下来继续发展</li><li>多态性：方法的重载本身就是一个多态性的体现</li></ul></li></ul><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>具体可参考 <a href="http://pengspace.top/2020/05/30/Java方法/#more">java方法</a>，此处只做一些补充说明</p><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><h5 id="break和return的区别"><a href="#break和return的区别" class="headerlink" title="break和return的区别"></a>break和return的区别</h5><p><code>break</code>:结束整个循环</p><p><code>continue</code>:结束本次循环</p><p><code>return</code>: 结束方法，返回一个结果</p><h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h5><p>注意规范，首字母小写和驼峰原则。见名知意</p><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>（参数类型，参数名）…</p><h5 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) <span class="keyword">throws</span> 异常类型(如 IOException) &#123;  </span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><h5 id="静态方法和非静态方法"><a href="#静态方法和非静态方法" class="headerlink" title="静态方法和非静态方法"></a>静态方法和非静态方法</h5><p><span style="color:red">非静态方法不能通过类名直接调用，若要调用非静态方法，必须先实例化该方法所在类的对象，通过对象来调用。</span></p><p><span style="color:red">静态方法可以通过类名直接调用，也可以通过对象调用。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student.say1();</span><br><span class="line">        <span class="comment">//Student.say2();错误，非静态方法不能通过类名直接调用</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();<span class="comment">//实例化对象</span></span><br><span class="line">        stu.say1();</span><br><span class="line">        stu.say2();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"非静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">静态方法是和类一起加载的，而非静态方法是在类实例化后才会起作用的</span>，所以在类中，也不能在静态方法中去调用非静态方法</p><h5 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h5><blockquote><p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。</p><p>实际参数：在调用有参函数时，主调函数和被调函数有数据传递关系。在主调函数中调用一个函数时，函数后面括号中的参数称为“实际参数”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//实际参数和形式参数的类型要对应</span></span><br><span class="line">        <span class="keyword">int</span> add = demo.add(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//1和2是实参</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    <span class="comment">//a和b是形参</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际参数是调用有参方法时真正传递的内容，而形式参数是用于接收实参内容的参数。</p><h5 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h5><p><span style="color:red">Java中都是值传递。</span></p><p>后续会专门写一篇来讲述Java为什么都是值传递。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><span style="color:red">类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</span>比如Person类、Pet类、Car类等，这些类都是<span style="color:red">用来描述/定义某一类具体事物应该具备的特点和行为。</span></p><p><span style="color:red">对象是抽象概念的具体实例。</span>比如 你就是个人的具体实例，你家的旺财就是狗的一个具体实例。<span style="color:red">能够体现出特点、展现出功能的是具体的实例，而不是一个抽象的概念。</span></p><h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">成员属性</span><br><span class="line">成员方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">属性定义格式：</span><br><span class="line">数据类型 属性名;</span><br><span class="line">属性定义并赋值的格式：</span><br><span class="line">数据类型 属性名 = 初始化值;</span><br><span class="line">方法定义格式：</span><br><span class="line">权限修饰符 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用<code>new</code>关键字创建对象。</p><p>使用<code>new</code>关键字创建对象的时候，除了为对象分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个类要想真正的进行操作，则必须依靠对象，对象的定义格式如下:</span><br><span class="line">类名称 对象名称 = <span class="keyword">new</span> 类名称();</span><br><span class="line"></span><br><span class="line">如果要想访问类中的属性或方法（方法的定义），则可以依靠以下的语法形式：</span><br><span class="line">访问类中的属性： 对象.属性 ;</span><br><span class="line">调用类中的方法： 对象.方法(实际参数列表) ;</span><br></pre></td></tr></table></figure><h3 id="构造方法（构造器）详解"><a href="#构造方法（构造器）详解" class="headerlink" title="构造方法（构造器）详解"></a>构造方法（构造器）详解</h3><p>一个类中即使什么都不写，也可以实例化该类的对象，那是因为，类中默认存在一个方法，就是<span style="color:red"><strong>构造器</strong></span>。</p><p>类中的<span style="color:red"><strong>构造器</strong></span>也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：</p><ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写void</li></ul><p>我们在使用<code>new</code>关键字实例化对象时,本质是在调用构造器,来初始化值。</p><p>构造器可以重载，但注意，<span style="color:red">一旦你定义了有参构造器，如果还想使用无参构造，无参构造器就必须也显式定义。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个类即使什么都不写，它也会存在一个方法</span></span><br><span class="line">    <span class="comment">//默认构造器 public  Person()&#123;&#125;</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造器 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造器：一旦定义了有参构造，无参构造器就必须显式定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new 实例化对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(person.name);    <span class="comment">//null</span></span><br><span class="line">        System.out.println(person1.name);   <span class="comment">//brian</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有对象名称的对象 就是匿名对象。 </span><br><span class="line">匿名对象只能使用一次，因为没有任何的对象引用，所以将称为垃圾，等待被GC回收。 </span><br><span class="line">只使用一次的对象可以通过匿名对象的方式完成，这一点在以后的开发中将经常使用到。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Math().sum(<span class="number">100</span>,<span class="number">20</span>);<span class="comment">//匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>Java栈的区域很小 , 大概2m左右 , 特点是存取的速度特别快 </p><p>栈存储的特点是, 先进后出</p><p>存储速度快的原因: </p><p>栈内存, 通过 ‘栈指针’ 来创建空间与释放空间 ! </p><p>指针向下移动, 会创建新的内存, 向上移动, 会释放这些内存 ! </p><p>这种方式速度特别快 , 仅次于PC寄存器 ! </p><p>但是这种移动的方式, 必须要明确移动的大小与范围 , 明确大小与范围是为了方便指针的移动 , 这是一个对于数据存储的限制, 存储的数据大小是固定的 , 影响了程序 的灵活性 ~</p><p>所以我们把更大部分的数据 存储到了堆内存中 </p><p>存储的是: </p><p>​        基本数据类型的数据 以及 引用数据类型的引用! </p><p>​        例如: </p><p>​        int a =10;</p><p>​        Person p = new Person(); </p><p>​        10存储在栈内存中 , 第二句代码创建的对象的引用(p)存在栈内存中</p></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>存放的是类的对象 . </p><p>Java是一个纯面向对象语言, 限制了对象的创建方式: </p><p>​        <span style="color:red">所有类的对象都是通过new关键字创建 </span></p><p>new关键字, 是指告诉JVM , 需要明确的去创建一个新的对象 , 去开辟一块新的堆内存空间: </p><p>堆内存与栈内存不同, 优点在于我们创建对象时 , 不必关注堆内存中需要开辟多少存储空间 , 也不需要关注内存占用 时长 ! </p><p>堆内存中内存的释放是由GC(垃圾回收器)完成的 </p><p>垃圾回收器 回收堆内存的规则: </p><p>​        当栈内存中不存在此对象的引用时,则视其为垃圾 , 等待垃圾回收器回收 !</p></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>存放的是 </p><ul><li>类信息 </li><li>静态的变量 </li><li>常量</li><li>成员方法 </li></ul><p>方法区中包含了一个特殊的区域 ( 常量池 )(存储的是使用static修饰的成员)</p></blockquote><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><blockquote><p>PC寄存器保存的是 当前正在执行的 JVM指令的 地址 ! </p><p>在Java程序中, 每个线程启动时, 都会创建一个PC寄存器 !</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>保存本地(native)方法的地址 !</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识面向对象&quot;&gt;&lt;a href=&quot;#初识面向对象&quot; class=&quot;headerlink&quot; title=&quot;初识面向对象&quot;&gt;&lt;/a&gt;初识面向对象&lt;/h2&gt;&lt;h3 id=&quot;面向过程和面向对象&quot;&gt;&lt;a href=&quot;#面向过程和面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向过程和面向对象&quot;&gt;&lt;/a&gt;面向过程和面向对象&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;面向过程思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是把模型分解成一步一步的过程。步骤清晰简单，第一步做什么，第二步做什么……&lt;/li&gt;
&lt;li&gt;面向过程适合处理一些较为简单的问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>简单的Java加减乘除计算器(适合新手)</title>
    <link href="https://www.pengspace.top/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/"/>
    <id>https://www.pengspace.top/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/</id>
    <published>2020-05-30T14:59:13.000Z</published>
    <updated>2020-09-30T04:24:41.405Z</updated>
    
    <content type="html"><![CDATA[<p>本人Java新手一枚，刚学完Java数据类型、流程控制、数组、方法等基础语法知识。</p><p>尝试写了一个简单的计算器，实现了加减乘除功能，并可以循环接收数据。</p><p>代码有待改进，希望各位大佬多多指点 :beers:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第一个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> a = in.nextDouble();</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第二个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> b = in.nextDouble();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入运算方式(+ - * /)"</span>);</span><br><span class="line">                String operation = in.next();</span><br><span class="line">                <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                        System.out.println(add(a,b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                        System.out.println(subtraction(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                        System.out.println(multiply(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                        System.out.println(division(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"是否继续使用? "</span> + <span class="string">"YES/NO"</span>);</span><br><span class="line">                String choose = in.next();</span><br><span class="line">                <span class="keyword">if</span> (choose.equals(<span class="string">"YES"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose.equals(<span class="string">"NO"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"欢迎下次使用，再见"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">subtraction</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">multiply</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"被除数不能为0"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人Java新手一枚，刚学完Java数据类型、流程控制、数组、方法等基础语法知识。&lt;/p&gt;
&lt;p&gt;尝试写了一个简单的计算器，实现了加减乘除功能，并可以循环接收数据。&lt;/p&gt;
&lt;p&gt;代码有待改进，希望各位大佬多多指点 :beers:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java练习" scheme="https://www.pengspace.top/categories/Java%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="代码" scheme="https://www.pengspace.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Java方法</title>
    <link href="https://www.pengspace.top/2020/05/30/Java%E6%96%B9%E6%B3%95/"/>
    <id>https://www.pengspace.top/2020/05/30/Java%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-30T13:32:41.000Z</published>
    <updated>2020-05-30T13:37:09.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法概述"><a href="#方法概述" class="headerlink" title="方法概述"></a>方法概述</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p><ul><li>方法是解决一类问题的步骤的有序组合</li><li>方法包含于类或对象中</li><li>方法在程序中被创建，在其他地方被引用</li></ul><a id="more"></a><p><strong>设计方法的原则：</strong></p><p>方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的<span style="color:red">原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展</span>。</p><p><strong>方法的命名规范：</strong></p><p>首字母小写和驼峰原则：run()，runRun()。</p><h2 id="方法的定义及调用"><a href="#方法的定义及调用" class="headerlink" title="方法的定义及调用"></a>方法的定义及调用</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><p>Java的方法类似于其它语言函数是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法：</p><p><span style="color:red">方法包含一个方法头和一个方法体。</span>下面是一个方法的所有部分：</p><ul><li><span style="color:red">修饰符</span>：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li><li><span style="color:red">返回值类型</span>：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li><li><span style="color:red">方法名</span>：是方法的实际名称。方法名和参数表共同构成方法签名。</li><li><span style="color:red">参数类型</span>：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。<ul><li>形式参数：在方法被调用时用于接收外界输入的数据。</li><li>实参：调用方法时实际传给方法的数据。</li></ul></li><li><span style="color:red">方法体</span>：方法体包含具体的语句，定义该方法的功能。</li><li><span style="color:red">返回值</span>：如果返回值类型不为void，那么需要在方法体的最后return返回值，遇到return即结束方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名)&#123;</span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>调用方法：对象名.方法名（实参列表）</p><p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p><ul><li><p>当方法返回一个值的时候，方法调用通常被当做一个值。例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> larger = max(<span class="number">20</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>如果方法返回值是void，方法调用一定是一条语句。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h2><p>重载就是在一个类中，有相同的函数名称，但形参不同的函数。</p><p><strong>方法的重载的规则：</strong></p><ul><li>方法名称必须相同。</li><li>参数列表必须不同（个数不同、或类型不同、参数排列顺序不同等）。</li><li>方法的返回类型可以相同也可以不相同。·仅仅返回类型不同不足以成为方法的重载。</li></ul><p><strong>实现理论：</strong></p><p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p><h2 id="命令行传参"><a href="#命令行传参" class="headerlink" title="命令行传参"></a>命令行传参</h2><p>有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> staticvoid) main(String args[])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++)&#123;</span><br><span class="line">System.out.println(<span class="string">"args["</span>+ i +<span class="string">"]:"</span>+args[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/30/ZSfx6b4NPU8Xdhe.png" alt=""></p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>JDK 1.5开始，Java支持传递同类型的可变参数给一个方法。</p><p>在方法声明中，在指定参数类型后加一个省略号（…）。</p><p>一个方法中只能指定<strong>一个</strong>可变参数，它必须是方法的<strong>最后一个参数</strong>。任何普通的参数必须在它之前声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMax</span><span class="params">(<span class="keyword">double</span>... numbers)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(<span class="string">"No argument passed"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> result=numbers[<span class="number">0</span>];</span><br><span class="line"><span class="comment">//排序！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; numbers.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(numbers[i]&gt;result)&#123;</span><br><span class="line">result=numbers[i];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">System.out.println(<span class="string">"The max value is "</span>+result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a><span style="color:red">递归</span></h2><p>A方法调用B方法，我们很容易理解</p><p><strong>递归就是：</strong>A方法调用A方法！就是自己调用自己</p><p>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合。</p><p><strong>递归结构包括两个部分：</strong></p><ul><li><span style="color:red">边界(递归头)</span>：什么时候不调用自身方法。如果没有头，将陷入死循环。</li><li><span style="color:red">递归体</span>：什么时候需要调用自身方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;<span class="comment">//边界</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        n = n*factorial(n-<span class="number">1</span>);<span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;方法概述&quot;&gt;&lt;a href=&quot;#方法概述&quot; class=&quot;headerlink&quot; title=&quot;方法概述&quot;&gt;&lt;/a&gt;方法概述&lt;/h2&gt;&lt;p&gt;Java方法是语句的集合，它们在一起执行一个功能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方法是解决一类问题的步骤的有序组合&lt;/li&gt;
&lt;li&gt;方法包含于类或对象中&lt;/li&gt;
&lt;li&gt;方法在程序中被创建，在其他地方被引用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java数组</title>
    <link href="https://www.pengspace.top/2020/05/24/Java%E6%95%B0%E7%BB%84/"/>
    <id>https://www.pengspace.top/2020/05/24/Java%E6%95%B0%E7%BB%84/</id>
    <published>2020-05-24T10:59:37.000Z</published>
    <updated>2020-10-11T06:26:06.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组概述"><a href="#数组概述" class="headerlink" title="数组概述"></a>数组概述</h2><p><strong><code>数组的定义:</code></strong></p><ul><li>数组是<span style="color:red">相同类型数据</span>的有序集合。</li><li>数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。</li><li>其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。</li></ul><a id="more"></a><h3 id="数组的声明创建"><a href="#数组的声明创建" class="headerlink" title="数组的声明创建"></a>数组的声明创建</h3><p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar;<span class="comment">//首选的方法</span></span><br><span class="line">或</span><br><span class="line">dataType arrayRefVar[];<span class="comment">//效果相同，但不是首选方法，不推荐使用</span></span><br></pre></td></tr></table></figure><p>Java语言使用<code>new</code> 操作符来创建数组，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dataType[] arrayRefVar = <span class="keyword">new</span> dataType[arraySize];</span><br></pre></td></tr></table></figure><p>数组的元素是通过索引访问的，<span style="color:red">数组索引从<strong>0</strong>开始</span>。</p><p>获取数组长度：<code>arrays.length</code></p><p>声明时数组在内存中并不存在，只有在创建数组时，才会在内存中为数组分配指定的空间。</p><h3 id="Java内存分析"><a href="#Java内存分析" class="headerlink" title="Java内存分析"></a>Java内存分析</h3><p><img src="https://i.loli.net/2020/05/23/pEowZelcCNFGzQ3.png" alt="java内存"></p><p><code>数组在内存中的创建过程:</code></p><ol><li>在声明数组时会在栈中压入数组名</li><li>创建数组时会在堆中开辟指定的空间用来存放数组</li><li>给数组赋值，将值存放在堆中数组对应的空间里</li></ol><p><img src="https://i.loli.net/2020/05/23/QGIF8zbnEcasDvg.png" alt="数组在内存中的创建过程"></p><h3 id="数组的三种初始化"><a href="#数组的三种初始化" class="headerlink" title="数组的三种初始化"></a>数组的三种初始化</h3><ul><li><p><strong>静态初始化</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Man[] mans =&#123;<span class="keyword">new</span> Man(<span class="number">1</span>,<span class="number">1</span>),<span class="keyword">new</span> Man(<span class="number">2</span>,<span class="number">2</span>)&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>动态初始化</strong></p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];<span class="comment">//创建数组 默认初始化</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>数组的默认初始化</strong></p><p>  数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。</p></li></ul><h3 id="数组的四个基本特点"><a href="#数组的四个基本特点" class="headerlink" title="数组的四个基本特点"></a>数组的四个基本特点</h3><ul><li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的。</li><li>其元素必须是<span style="color:red">相同类型</span>，不允许出现混合类型。</li><li>数组中的元素可以是任何数据类型，包括基本类型和引用类型。</li><li>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<span style="color:red">数组对象本身是在堆中的</span>。</li></ul><h3 id="数组边界"><a href="#数组边界" class="headerlink" title="数组边界"></a>数组边界</h3><p>下标的合法区间：[0,length-1]，如果越界就会报错；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(a[<span class="number">2</span>]);<span class="comment">//报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">ArraylndexOutOfBoundsException：数组下标越界异常！</span></p><blockquote><p><strong><code>小结</code></strong></p><ul><li>数组是相同数据类型（数据类型可以为任意类型）的有序集合</li><li>数组也是对象。数组元素相当于对象的成员变量</li><li>数组长度的确定的，不可变的。如果越界，则报：ArraylndexOutofBounds</li></ul></blockquote><h2 id="数组的使用"><a href="#数组的使用" class="headerlink" title="数组的使用"></a>数组的使用</h2><p>数组一般可以配合循环来使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="comment">//打印全部的数组元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            System.out.println(arrays[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印所有元素的和</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; ++i) &#123;</span><br><span class="line">            sum += arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"sum="</span>+sum);</span><br><span class="line">        <span class="comment">//查找最大最小元素</span></span><br><span class="line">        <span class="keyword">int</span> max = array[<span class="number">0</span>];<span class="comment">//创建变量，存储遍历数组时发现的最大值，</span></span><br><span class="line">        <span class="comment">//初始值赋为数组中第一个元素而不赋为0，是为了避免数组中没有比0大的值，这样就会输出错误的值</span></span><br><span class="line">        <span class="keyword">int</span> min = array[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arrays.length; i++) &#123;</span><br><span class="line">            max = max &gt; arrays[i] ? max : arrays[i];</span><br><span class="line">            min = min &lt; arrays[i] ? min : arrays[i]</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"max="</span>+max+<span class="string">"\nmin="</span>+<span class="string">"min"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for-each循环-增强型for循环"><a href="#for-each循环-增强型for循环" class="headerlink" title="for-each循环(增强型for循环)"></a>for-each循环(增强型for循环)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> array : arrays)&#123;<span class="comment">//这种方式没有下标，适合打印输出</span></span><br><span class="line">            System.out.println(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组作方法入参和作返回值"><a href="#数组作方法入参和作返回值" class="headerlink" title="数组作方法入参和作返回值"></a>数组作方法入参和作返回值</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arraysReverse = reverse(arrays);</span><br><span class="line">        printArray(arraysReverse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打印数组元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arrays)</span></span>&#123; <span class="comment">//数组作为方法的传入参数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            System.out.print(arrays[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//反转数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] reverse(<span class="keyword">int</span>[] arrays)&#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arrays.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            result[result.length-i-<span class="number">1</span>] = arrays[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;<span class="comment">//数组作为返回值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组的常用算法"><a href="#数组的常用算法" class="headerlink" title="数组的常用算法"></a>数组的常用算法</h3><p>####冒泡排序</p><p><img src="https://i.loli.net/2020/05/24/QoRPrY2VfzcnhwE.gif" alt="冒泡排序"></p><p>如果遇到相等的值不进行交换，那这种排序方式是稳定的排序方式。</p><p>原理：比较两个相邻的元素，将值大的元素交换到右边</p><p>思路：依次比较相邻的两个数，将比较小的数放在前面，比较大的数放在后面。</p><p>算法分析：</p><p>N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次，所以可以用双重循环语句，外层控制循环多少趟，内层控制每一趟的循环次数</p><p>冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，同样也能找出一个最大的数排在参与第二趟比较的数后面，第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，以此类推……也就是说，没进行一趟比较，每一趟少比较一次，一定程度上减少了算法的量。</p><p>时间复杂度</p><p>1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：$C_{min}=n-1$；$M_{min}=0$;所以，冒泡排序最好的时间复杂度为O(n)。</p><p>2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p><p>$$C_{max} =\cfrac{n(n-1)}{2} = O(n^2)$$</p><p>$M_{max} =\cfrac{3n(n-1)}{2} = O(n^2)$</p><p>综上所述：冒泡排序总的平均时间复杂度为：$O(n^2)$ ,时间复杂度和数据状况无关。</p><blockquote><p>Java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array)&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//外层循环控制比较的轮次 : length-1轮</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">     <span class="comment">//内层循环控制每轮比较的次数</span></span><br><span class="line">     <span class="comment">//第i轮（i从0开始计算），比较次数为length-i-1</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length-<span class="number">1</span>-i; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (array[j+<span class="number">1</span>]&lt;array[j])&#123;</span><br><span class="line">             temp = array[j];</span><br><span class="line">             array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">             array[j+<span class="number">1</span>] = temp;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="二分查找（折半查找）"><a href="#二分查找（折半查找）" class="headerlink" title="二分查找（折半查找）"></a>二分查找（折半查找）</h4><p><strong>概述</strong></p><p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，二分查找要求数组数据必须采用顺序存储结构有序排列。</p><p>*<em>原理 *</em></p><p>首先，假设数组中元素是按升序排列，将数组中间位置的数据与查找数据比较，如果两者相等，则查找成功；否则利用中间位置记录将数组分成前、后两个子数组，如果中间位置数据大于查找数据，则进一步查找前子数组，否则进一步查 找后子数组。</p><p> 重复以上过程，直到找到满足条件的数据，则表示查找成功， 直到子数组不存在为止，表示查找不成功。</p><blockquote><p>Java代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二分查找（折半查找）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个有序数组</span></span><br><span class="line"><span class="keyword">int</span>[] nums = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>,<span class="number">80</span>,<span class="number">90</span>&#125;;</span><br><span class="line"><span class="comment">//要查找的数据</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">bubbleSort(nums,num);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"位置："</span>+centerIndex);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] array，<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.最小范围下标</span></span><br><span class="line"><span class="keyword">int</span> minIndex = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//2.最大范围下标</span></span><br><span class="line"><span class="keyword">int</span> maxIndex = array.length-<span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.中间数据下标</span></span><br><span class="line"><span class="keyword">int</span> centerIndex = (minIndex+maxIndex)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"循环了一次"</span>);</span><br><span class="line"><span class="keyword">if</span>(array[centerIndex]&gt;num) &#123;</span><br><span class="line"><span class="comment">//中间数据较大</span></span><br><span class="line">maxIndex = centerIndex-<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(array[centerIndex]&lt;num) &#123;</span><br><span class="line"><span class="comment">//中间数据较小</span></span><br><span class="line">minIndex = centerIndex+<span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//找到了数据  数据位置：centerIndex</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(minIndex &gt; maxIndex) &#123;</span><br><span class="line">centerIndex = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当边界发生变化， 需要更新中间下标</span></span><br><span class="line">centerIndex = (minIndex+maxIndex)/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> centerIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组可以看成是数组的数组，比如二维数组就是一个特殊的一维数组，其每一个元素都是一个一维数组。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">5</span>]<span class="comment">//二维数组a可以看成一个两行5列的数组</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/05/24/qOGaBP61eo5mVdU.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arrays= &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">//将数组遍历打印出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arrays.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arrays[i].length; j++)&#123;</span><br><span class="line">                System.out.print(arrays[i][j]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="Java的Arrays类"><a href="#Java的Arrays类" class="headerlink" title="Java的Arrays类"></a>Java的Arrays类</h2><p>数组的工具类<code>java.util.Arrays</code></p><p>由于数组对象本身并没有什么方法可以供我们调用，但API中提供了一个工具类Arrays供我们使用，从而可以对数据对象进行一些基本的操作。</p><p>Arrays类中的方法都是static修饰的静态方法，在使用的时候可以直接使用类名进行调用，而“不用”使用对象来调用（注意：是“不用”而不是“不能”）</p><p>Arrays类具有以下<strong>常用</strong>功能</p><ul><li>给数组赋值：通过fill方法。</li><li>对数组排序：通过 sort 方法，按升序。</li><li>比较数组：通过equals 方法比较数组中元素值是否相等。</li><li>查找数组元素：通过binarySearch 方法能对排序好的数组进行二分查找法操作。</li></ul><p>具体使用可参考<a href="https://www.matools.com/api/java8" target="_blank" rel="noopener">JDK文档</a></p><h2 id="稀疏数组"><a href="#稀疏数组" class="headerlink" title="稀疏数组"></a>稀疏数组</h2><p>当一个数组中大部分元素为0，或者为同一值的数组时，可以使用<strong>稀疏数组</strong>来保存该数组。</p><p>稀疏数组的处理方式是：</p><ul><li><p>记录数组一共有几行几列，有多少个不同值</p></li><li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中,从而缩小程序的规模</p></li></ul><blockquote><p>如下图：左边是原始数组，右边是稀疏数组</p><p><img src="https://i.loli.net/2020/05/24/4HsMGcvahmbUk72.png" alt=""></p><table><thead><tr><th align="center"></th><th align="center">行</th><th align="center">列</th><th align="center">值</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">[0]</td><td align="center">6</td><td align="center">7</td><td align="center">8</td><td align="center">表示这是一个6行7列的数组，有效值有 8 个</td></tr><tr><td align="center">[1]</td><td align="center">0</td><td align="center">3</td><td align="center">22</td><td align="center">第一个有效值位于第0行第3列，值为22</td></tr><tr><td align="center">[2]</td><td align="center">0</td><td align="center">6</td><td align="center">15</td><td align="center">第二个有效值位于第0行第6列，值为15</td></tr><tr><td align="center">[3]</td><td align="center">1</td><td align="center">1</td><td align="center">11</td><td align="center">第三个有效值位于第1行第1列，值为11</td></tr><tr><td align="center">[4]</td><td align="center">1</td><td align="center">5</td><td align="center">17</td><td align="center">第四个有效值位于第1行第5列，值为17</td></tr><tr><td align="center">[5]</td><td align="center">2</td><td align="center">3</td><td align="center">-6</td><td align="center">第五个有效值位于第2行第3列，值为-6</td></tr><tr><td align="center">[6]</td><td align="center">3</td><td align="center">5</td><td align="center">39</td><td align="center">第六个有效值位于第3行第5列，值为39</td></tr><tr><td align="center">[7]</td><td align="center">4</td><td align="center">0</td><td align="center">91</td><td align="center">第七个有效值位于第4行第0列，值为91</td></tr><tr><td align="center">[8]</td><td align="center">5</td><td align="center">2</td><td align="center">28</td><td align="center">第八个有效值位于第5行第2列，值为28</td></tr></tbody></table></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** 转为稀疏数组 ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] toSparseArray(<span class="keyword">int</span>[][] arr)&#123;</span><br><span class="line">    <span class="comment">//获取有效值的个数</span></span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建一个稀疏数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[sum+<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">0</span>] = arr.length;</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">1</span>] = arr[<span class="number">0</span>].length;</span><br><span class="line">    arr2[<span class="number">0</span>][<span class="number">2</span>] = sum;</span><br><span class="line">    <span class="comment">//遍历arr,将非零的值的信息，存放入稀疏数组中</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                arr2[count][<span class="number">0</span>] = i;</span><br><span class="line">                arr2[count][<span class="number">1</span>] = j;</span><br><span class="line">                arr2[count][<span class="number">2</span>] = arr[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** 稀疏数组转为普通数组 ****/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] sparseToArray(<span class="keyword">int</span>[][] arr)&#123;</span><br><span class="line">    <span class="comment">//读取稀疏数组,并新建一个数组</span></span><br><span class="line">    <span class="keyword">int</span>[][] arr2 = <span class="keyword">new</span> <span class="keyword">int</span>[arr[<span class="number">0</span>][<span class="number">0</span>]][arr[<span class="number">0</span>][<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//还原稀疏数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr2[arr[i][<span class="number">0</span>]][arr[i][<span class="number">1</span>]] = arr[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数组概述&quot;&gt;&lt;a href=&quot;#数组概述&quot; class=&quot;headerlink&quot; title=&quot;数组概述&quot;&gt;&lt;/a&gt;数组概述&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;数组的定义:&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数组是&lt;span style=&quot;color:red&quot;&gt;相同类型数据&lt;/span&gt;的有序集合。&lt;/li&gt;
&lt;li&gt;数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。&lt;/li&gt;
&lt;li&gt;其中，每一个数据称作一个数组元素，每个数组元素可以通过一个下标来访问它们。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java流程控制</title>
    <link href="https://www.pengspace.top/2020/05/19/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://www.pengspace.top/2020/05/19/Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</id>
    <published>2020-05-19T12:00:28.000Z</published>
    <updated>2020-05-19T12:04:55.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用户交互Scanner"><a href="#用户交互Scanner" class="headerlink" title="用户交互Scanner"></a>用户交互Scanner</h2><p>java.util.Scanner是Java5的新特征，我们可以通过Scanner 类来获取用户的输入。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">if</span> (s.hasNext)&#123;</span><br><span class="line">    type name = s.next()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.hasNextLine)&#123;</span><br><span class="line">    type name = s.nextLine()</span><br><span class="line">&#125;</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><p>通过 Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用 hasNext()与hasNextLine()判断是否还有输入的数据。</p><blockquote><p><span style="color:red">凡是属于IO流的类如果不关闭会一直占用资源，要习惯用完就关掉.</span></p></blockquote><p>下面来看一下<code>next()</code>方法和<code>nextLine()</code>方法的区别</p><p><code>next()</code>:</p><ul><li>一定要读取到有效字符后才可以结束输入。</li><li>对输入有效字符之前遇到的空白，next()方法会自动将其去掉。</li><li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li><li><span style="color:red">next()不能得到带有空格的字符串。</span></li></ul><p><code>nextLine()</code>:</p><ul><li>以Enter为结束符，也就是说nextLine()方法返回的是输入回车之前的所有字符。</li><li>可以获得空白。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;<span class="comment">//导入Scanner工具类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建扫描器Scanner对象，用于接收键盘数据</span></span><br><span class="line">        Scanner in1 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        Scanner in2 = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="comment">//in1和in2都输入“hello world”</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断用户有没有输入字符串</span></span><br><span class="line">        <span class="keyword">if</span>(in1.hasNext())&#123;</span><br><span class="line">            <span class="comment">//使用next()方法接收</span></span><br><span class="line">            String str1 = in1.next();</span><br><span class="line">            System.out.println(<span class="string">"用next()方法接收的输出："</span> + str1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(in2.hasNextLine())&#123;</span><br><span class="line">            <span class="comment">//使用nextLine()方法接收</span></span><br><span class="line">            String str2 = in2.nextLine();</span><br><span class="line">            System.out.println(<span class="string">"用nextLine()方法接收的输出："</span> + str2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//凡是属于IO流的类如果不关闭会一直占用资源，要习惯用完就关掉</span></span><br><span class="line">        in1.close();</span><br><span class="line">        in2.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码运行结果如图所示：</p><img src="https://i.loli.net/2020/05/17/Bxt5UXKyWm1co3v.png" style="zoom:80%;" /><p>scanner工具中，还有hasNextInt()、hasNextFloat()等方法验证输入的类型，nextInt()、nextFloat()接收相关类型的输入。</p><blockquote><p>拓展说明：</p><p><code>print()</code>和<code>println()</code>的区别：</p><p><code>println()</code>:输出完会换行</p><p><code>print()</code>:输出完不会换行，内容都输出在一行</p></blockquote><h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><p>JAVA的基本结构就是顺序结构，除非特别指明，否则就按照顺序一句一句执行。</p><p>顺序结构是最简单的算法结构。</p><img src="https://i.loli.net/2020/05/17/z5DBQHsrjbfiJMC.png" style="zoom: 50%;" /><p>语句与语句之间，框与框之间是按从上到下的顺序进行的，它是由若干个依次执行的处理步骤组成的，<span style="color:red">它是任何一个算法都离不开的一种基本算法结构。</span></p><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><h3 id="if选择结构"><a href="#if选择结构" class="headerlink" title="if选择结构"></a><code>if</code>选择结构</h3><h4 id="if单选择结构"><a href="#if单选择结构" class="headerlink" title="if单选择结构"></a><code>if</code>单选择结构</h4><p>我们很多时候需要去判断一个东西是否可行，然后我们才去执行，这样一个过程在程序中用<code>if</code>语句来表示。</p><img src="https://i.loli.net/2020/05/19/QfS8e5un3JXVdyk.png" style="zoom: 50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="if双选择结构"><a href="#if双选择结构" class="headerlink" title="if双选择结构"></a><code>if</code>双选择结构</h4><p>那现在有个需求，公司要收购一个软件，成功了，给人支付100万元，失败了，自己找人开发。这样的需求用一个<code>if</code>就搞不定了，我们需要有两个判断，需要一个双选择结构，所以就有了<code>if-else</code>结构。</p><img src="https://i.loli.net/2020/05/19/Ws7XgdF2jonTQfB.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式为false将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####<code>if</code>多选择结构</p><p>我们发现不管是单选择结构，还是双选择结构都不符合实际情况，真实的情况还可能存在ABCD，存在区间多级判断。比如90-100就是A，80-90就是B..等等，在生活中我们很多时候的选择也不仅仅只有两个，所以我们需要一个多选择结构来处理这类问题！</p><img src="https://i.loli.net/2020/05/19/2NQ6qmIyFrUYE8i.png" style="zoom: 67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式2为true将执行的语句</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果以上条件都不满足将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>####嵌套的<code>if</code>结构 </p><p>使用嵌套的<code>if...else</code> 语句是合法的。也就是说你可以在另一个<code>if</code>或者<code>else if</code>语句中使用<code>if</code>或者<code>else if</code> 语句。你可以像<code>if</code>语句一样嵌套 <code>else if...else</code>。</p><p><strong>嵌套 if 语句</strong>，只有当外层 if 的条件成立时，才会判断内层 if 的条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(布尔表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为true</span></span><br><span class="line">    <span class="keyword">if</span>(布尔表达式<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">//如果布尔表达式2为true将执行的语句</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果布尔表达式2为false将执行的语句</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//如果布尔表达式1为false 将执行的语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="swich多选择结构"><a href="#swich多选择结构" class="headerlink" title="swich多选择结构"></a><code>swich</code>多选择结构</h3><p>多选择结构还有一个实现方式就是<code>switch case</code> 语句。</p><p><code>switch case</code> 语句判断一个变量与一系列值中某个值是否相等，每个值称为一个分支。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//可以有任意数量的case语句</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch 语句中的变量类型可以是：</p><ul><li>byte、short、int 或者char。</li><li>从Java SE7开始，<code>switch</code> 支持字符串 String 类型了，同时 <code>case</code>标签必须为字符串常量或字面量。</li></ul><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a><code>while</code>循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    <span class="comment">//循环内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>只要布尔表达式为true，循环就会一直执行下去。</li><li><span style="color : red">大多数情况是需要让循环停下来的，我们可以以让表达式失效的方式来结束循环。</span></li><li>少部分情况需要循环一直执行，比如服务器的请求响应监听等。</li><li>循环条件一直为true就会造成无限循环(死循环)，我们正常的业务编程中应该尽量避免死循环。会影响程序性能或者造成程序卡死奔溃！</li></ul><h3 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do...while循环"></a><code>do...while</code>循环</h3><p>对于while 语句而言，如果不满足条件，则不能进入循环。但有时候我们需要即使不满足条件，也至少执行一次。</p><p><code>do...while</code>循环和<code>while</code> 循环相似，不同的是，<code>do...while</code>循环至少会执行一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式);</span><br></pre></td></tr></table></figure><p>While和do-While的区别：</p><ul><li><p><code>while</code>先判断后执行。<code>do…while</code>是先执行后判断！</p></li><li><p><code>do...while</code>总是保证循环体会被至少执行一次！这是他们的主要差别。</p></li></ul><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a><code>for</code>循环</h3><p>虽然所有循环结构都可以用 while或者do..while表示，但Java 提供了另一种语句-<code>for</code>循环，使一些循环结构变得更加简单。</p><p><span style="color:red">for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构。</span></p><p>for循环执行的次数是在执行前就确定的。语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化;布尔表达式;迭代)&#123;</span><br><span class="line">    <span class="comment">//代码语句</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关于for循环的几点说明：</p><ol><li><p>最先执行初始化步骤。可以声明一种类型，可初始化一个或多个循环控制变量，也可以是空语句。</p></li><li><p>然后，检测布尔表达式的值。如果为true，循环体被执行。如果为false，循环终止，开始执行循环体后面的语句。</p></li><li><p>执行一次循环后，更新循环控制变量（送代因子控制循环变量的增减）。</p></li><li><p>再次检测布尔表达式。循环执行上面的过程。</p></li></ol></blockquote><h4 id="增强型for循环"><a href="#增强型for循环" class="headerlink" title="增强型for循环"></a>增强型<code>for</code>循环</h4><p>在java5中引入了一种主要用于数组或集合的增强型for循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)&#123;</span><br><span class="line">    <span class="comment">//代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>声明语句</strong>：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</p></li><li><p><strong>表达式</strong>：表达式是要访问的数组名，或者是返回值为数组的方法。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ary = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>&#125;;   <span class="comment">//定义一个数组</span></span><br><span class="line">        <span class="comment">//遍历数组中的元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x : ary)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>在任何循环语句的主体部分，均可用break控制循环的流程。break用于<span style="color:red">强行退出循环，不执行循环中剩余的语句。</span>(break语句也在switch语句中使用)</p><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>continue 语句用在循环语句体中，用于<span style="color:red">终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。</span></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;用户交互Scanner&quot;&gt;&lt;a href=&quot;#用户交互Scanner&quot; class=&quot;headerlink&quot; title=&quot;用户交互Scanner&quot;&gt;&lt;/a&gt;用户交互Scanner&lt;/h2&gt;&lt;p&gt;java.util.Scanner是Java5的新特征，我们可以通过Scanner 类来获取用户的输入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java语法基础</title>
    <link href="https://www.pengspace.top/2020/05/16/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.pengspace.top/2020/05/16/Java%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2020-05-16T11:39:06.000Z</published>
    <updated>2020-05-16T11:43:07.418Z</updated>
    
    <content type="html"><![CDATA[<h2 id="注释、标识符，关键字"><a href="#注释、标识符，关键字" class="headerlink" title="注释、标识符，关键字"></a>注释、标识符，关键字</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><a id="more"></a><p>平时我们编写代码，在代码量比较少的时候，我们还可以看懂自己写的，但是当项目结构一旦复杂起来，我们就需要用到注释了。</p><p>注释并不会被执行，是给写代码的人看的。</p><p><span style = color:red>写注释是一个很好的习惯</span></p><p><span style = color:red>写代码要注意规范</span></p><p>Java的注释有三种：单行注释；多行注释；文档注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment"> 多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//JavaDoc:文档注释/** */</span></span><br><span class="line"><span class="comment">//javadoc命令是用来生成自己API文档的</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  作者名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 版本号</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 指明需要最早使用的jdk版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> 参数名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回值情况</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> 异常抛出情况</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>JavaDoc ，可通过终端命令生成Api文档</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javadoc -encoding UTF-8 -charset UTF-8 *.java</span><br></pre></td></tr></table></figure><p>也可以通过Intellij IDEA生成，在工具栏中找到 <u>T</u>ools——&gt;Generate Java<u>D</u>oc…</p><p><img src="https://i.loli.net/2020/05/15/5FeQRjBkPAirSKs.png" alt=""></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://i.loli.net/2020/05/11/EjmKrwpXdu632gI.png" alt="Java关键字"></p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p><span style = color:red>Java所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</span></p><p><code>标识符注意点：</code></p><ul><li>所有的标识符都应该以字母（A-z或者a-z），美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z或者a-z），美元符（$）、下划线（_）或数字的任何字符组合。</li><li><span style = color:red>不能使用关键字作为变量名或方法名。</span></li><li>标识符是<span style = color:red>大小写敏感</span>的</li><li><span style = color:red>可以使用中文命名，但是一般不建议这样去使用，也不建议使用拼音，很Low，不规范</span></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合法标识符举例：age、$salary、value、_1_value</span></span><br><span class="line"><span class="comment">//非法标识符举例：123abc、-salary、#abc</span></span><br><span class="line"><span class="comment">//中文命名举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（string[]args）&#123;</span><br><span class="line">string 王者荣耀=<span class="string">"最强王者"</span>;</span><br><span class="line">    System.out.println(王者荣耀);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>Java是强类型语言，要求变量的使用要严格符合规定，所有变量都必须先定义后才能使用。</p><p><img src="https://i.loli.net/2020/05/11/NucZLt9mwnkRMyA.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八大基本数据类型</span></span><br><span class="line"><span class="comment">//整数</span></span><br><span class="line"><span class="keyword">int</span> num1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">byte</span> num2 = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> num3 = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">long</span> num3 = <span class="number">30L</span>;<span class="comment">//long类型要在数字后加个 L</span></span><br><span class="line"><span class="comment">//小数：浮点数</span></span><br><span class="line"><span class="keyword">float</span> num5 = <span class="number">50.1F</span>;<span class="comment">//float类型要在数字后加个 F</span></span><br><span class="line"><span class="keyword">double</span> num6 = <span class="number">3.1415926535</span>;</span><br><span class="line"><span class="comment">//字符型</span></span><br><span class="line"><span class="keyword">char</span> name1 = <span class="string">'A'</span>;<span class="comment">//引号内只能有一个字符</span></span><br><span class="line"><span class="comment">//布尔值:只有是(true)、非(false) 两个值</span></span><br><span class="line"><span class="keyword">boolean</span> flag1 = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag2 = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><blockquote><p>位（bit）：是计算机内部数据储存的最小单位，11001100是一个八位二进制数。</p><p>字节（byte）：是计算机中数据处理的基本单位，习惯上用大写B来表示，1B（byte，字节）=8bit（位）</p><p>字符：是指计算机中使用的字母、数字、字和符号</p><p>1bit表示1位，1Byte表示一个字节1B=8b。1024B=1KB，1024KB=1MB，1024MB=1GB…</p></blockquote><h3 id="数据类型拓展"><a href="#数据类型拓展" class="headerlink" title="数据类型拓展"></a>数据类型拓展</h3><h4 id="整数拓展"><a href="#整数拓展" class="headerlink" title="整数拓展"></a>整数拓展</h4><p>进制问题：</p><p>二进制 0b；十进制；八进制 0；十六进制 0x</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0b10</span>;<span class="comment">//二进制输出2</span></span><br><span class="line"><span class="keyword">int</span> i1 = <span class="number">10</span>;<span class="comment">//十进制输出10</span></span><br><span class="line"><span class="keyword">int</span> i2 = <span class="number">010</span>;<span class="comment">//八进制输出8</span></span><br><span class="line"><span class="keyword">int</span> i3 = <span class="number">0x10</span>;<span class="comment">//十六进制输出16</span></span><br></pre></td></tr></table></figure><h4 id="浮点数拓展"><a href="#浮点数拓展" class="headerlink" title="浮点数拓展"></a>浮点数拓展</h4><p>float和double类型，表现的长度是有限的，同时它也是离散的，它存在<code>舍入误差</code>的问题，他的结果是一个大约数，接近但不等于。</p><p><span style = color:red>尽量不要使用浮点数进行比较，尤其是在做涉及钱的业务时。</span></p><p>看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;<span class="comment">//0.1</span></span><br><span class="line"><span class="keyword">double</span> d = <span class="number">1.0</span>/<span class="number">10</span>;<span class="comment">//0.1</span></span><br><span class="line">System.out.println(f==d);<span class="comment">//结果为false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">float</span> d1 = <span class="number">2132154645646f</span>;</span><br><span class="line"><span class="keyword">float</span> d2 = d1 + <span class="number">1</span>;</span><br><span class="line">System.out.println(d1==d2);<span class="comment">//结果为true</span></span><br></pre></td></tr></table></figure><p>我们可以看出，浮点数是存在误差的。</p><p>Java中，我们可以用<code>BigDecimal</code>这个数学工具类来执行上述的操作。</p><h4 id="字符拓展"><a href="#字符拓展" class="headerlink" title="字符拓展"></a>字符拓展</h4><p>所有字符本质还是数字</p><p>编码： Unicode码   u0000-uFFFF —&gt;<code>UTF-8</code>，UTF-16，UTF-32</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符强制转换</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">'中'</span>;</span><br><span class="line">System.out.println(c1);<span class="comment">//输出 a</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c1); <span class="comment">//强制转换 输出 97</span></span><br><span class="line">System.out.println(c2);<span class="comment">//输出 中</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c2); <span class="comment">//输出 20013</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">'\u0061'</span>;<span class="comment">//十六进制</span></span><br><span class="line">System.out.println(c3);<span class="comment">//输出 a</span></span><br></pre></td></tr></table></figure><p>转义字符</p><table><thead><tr><th align="center">转义字符</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\t</td><td align="center">水平制表符</td></tr><tr><td align="center">\r</td><td align="center">回车，将当前位置移到本行开头</td></tr><tr><td align="center">\b</td><td align="center">退格，将当前位置移到前一列</td></tr><tr><td align="center">\f</td><td align="center">换页，将当前位置移到下页开头</td></tr><tr><td align="center">\\</td><td align="center">代表一个反斜线字符’’\‘</td></tr><tr><td align="center">\‘</td><td align="center">代表一个单引号（撇号）字符</td></tr><tr><td align="center">\“</td><td align="center">代表一个双引号字符</td></tr><tr><td align="center">\0</td><td align="center">空字符(NULL)</td></tr><tr><td align="center">\ddd</td><td align="center">1到3位八进制数所代表的任意字符 \000 ~ \377</td></tr><tr><td align="center">\uxxxx</td><td align="center">Unicode转义字符，\u + 四个十六进制数字所代表的字符 \u0000 ~ \uFFFF</td></tr></tbody></table><h4 id="布尔值拓展"><a href="#布尔值拓展" class="headerlink" title="布尔值拓展"></a>布尔值拓展</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//下面的方式是同样的效果，都表示当flag为真时，做什么</span></span><br><span class="line"><span class="keyword">if</span> (flag == <span class="keyword">true</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (flag)&#123;&#125;</span><br></pre></td></tr></table></figure><p><span style = color:red>Less is More,代码要精简易读</span></p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>由于Java是强类型语言，所以要进行有些运算的时候，需要用到类型转换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">低---------------------------------------&gt;高</span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br><span class="line">    <span class="comment">//浮点数优先级一定大于整数</span></span><br></pre></td></tr></table></figure><p>运算中，不同类型的数据先转换为同一类型，然后进行运算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">int</span> i = <span class="number">128</span>;</span><br><span class="line"><span class="comment">//强制类型转换  (类型)变量名高--&gt;低</span></span><br><span class="line"><span class="keyword">byte</span> b =(<span class="keyword">byte</span>)i;    <span class="comment">//byte类型范围为-128-127，转换后内存溢出</span></span><br><span class="line"><span class="comment">//自动类型转换  低--&gt;高</span></span><br><span class="line"><span class="keyword">double</span> d = i;</span><br><span class="line">System.out.println(i);<span class="comment">//输出 128</span></span><br><span class="line">System.out.println(b);<span class="comment">//输出 -128</span></span><br><span class="line">System.out.println(d);<span class="comment">//输出 128.0</span></span><br><span class="line"></span><br><span class="line">System.out.println((<span class="keyword">int</span>)<span class="number">23.7</span>);  <span class="comment">//输出23</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)-<span class="number">45.54f</span>);  <span class="comment">//输出 -45</span></span><br></pre></td></tr></table></figure><p><span style ="color:red"><b>注意:</b></span></p><ul><li>在类型转换时，要注意<span style="color:red">数据类型的取值范围，避免内存溢出</span>。</li><li>不能对布尔值进行转换</li><li>不能把对象类型转换为不相干的类型</li><li>转换时还可能存在精度问题，比如将浮点数转换为int类型，会舍去小数部分。</li></ul><p><strong>操作比较大的数的时候，注意溢出问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7以后，数字之间可以用下划线分割，下划线并不会被打印出来</span></span><br><span class="line"><span class="keyword">int</span> money = <span class="number">10_0000_0000</span>;</span><br><span class="line"><span class="keyword">int</span> year = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">int</span> total = money * year;  <span class="comment">//输出total的值为-1474836480。因为结果超出了int的范围，溢出</span></span><br><span class="line"><span class="keyword">long</span> total2 = money * year; </span><br><span class="line"><span class="comment">//输出total2的值为-1474836480。因为运算顺序是先计算等式右边的，再把结果转换为long类型赋值给total2，但转换之前的结果已经出问题了。</span></span><br><span class="line"><span class="keyword">long</span> total3 = money*((<span class="keyword">long</span>)year); </span><br><span class="line"><span class="comment">//这次total3的结果是正确的 先把一个数转换为long，这样等式右边计算时就是以long类型在计算，就不会发生溢出了</span></span><br></pre></td></tr></table></figure><h2 id="变量、常量、作用域"><a href="#变量、常量、作用域" class="headerlink" title="变量、常量、作用域"></a>变量、常量、作用域</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量就是可以变化的量！</p><p>Java是一种强类型语言，每个变量都必须声明其类型。</p><p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和<span style ="color:red">作用域</span>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type varNam [= value][&#123;,varName[= value],...&#125;];</span><br><span class="line"><span class="comment">//数据类型 变量名 = 值； 可以使用逗号隔开来声明多个同类型变量(不建议)。</span></span><br></pre></td></tr></table></figure><p><span style ="color:red"><strong>注意:</strong></span></p><ul><li><p>每个变量都有类型，类型可以是基本类型，也可以是引用类型。</p></li><li><p>变量名必须是合法的标识符。</p></li><li><p>变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</p></li></ul><h4 id="类变量、实例变量、局部变量"><a href="#类变量、实例变量、局部变量" class="headerlink" title="类变量、实例变量、局部变量"></a>类变量、实例变量、局部变量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Variable</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> allClicks = <span class="number">0</span>;  <span class="comment">//类变量</span></span><br><span class="line">    String str = <span class="string">"hello world"</span>;  <span class="comment">//实例变量 从属于对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">//局部变量，必须声明和初始化值，作用域仅限这个方法之内</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类变量：从属于类，作用域是在这个类内，随类一起出现，一起消失。</p><p>实例变量：从属于对象；如果不进行初始化,数值类型默认值为 0 | 0.0，char类型默认为一个空格，布尔类型默认值为false；除了基本类型，其余的默认都为 null。</p><p>局部变量，必须声明和初始化值，作用域仅限方法之内。</p><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量(constant)：<span style="color:red">初识化(initialize)后不能再改变值！</span>不会变动的值。</p><p>所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</p><p>常量名一般使用大写字符表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> 常量名 = 值;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure><blockquote><p>说明：修饰符，不存在先后顺序， <code>final static double PI = 3.14</code>和<code>static final double PI = 3.14</code>是一样的。</p></blockquote><h3 id="变量的命名规范"><a href="#变量的命名规范" class="headerlink" title="变量的命名规范"></a>变量的命名规范</h3><ul><li>所有变量、方法、类名：<span style="color:red"><strong>见名知意</strong></span></li><li>类成员变量：首字母小写和驼峰原则：monthSalary</li><li>局部变量：首字母小写和驼峰原则</li><li>常量：大写字母和下划线：MAX_VALUE</li><li>类名：首字母大写和驼峰原则：Man，GoodMan</li><li>方法名：首字母小写和驼峰原则：run()，runRun()</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>Java语言支持如下运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">算术运算符: +,-,*,/,%,++,--</span><br><span class="line">赋值运算符: =</span><br><span class="line">关系运算符: &gt;,&lt;,&gt;=,&lt;=,==,!=,<span class="keyword">instanceof</span></span><br><span class="line">逻辑运算符: &amp;&amp;,||,!</span><br><span class="line">位运算符:   &amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;</span><br><span class="line">条件运算符: ? :</span><br><span class="line">扩展赋值运算符：+=,-=,*=,/=</span><br></pre></td></tr></table></figure><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><h4 id="基本运算符"><a href="#基本运算符" class="headerlink" title="基本运算符"></a>基本运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+(加),-(减),*(乘),/(除),%(模，取余)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低---------------------------------------&gt;高</span><br><span class="line"><span class="keyword">byte</span>,<span class="keyword">short</span>,<span class="keyword">char</span>-&gt;<span class="keyword">int</span>-&gt;<span class="keyword">long</span>-&gt;<span class="keyword">float</span>-&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure><p>不同类型相互运算时，结果的类型总是与要计算的数中优先级最高的那个数的类型保持一致，但最低为int，即当只有short、byte、char相互运算时，结果仍为int类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> a = <span class="number">123.123</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">123.123F</span>;</span><br><span class="line">        <span class="keyword">long</span> c = <span class="number">123123123123123L</span>;</span><br><span class="line">        <span class="keyword">int</span> d = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">short</span> e = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">byte</span> f =<span class="number">8</span>;</span><br><span class="line">        <span class="keyword">char</span> g = <span class="string">'a'</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(getType(a+b+c+d+e+f+g)); <span class="comment">//double类型</span></span><br><span class="line">        System.out.println(getType(b+c+d+e+f+g));   <span class="comment">//float类型</span></span><br><span class="line">        System.out.println(getType(c+d+e+f+g));     <span class="comment">//long类型</span></span><br><span class="line">        System.out.println(getType(d+e+f+g));       <span class="comment">//int</span></span><br><span class="line">        System.out.println(getType(e+f+g));         <span class="comment">//int</span></span><br><span class="line">        System.out.println(getType(f+g));           <span class="comment">//int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取变量类型的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Object o)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> o.getClass().toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ++  --   自增，自减   一元运算符</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> b = a++;<span class="comment">//后置自增,执行这行代码时,先将a的值赋给b,a再自增</span></span><br><span class="line">System.out.println(a);  <span class="comment">// 4</span></span><br><span class="line"><span class="keyword">int</span> c = ++a;<span class="comment">//前置自增,执行这行代码时,先将a自增,再将自增后的结果赋给c</span></span><br><span class="line">System.out.println(a);  <span class="comment">//5</span></span><br><span class="line">System.out.println(b);  <span class="comment">//3</span></span><br><span class="line">System.out.println(c);  <span class="comment">//5</span></span><br></pre></td></tr></table></figure><h3 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h3><p>关系运算符计算后返回的结果是<code>布尔值</code>，常与<code>if</code>判断语句结合使用。</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&amp;&amp;(与),||(或),!(非)</span></span><br><span class="line"><span class="comment">//逻辑与运算：两个变量都为真，结果才为true</span></span><br><span class="line"><span class="comment">//逻辑或运算：两个变量有一个为真，则结果才为true</span></span><br><span class="line"><span class="comment">//非：如果是真则变为假，如果是假则变为真</span></span><br><span class="line"><span class="keyword">boolean</span> a = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">boolean</span> b = <span class="keyword">false</span>;</span><br><span class="line">System.out.println(a&amp;&amp;b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a||b);<span class="comment">//true</span></span><br><span class="line">System.out.println(!(a&amp;&amp;b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//短路运算</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">boolean</span> d = (c &lt; <span class="number">4</span>)&amp;&amp;(c++ &lt; <span class="number">4</span>); <span class="comment">//如果&amp;&amp;前面的为false，则后面的不会被运算</span></span><br><span class="line">System.out.println(c);  <span class="comment">//5，说明c++没有被运算</span></span><br><span class="line">System.out.println(d);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">A和B都是二进制数</span><br><span class="line">A = <span class="number">0011</span> <span class="number">1100</span></span><br><span class="line">B = <span class="number">0000</span> <span class="number">1101</span></span><br><span class="line"></span><br><span class="line">A&amp;B = <span class="number">0000</span> <span class="number">1100</span>按位与：都为<span class="number">1</span>时为<span class="number">1</span>，其他情况为<span class="number">0</span></span><br><span class="line">A|B = <span class="number">0011</span> <span class="number">1101</span>按位或：都为<span class="number">0</span>时为<span class="number">0</span>，其他情况为<span class="number">1</span></span><br><span class="line">A^B = <span class="number">0011</span> <span class="number">0001</span>按位异或：相同为<span class="number">0</span>，不同为<span class="number">1</span></span><br><span class="line">~B = <span class="number">1111</span> <span class="number">0010</span>按位取反</span><br><span class="line">_________________________________________________</span><br><span class="line"></span><br><span class="line">&lt;&lt;：左移，每移一位相当于乘以<span class="number">2</span></span><br><span class="line">&gt;&gt;：右移，每移一位相当于除以<span class="number">2</span></span><br><span class="line">如 <span class="number">2</span>&lt;&lt;<span class="number">3</span> = <span class="number">16</span></span><br></pre></td></tr></table></figure><p>位运算由于是操作二进制数，所以效率极高。</p><h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>看下面例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a += b;<span class="comment">//就相当于 a=a+b</span></span><br><span class="line">a -= b;<span class="comment">//就相当于 a=a-b</span></span><br><span class="line"><span class="comment">// 同样*=、/=也是这样的</span></span><br></pre></td></tr></table></figure><h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">条件运算符是三元运算符</span><br><span class="line">x ? y : z</span><br><span class="line">如果x为真，则结果为有，否则结果为z</span><br></pre></td></tr></table></figure><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>()、[]、{}</td><td>从左向右</td></tr><tr><td>2</td><td>!、+、-、~、++、–</td><td>从右向左</td></tr><tr><td>3</td><td>*、/、%</td><td>从左向右</td></tr><tr><td>4</td><td>+、-</td><td>从左向右</td></tr><tr><td>5</td><td>&lt;&lt;、&gt;&gt;、&gt;&gt;&gt;</td><td>从左向右</td></tr><tr><td>6</td><td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td><td>从左向右</td></tr><tr><td>7</td><td>==、!=</td><td>从左向右</td></tr><tr><td>8</td><td>&amp;</td><td>从左向右</td></tr><tr><td>9</td><td>^</td><td>从左向右</td></tr><tr><td>10</td><td>|</td><td>从左向右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左向右</td></tr><tr><td>12</td><td>||</td><td>从左向右</td></tr><tr><td>13</td><td>? :</td><td>从右向左</td></tr><tr><td>14</td><td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、&lt;&lt;=、&gt;&gt;=、&gt;&gt;&gt;=</td><td>从右向左</td></tr></tbody></table><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><ol><li><p>字符串连接符    +</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">System.out.println(<span class="string">"引号在前面"</span>+a+b);<span class="comment">// 输出 引号在前面1020</span></span><br><span class="line">System.out.println(a+b+<span class="string">"引号在后面"</span>);<span class="comment">// 输出 30引号在后面</span></span><br></pre></td></tr></table></figure></li></ol><p>可见，如果字符串在前面，则它后面连接的内容不会进行运算，如果字符串在后面，则它前面连接的内容会进行运算。</p><ol start="2"><li><p>很多运算，我们需要一些工具类来操作！如下代码用<code>Math</code>类进行幂运算。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> power = Math.pow(<span class="number">2</span>,<span class="number">3</span>); <span class="comment">//2的3次方，8.0</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="包机制"><a href="#包机制" class="headerlink" title="包机制"></a>包机制</h2><p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p><p>包语句的语法格式为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pkg1[. pkg2[. pkg3...]];</span><br></pre></td></tr></table></figure><p><span style="color:red">一般利用公司域名倒置作为包名</span></p><p>为了能够使用某一个包的成员，我们需要在Java 程序中明确导入该包。使用<code>import</code>语句可完成此功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> package1[.package2...].(classname|*);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;注释、标识符，关键字&quot;&gt;&lt;a href=&quot;#注释、标识符，关键字&quot; class=&quot;headerlink&quot; title=&quot;注释、标识符，关键字&quot;&gt;&lt;/a&gt;注释、标识符，关键字&lt;/h2&gt;&lt;h3 id=&quot;注释&quot;&gt;&lt;a href=&quot;#注释&quot; class=&quot;headerlink&quot; title=&quot;注释&quot;&gt;&lt;/a&gt;注释&lt;/h3&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>初识Java</title>
    <link href="https://www.pengspace.top/2020/05/16/%E5%88%9D%E8%AF%86Java/"/>
    <id>https://www.pengspace.top/2020/05/16/%E5%88%9D%E8%AF%86Java/</id>
    <published>2020-05-16T11:28:35.000Z</published>
    <updated>2020-05-19T03:15:59.183Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java帝国的建立"><a href="#java帝国的建立" class="headerlink" title="java帝国的建立"></a>java帝国的建立</h2><p>1972 年C语言诞生 ，C语言具有贴近硬件，运行速度极快，效率极高的优点，一经诞生，就广泛用于操作系统、编译器、数据库、网络系统等的开发。但由于C语言的指针问题和内存管理的问题，对新手有一些不太友好。</p><a id="more"></a><p>1982年C++诞生，C++兼容C语言，它增加了面向对象的特性，在图形领域和游戏方面取得了一些成就。但C++更加复杂。</p><p>1995年，java诞生，它语法有些像C，但没有C中的指针和内存管理问题；它实现了真正的可移植性，编写一次，到处运行；它也有面向对象的特性，有更安全的类型，有高质量的类库等优点。</p><h3 id="java的发展"><a href="#java的发展" class="headerlink" title="java的发展"></a>java的发展</h3><p>1995年的网页简单而粗糙，缺乏互动性。java团队在浏览器中放入了java的运行环境，开发了一个图形界面程序(Applet)，使得网页变得更美观，有互动性。java进入了广大程序员的视线。</p><p>1998年，java 发布java2版本，该版本包含三个方向：</p><p>Java 2 标准版（J2SE）    针对桌面端开发</p><p>Java 2 移动版（J2ME）    针对移动端开发</p><p>Java 2 企业版（J2EE）     针对服务器端开发</p><p> 但是Java SE 和Java ME当时并没有得到很好的发展。反而Java EE得到了很多IT大公司的应用 ，他们基于Java开发了许多的平台、系统、工具：</p><ul><li>构建工具：Ant，Maven，Jekins</li><li>应用服务器：Tomcat，Jetty，Jboss，Websphere，weblogic</li><li>Web开发：Struts，Spring，Hibernate，myBatis</li><li>开发工具：Eclipse，Netbean，intellij idea，Jbuilder</li><li>……</li></ul><p>2006年，Hadoop的发布让Java进入大数据领域</p><p>2008年，Android的诞生，让Java重新进入了移动端领域，并在移动端开发中占据了举足轻重的地位。</p><p>之后，Java的发展就一发不可收拾，占据了服务器端开发的大部分市场，一个伟大的帝国诞生了！！</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">拓展：</span><br><span class="line">“三高”问题：高可用，高性能，高并发。</span><br></pre></td></tr></table></figure><h2 id="Java的特性和优势"><a href="#Java的特性和优势" class="headerlink" title="Java的特性和优势"></a>Java的特性和优势</h2><ul><li>简单性</li><li>面向对象</li><li>跨平台 可移植性</li><li>高性能</li><li>分布式</li><li>动态性（反射机制）</li><li>多线程</li><li>安全性</li><li>健壮性</li></ul><h2 id="Java-的三大版本"><a href="#Java-的三大版本" class="headerlink" title="Java 的三大版本"></a>Java 的三大版本</h2><h3 id="JavaSE"><a href="#JavaSE" class="headerlink" title="JavaSE"></a>JavaSE</h3><p>标准版（桌面程序，控制台开发…）</p><h3 id="JavaME"><a href="#JavaME" class="headerlink" title="JavaME"></a>JavaME</h3><p>嵌入式开发（手机，小家电…）</p><p>该版本几乎已经没有人用了</p><h3 id="JavaEE"><a href="#JavaEE" class="headerlink" title="JavaEE"></a>JavaEE</h3><p>企业级开发（web端，服务器开发…）</p><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><p>JDK：Java Development Kit，称为Java开发包或者Java开发者工具，是一个编写Java的Applet小程序和应用程序的开发环境。JDK是整个Java的核心，包括了<code>Java运行环境(JRE)</code>，一些<code>Java工具</code>和<code>Java的核心类库(Java API)</code>。</p><p>JRE：Java Runtime Environment。JRE是个运行环境，JDK是个开发环境。因此写Java程序时需要JDK，而运行Java程序时就需要JRE。而JDK中已经包含了JRE，因此只要安装了JDK就可以编辑Java程序，也可以正常运行Java程序。</p><p>JVM：Java Virtual Machine</p><p><img src="https://i.loli.net/2020/05/09/h5MHDELCjmzKvcY.png" alt=""></p><h2 id="JDK的安装"><a href="#JDK的安装" class="headerlink" title="JDK的安装"></a>JDK的安装</h2><p><a href="https://www.oracle.com/java/technologies/javase-jdk8-downloads.html" target="_blank" rel="noopener">https://www.oracle.com/java/technologies/javase-jdk8-downloads.html</a></p><p>去上面网址下载对应的版本</p><p>下载后双击安装，记住安装的路径</p><p><strong>配置环境变量</strong></p><p>右键点击此电脑，打开属性，找到高级系统设置-&gt;环境变量-&gt;系统变量</p><ol><li>新建一个变量JAVA_HOME，值为jdk安装的路径</li></ol><p><img src="https://i.loli.net/2020/05/09/dF2PvYc5eJ8H9nD.png" alt=""></p><ol start="2"><li>配置Path变量，找到系统变量中的Path变量，点击编辑，新建两个，值分别为<code>%JAVA_HOME%\bin</code>，<code>%JAVA_HOME%\jre\bin</code></li></ol><p><img src="https://i.loli.net/2020/05/09/uaRCMe71En3XG9V.png" alt=""></p><p>配置好环境变量之后，打开cmd(终端)，输入 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>出现下图效果说明JDK安装配置成功</p><p><img src="https://i.loli.net/2020/05/09/hTROlwQ7uWEyVaJ.png" alt=""></p><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p><strong>HelloWorld</strong></p><p>步骤：</p><ol><li>新建一个文件夹，存放代码</li><li>新建一个Java文件(Hello.java)</li><li>编写代码</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">System.out.print(<span class="string">"Hello,World!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>编译 ，打开终端，输入命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -Hello.java</span><br></pre></td></tr></table></figure><p> 编译完成后生成一个Hello.class文件，再输入运行命令</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java Hello</span><br></pre></td></tr></table></figure><p> 就能看到终端中打印出了 <code>Hello,World!</code></p></li></ol><p><img src="https://i.loli.net/2020/05/09/oLXTjy8ECYeFV25.png" alt=""></p><p><strong>可能遇到的问题</strong></p><ul><li>每个单词的大小写不能出现问题，<strong>Java对大小写敏感</strong></li><li>文件名 和 类名必须保持一致，并且首字母大写</li><li>符号要用英状态下的符号</li></ul><h2 id="Java程序运行机制"><a href="#Java程序运行机制" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h2><h3 id="编译型与解释型"><a href="#编译型与解释型" class="headerlink" title="编译型与解释型"></a>编译型与解释型</h3><p>我们知道，计算机是无法理解现在的高级语言程序的，计算机只能理解机器语言，也就是可以通过CPU进行分析和执行的指令集。而要想让计算机能够运行我们写的高级语言程序，就需要一个系统软件来实现，它就是<strong><code>语言处理程序</code></strong>，也称为<strong><code>编译程序</code></strong>，它可以将我们写的高级语言程序，翻译成计算机可执行的<strong><code>机器语言</code></strong>。而这个翻译的方式就分为<strong><code>编译型</code></strong>和<strong><code>解释性</code></strong>两种。</p><p><strong><code>编译型：</code></strong>是有一个负责翻译的程序来对我们的源代码进行转换，生成相对应的可执行代码(机器码),这个过程就被称为编译,而来编译的程序也就被称为编译器,也就是说我们写一个程序代码在源文件当中,通常经过编译以后生成一个可执行文件,这样我们就可以直接运行了。</p><p><strong><code>解释型：</code></strong>在程序运行的前一刻，还只有源程序没有可执行程序,而当执行时每执行到源程序的某一条指令，则会有有一个称为解释程序的外壳程序将源代码转换成二进制代码以供执行,也就是说一边解释 一边执行 ,所以解释型程序是离不开解释程序的。</p><p>从上面我们可以看出，编译型和解释型的关键区别就在于这个翻译的时机不同。解释型语言在运行程序的时候才翻译,每执行一次,要翻译一次,效率较低。编译型就是直接编译成机器可以执行的格式,只翻译一次。</p><p>编译型和解释型各有优缺点</p><p>优点:</p><p>解释型:可移植性好,只要有运行相应需要的解释环境,可以在不用的操作系统上运行,修改调试也非常方便</p><p>编译型:相比解释执行编译执行效率高，占用资源小，适合复杂程序</p><p>缺点:</p><p>解释型:一句一句执行解释,浪费计算机资源,效率低</p><p>编译型:兼容性差,编译型程序虽然源代码也可以移植，但前提是必须针对不同的系统分别进行编译.</p><h3 id="Java程序运行机制-1"><a href="#Java程序运行机制-1" class="headerlink" title="Java程序运行机制"></a>Java程序运行机制</h3><p><strong>Java这个语言有些特殊，它既是编译型的，又是解释型的</strong></p><p>说Java是编译型的，是因为所有的Java代码都是要编译的，.java不经过编译就什么用都没有。</p><p>说Java是解释型的，是因为java代码编译后不能直接运行，它是解释运行在JVM上的，所以它是解释运行的，那也就算是解释型的了。 </p><p>但是，现在的JVM为了效率，都有一些JIT优化。它又会把.class的二进制代码编译为本地的代码直接运行，所以，又是编译的。像C、C++ 他们经过一次编译之后直接可以编译成操作系统了解的类型，可以直接执行的 所以他们是编译型的语言。没有经过第二次的处理 而Java不一样，他首先由编译器编译成.class类型的文件，这个是Java自己类型的文件 ，然后再通过虚拟机(JVM)从.class文件中读一行解释执行一行，所以他是解释型的语言，而由于Java对于多种不同的操作系统有不同的JVM所以 Java实现了真正意义上的跨平台！</p><p>观看下面两张图 了解一下Java的虚拟机机制：</p><blockquote><p>1.java语言的编译–&gt;解释—&gt;执行过程</p><p><img src="https://i.loli.net/2020/05/10/HtRmwf4LBIr1qPS.jpg" alt="java语言的编译--&gt;解释---&gt;执行过程"></p></blockquote><p><img src="https://i.loli.net/2020/05/10/ITZEnaNuweHiflQ.jpg" alt="java虚拟机JVM"></p><blockquote><p>如果严格按照定义来说，Java应该是解释型语言，因为<em>.java程序在编译之后，被编译为\</em>.class文件，并不是机器码，依然不能被计算机直接运行。*.class文件是在JVM中被解释运行的。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java帝国的建立&quot;&gt;&lt;a href=&quot;#java帝国的建立&quot; class=&quot;headerlink&quot; title=&quot;java帝国的建立&quot;&gt;&lt;/a&gt;java帝国的建立&lt;/h2&gt;&lt;p&gt;1972 年C语言诞生 ，C语言具有贴近硬件，运行速度极快，效率极高的优点，一经诞生，就广泛用于操作系统、编译器、数据库、网络系统等的开发。但由于C语言的指针问题和内存管理的问题，对新手有一些不太友好。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机硬件核心基础</title>
    <link href="https://www.pengspace.top/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.pengspace.top/2020/05/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-05-07T02:43:18.000Z</published>
    <updated>2020-05-30T13:49:50.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>先来了解一些基本概念：</p><p><strong><code>编程语言</code></strong>本质是一门语言，语言就是一种事物与另外一种事物沟通的表达方式/工具，那么编程语言就是<strong>人</strong>与<strong>计算机</strong>之间沟通的方式。</p><a id="more"></a><p><strong><code>编程</code></strong>就是人类把自己想让计算机做的事，也就是自己的思维逻辑，用编程语言表达出来。</p><p><strong><code>编程的目的</code></strong>就是让计算机按照人类的思维逻辑去工作，从而解放人力。</p><p><img src="https://i.loli.net/2020/05/07/hg3NOqwCmSMkfGj.jpg" alt="1"></p><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><blockquote><p><img src="https://i.loli.net/2020/05/16/Hr8qJpKlM3tcuIi.jpg" alt="简单计算机组件"></p></blockquote><h3 id="计算机五大组成部分"><a href="#计算机五大组成部分" class="headerlink" title="计算机五大组成部分"></a>计算机五大组成部分</h3><h4 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a><strong><code>控制器</code></strong></h4><p><strong>控制器</strong>是计算机的指挥系统。控制器通过地址访问存储器，从存储器中取出指令，经译码器分析后，根据指令分析结果产生相应的操作控制信号作用于其他部件，使得各部件在控制器控制下有条不紊地协调工作。</p><h4 id="运算器"><a href="#运算器" class="headerlink" title="运算器"></a><strong><code>运算器</code></strong></h4><p><strong>运算器</strong>是实现算术运算和逻辑运算的部件。</p><p><strong><code>控制器 + 运算器 = CPU</code></strong> </p><h4 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a><strong><code>存储器</code></strong></h4><p><strong>存储器</strong>是计算机用来存放所有数据和程序的记忆部件。它的基本功能是按指定的地址存（写）入或者取（读）出信息。 </p><p>计算机中的存储器可分成两大类：一类是内存储器，简称<strong>内存或主存</strong>；另一类是外存储器(辅助存储器)，简称<strong>外存或辅存</strong>。 存储器由若干个存储单元组成，每个存储单元都有一个地址，计算机通过地址对存储单元进行读写。一个存储器所包含的字节数称为<strong>存储容量</strong>，单位有B、KB、MB、GB、TB等。</p><ul><li><p><strong>内存:</strong> 存取数据快；断电数据丢失，只能临时存取数据。</p></li><li><p><strong>外存:</strong>存取数据慢；断电数据不会丢失，用来永久保存数据 。</p><p>  内存的存取速度要远高于外存。</p></li></ul><h4 id="输入设备input"><a href="#输入设备input" class="headerlink" title="输入设备input"></a><strong><code>输入设备input</code></strong></h4><p><strong>输入设备</strong>是计算接收外界输入数据的工具，如键盘、鼠标。</p><h4 id="输出设备output"><a href="#输出设备output" class="headerlink" title="输出设备output"></a><strong><code>输出设备output</code></strong></h4><p><strong>输出设备</strong>是计算机向外输出数据的工具，如显示器、打印机。</p><p>存储器如内存、磁盘等既是输入设备又是输出设备，统称为IO设备</p><blockquote><p><img src="https://i.loli.net/2020/05/16/4aDRbLGvfy7wrAs.png" alt="img"></p></blockquote><p>CPU存取的数据和指令都来自主存储器(内存) 。</p><p>内存称之为主存，主存储器内的数据则是从输入单元所传输进来！而CPU处理完毕的数据也必须先写回主存储器中，最后数据才从主存储器传输到输出单元。</p><h3 id="程序运行与三大核心硬件-CPU-内存-硬盘-的关系"><a href="#程序运行与三大核心硬件-CPU-内存-硬盘-的关系" class="headerlink" title="程序运行与三大核心硬件(CPU 内存 硬盘)的关系"></a>程序运行与三大核心硬件(CPU 内存 硬盘)的关系</h3><p>我们编写的程序一定是要运行于计算机硬件之上，而站在硬件的角度，与运行程序有关的三大核心硬件为CPU、内存、硬盘。</p><p>程序最先是存放于硬盘中的，程序的运行是先从硬盘把代码加载到内存中，然后CPU是从内存中读取指令运行。</p><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统的由来"><a href="#操作系统的由来" class="headerlink" title="操作系统的由来"></a>操作系统的由来</h3><p>大前提：我们编程目的就是为了奴役计算机，让计算机硬件自发地运行起来，然而硬件毕竟是”死的“，<strong>硬件的运行都是由软件支配</strong>。</p><p>倘若我们要开发一个应用程序，在没有操作系统之前，开发者在编写业务逻辑之前，必须先编写一套完整的控制程序来控制所有的硬件基本运行(这要求开发者需要详细了解计算机硬件的各种控制细节，例如要熟悉CPU里面所有的指令集)，如此，所有开发者在开发程序时都必须按以下两个步骤：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.编写一套完整的的控制程序，用来控制硬件的基本运行，以及把复杂的硬件的操作封装成简单的接口</span><br><span class="line">2.基于控制程序的接口开发包含一系列业务逻辑的程序，为了与控制程序区分，可以称为应用程序.</span><br></pre></td></tr></table></figure><p>综上，对于不同的应用程序来说，应用程序的业务逻辑各不相同，但硬件的控制程序都大致相同，为了避免所有开发者做重复劳动，以及不用再耗费精力去了解所有硬件的运行细节，有公司专门跳出来承担起控制程序的开发任务，这里所说的控制程序指的就是操作系统。</p><p><strong><code>操作系统</code></strong>是一个协调、管理、控制计算机硬件资源与应用软件资源的控制程序。它位于计算机硬件与应用软件之间，起承上启下的作用。</p><p><strong>操作系统的功能:</strong> </p><ul><li><p>控制计算机硬件的基本运行</p></li><li><p>帮我们把复杂的硬件的控制封装成简单的接口，对于开发应用程序来说只需要调用操作系统提供给我们的接口即可</p></li></ul><h3 id="系统软件与应用软件"><a href="#系统软件与应用软件" class="headerlink" title="系统软件与应用软件"></a>系统软件与应用软件</h3><ul><li><p>系统软件：</p><p>  指控制和协调计算机及外部设备、支持应用软件开发和运行的系统，是无需用户干预的各种程序的集合，主要功能是调度、监控和维护计算机系统；负责管理计算机系统中各种独立的硬件，使得它们可以协调工作。系统软件使得计算机使用者和其他软件将计算机当作一个整体而不需要顾及到底层每个硬件是如何工作的。</p><p>  一般来讲，系统软件包括操作系统和一系列基本的工具（比如编译器，数据库管理，存储器格式化，文件系统管理，用户身份验证，驱动管理，网络连接等方面的工具），是支持计算机系统正常运行并实现用户操作的那部分软件。</p></li><li><p>应用软件：</p><p>  应用软件(Application）是和系统软件相对应的，是用户可以使用的各种程序设计语言，以及用各种程序设计语言编制的应用程序的集合，分为应用软件包和用户程序。应用软件包是利用计算机解决某类问题而设计的程序的集合，多供用户使用。</p><p>  应用软件是为满足用户不同领域、不同问题的应用需求而提供的那部分软件。 它可以拓宽计算机系统的应用领域，放大硬件的功能。</p></li></ul><h3 id="计算机系统三层结构"><a href="#计算机系统三层结构" class="headerlink" title="计算机系统三层结构"></a>计算机系统三层结构</h3><p>我们开发应用程序本质是在控制硬件，但是我们直接打交道的是操作系统，应用程序都是通过操作系统来间接地操作硬件的，所以一套完整的计算机系统分为三层，如下：</p><blockquote><p><img src="https://i.loli.net/2020/04/20/nrdy8V6NIoPLhiD.jpg" alt="计算机系统三层结构"></p></blockquote><h3 id="平台与跨平台的概念"><a href="#平台与跨平台的概念" class="headerlink" title="平台与跨平台的概念"></a>平台与跨平台的概念</h3><p>应用程序都是运行于操作系统之上，而操作系统则是运行于硬件之上的，所以承载应用程序的是一台运行有操作系统的计算机，称之为应用程序的运行平台，即：<strong><code>硬件 + 操作系统 = 平台</code></strong>。</p><blockquote><p><img src="https://i.loli.net/2020/04/20/iBWhvPRqGZ14ry5.jpg" alt="平台"></p></blockquote><p>常见的平台有：windows系统+某款硬件、linux系统+某款硬件、ubuntu+某款硬件等，我们在开发应用程序时就需要考虑到应用程序的<strong>跨平台</strong>性，如果能开发出一款可以在任意平台运行的应用程序，那对于开发者来说真是极大的福音。</p><p>跨平台即不依赖于操作系统，也不依赖硬件环境。一个操作系统下开发的应用，放到另一个操作系统下依然可以运行。而决定应用软件的跨平台性的关键因素往往是编程语言的选择,一般解释型语言(即不需编译的语言，比如：PHP、Python等)都可跨平台运行；有些编译型语言(如：Java等)由于其本身的特性(不同平台有不同的库、具有跨平台的扩展以及中间件)，也可跨平台运行。</p><h2 id="知识拓展"><a href="#知识拓展" class="headerlink" title="知识拓展"></a>知识拓展</h2><h3 id="CPU详解"><a href="#CPU详解" class="headerlink" title="CPU详解"></a>CPU详解</h3><h4 id="CPU的分类与指令集"><a href="#CPU的分类与指令集" class="headerlink" title="CPU的分类与指令集"></a>CPU的分类与指令集</h4><p>CPU内部是含有微指令集的，我们所使用的的软件都要经过CPU内部的微指令集来完成才行。这些指令集的设计主要又被分为两种设计理念，这就是目前世界上常见到的两种主要的CPU种类：分别是精简指令集（RISC）与复杂指令集（CISC）系统。下面我们就来谈谈这两种不同CPU种类的差异！</p><p>1.<strong><code>精简指令集</code></strong></p><p>精简指令集(Reduced Instruction Set Computing，RISC)：这种CPU的设计中，微指令集较为精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。常见的RISC指令集CPU主要例如Sun公司的SPARC系列、IBM公司的Power Architecture（包括PowerPC）系列、与ARM系列等。【注：Sun已经被Oracle收购】</p><p>SPARC架构的计算机常用于学术领域的大型工作站中，包括银行金融体系的主服务器也都有这类的计算机架构；</p><p>PowerPC架构的应用，如Sony出产的Play Station 3（PS3）使用的就是该架构的Cell处理器。</p><p>ARM是世界上使用范围最广的CPU，常用的各厂商的手机、PDA、导航系统、网络设备等，几乎都用该架构的CPU。</p><p>2.<strong><code>复杂指令集</code></strong></p><p>复杂指令集（Complex Instruction Set Computer，CISC）与RISC不同，在CISC的微指令集中，每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因此指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。常见的CISC微指令集CPU主要有AMD、Intel、VIA等的x86架构的CPU。</p><p>总结：</p><p>CPU按照指令集可以分为精简指令集CPU和复杂指令集CPU两种，区别在于前者的指令集精简，每个指令的运行时间都很短，完成的动作也很单纯，指令的执行效能较佳；但是若要做复杂的事情，就要由多个指令来完成。后者的指令集每个小指令可以执行一些较低阶的硬件操作，指令数目多而且复杂，每条指令的长度并不相同。因为指令执行较为复杂所以每条指令花费的时间较长，但每条个别指令可以处理的工作较为丰富。</p><h4 id="x86-64"><a href="#x86-64" class="headerlink" title="x86-64"></a>x86-64</h4><p><strong><code>x86架构</code></strong></p><p>x86是针对cpu的型号或者说架构的一种统称，详细地讲，最早的那颗Intel发明出来的CPU代号称为8086，后来在8086的基础上又开发出了80285、80386….，因此这种架构的CPU就被统称为x86架构了。</p><p>由于AMD、Intel、VIA所开发出来的x86架构CPU被大量使用于个人计算机上面，因此，个人计算机常被称为x86架构的计算机！</p><p>程序员开发出的软件最终都要翻译成cpu的指令集才能运行，因此软件的版本必须与cpu的架构契合，举个例子，我们在MySQL官网下载软件MySQL时名字为：<code>Windows(x86,32-bit),ZIP Archive (mysql-5.7.20-win32.zip)</code>我们发现名字中有x86，这其实就是告诉我们：该软件应该运行在x86架构的计算机上。</p><p><strong><code>64位</code></strong></p><p>cpu的位数指的是cpu一次性能从内存中取出多少位二进制指令，64bit指的是一次性能从内存中取出64位二进制指令。</p><p>在2003年以前由Intel所开发的x86架构CPU由8位升级到16、32位，后来AMD依此架构修改新一代的CPU为64位，到现在，个人计算机CPU通常都是x86_64的架构。</p><p>cpu具有向下兼容性，指的是64位的cpu既可以运行64位的软件，也可以运行32位的软件，而32位的cpu只能运行32位的软件。这其实很好理解，如果把cpu的位数当成是车道的宽，而内存中软件的指令当做是待通行的车辆，宽64的车道每次肯定既可以通行64辆车，也可以通信32辆车，而宽32的车道每次却只能通行32辆车</p><h4 id="运算器与控制器"><a href="#运算器与控制器" class="headerlink" title="运算器与控制器"></a>运算器与控制器</h4><p>常将运算器和控制器合称为中央处理器(Central Processing Unit，CPU)。其中运算器用来主要负责程序运算与逻辑判断，控制器则主要协调各组件和各单元的工作，所以CPU的工作主要在于管理和运算。可以说计算机的大脑就是CPU。</p><p><strong><code>1.运算器</code></strong></p><p>运算器是对信息进行处理和运算的部件。经常进行的运算是算术运算和逻辑运算，所以运算器又可称为算术逻辑运算部件（Arithmetic and Logical，ALU）。</p><p>运算器的核心是加法器。运算器中还有若干个通用寄存器或累加寄存器，用来暂存操作数并存放运算结果。寄存器的存取速度比存储器的存放速度快很多。</p><p><strong><code>2.控制器</code></strong></p><p>控制器是整个计算机的指挥中心，它的主要功能是按照人们预先确定的操作步骤，控制整个计算机的各部件有条不紊的自动工作。</p><p>控制器从主存中逐条地读取出指令进行分析，根据指令的不同来安排操作顺序，向各部件发出相应的操作信号，控制它们执行指令所规定的任务。控制器中包括一些专用的寄存器。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>寄存器是中央处理器内的组成部份。它跟CPU有关。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。在中央处理器的算术及逻辑部件中，包含的寄存器有累加器(ACC)。</p><blockquote><p><img src="https://i.loli.net/2020/05/16/l1qb8EsJoZPtx4m.jpg" alt="img"></p></blockquote><h4 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h4><p>除了在嵌入式系统中的非常简单的CPU(如:单片机)之外，多数CPU都有两种模式，即<strong><code>内核态与用户态</code></strong>。</p><p>通常，计算机由<a href="https://baike.baidu.com/item/PSW/1878339?fr=aladdin" target="_blank" rel="noopener">PSW</a>(程序状态寄存器)控制这两种模式。</p><p><strong><code>内核态：</code></strong>当cpu在内核态运行时，cpu可以执行指令集中所有的指令，很明显，所有的指令中包含了使用硬件的所有功能，（操作系统在内核态下运行，从而可以访问整个硬件）</p><p><strong><code>用户态：</code></strong>用户程序在用户态下运行，仅仅只能执行cpu整个指令集的一个子集，该子集中不包含操作硬件功能的部分，因此，一般情况下，在用户态中有关I/O和内存保护（操作系统占用的内存是受保护的，不能被别的程序占用），当然，在用户态下，将PSW中的模式设置成内核态也是禁止的。</p><p><strong><code>内核态与用户态切换:</code></strong><br>        用户态下工作的软件不能操作硬件，但是我们的软件一定会有操作硬件的需求，比如从磁盘上读一个文件，那就必须经历从用户态切换到内核态的过程，为此，用户程序必须使用<a href="https://baike.baidu.com/item/系统调用/861110" target="_blank" rel="noopener">系统调用(system call)</a>，通过相应的指令把用户态切换成内核态。</p><p>把系统调用看成一个特别的过程调用指令就可以了，该指令具有从用户态切换到内核态的特别能力。</p><h4 id="多线程与多核芯片"><a href="#多线程与多核芯片" class="headerlink" title="多线程与多核芯片"></a>多线程与多核芯片</h4><p>在一个CPU中增加多个处理逻辑，称为多线程或超线程，该概念是由Inter公司首次提出。</p><p>多核就是多个完整的CPU处理器。</p><p>比如，我们常说的四核八线程，就是指有四个CPU,每个CPU中有两个线程。</p><blockquote><img src="https://i.loli.net/2020/05/03/L4eNdiVUZ3AYOgs.png" alt="1" style="zoom: 80%;" /><img src="https://i.loli.net/2020/05/03/Ix8Ogqi9DKUa36H.png" alt="2" style="zoom:80%;" /></blockquote><h3 id="存储器相关"><a href="#存储器相关" class="headerlink" title="存储器相关"></a>存储器相关</h3><blockquote><p><img src="https://i.loli.net/2020/05/16/Ko49glFa7BZUNXV.jpg" alt="存储层次结构"></p></blockquote><p>存储器系统采用如上图的分层结构，顶层的存储器速度较高，容量较小，与底层的存储器相比每位的成本较高，其差别往往是十亿数量级的。</p><h4 id="寄存器即L1缓存"><a href="#寄存器即L1缓存" class="headerlink" title="寄存器即L1缓存"></a>寄存器即L1缓存</h4><p>用与cpu相同材质制造，与cpu一样快，因而cpu访问它无时延，典型容量是：在32位cpu中为32*32，在64位cpu中为64*64，在两种情况下容量均小于1KB。</p><h4 id="高速缓存即L2缓存"><a href="#高速缓存即L2缓存" class="headerlink" title="高速缓存即L2缓存"></a>高速缓存即L2缓存</h4><p>主要由硬件控制高速缓存的存取，内存中有高速缓存行按照0~64字节为行0，64~127为行1…</p><p>最常用的高速缓存行放置在cpu内部或者非常接近cpu的高速缓存中。当某个程序需要读一个存储字时，高速缓存硬件检查所需要的高速缓存行是否在高速缓存中。如果是，则称为<strong>高速缓存命中</strong>，缓存满足了请求，就不需要通过总线把访问请求送往主存(内存)，这毕竟是慢的。高速缓存的命中通常需要两个时钟周期。<strong>高速缓存未命中</strong>，就必须访问内存，这需要付出大量的时间代价。由于高速缓存价格昂贵，所以其大小有限，有些机器具有两级甚至三级高速缓存，每一级高速缓存比前一级慢但是容量大。</p><p>缓存在计算机科学的许多领域中起着重要的作用，并不仅仅只是RAM（随机存取存储器）的缓存行。只要存在大量的资源可以划分为小的部分，那么这些资源中的某些部分肯定会比其他部分更频发地得到使用，此时用缓存可以带来性能上的提升。一个典型的例子就是操作系统一直在使用缓存，比如，多数操作系统在内存中保留频繁使用的文件（的一部分），以避免从磁盘中重复地调用这些文件，类似的/root/a/b/c/d/e/f/a.txt的长路径名转换成该文件所在的磁盘地址的结果然后放入缓存，可以避免重复寻找地址，还有一个web页面的url地址转换为网络地址(IP)地址后，这个转换结果也可以缓存起来供将来使用。</p><p>缓存是一个好方法，在现代cpu中设计了两个缓存，再看3.1.5中的两种cpu设计图。第一级缓存称为L1总是在CPU中，通常用来将已经解码的指令调入cpu的执行引擎，对那些频繁使用的数据字，多数芯片还会安装第二L1缓存 … 另外往往设计有二级缓存L2，用来存放近来经常使用的内存字。L1与L2的差别在于对cpu对L1的访问无时间延迟，而对L2的访问则有1-2个时钟周期（即1-2ns）的延迟。</p><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>再往下一层是主存，此乃存储器系统的主力，主存通常称为<strong>随机访问存储(可读可写)<code>RAM</code></strong>，就是我们通常所说的内存，容量一直在不断攀升，所有不能再高速缓存中找到的，都会到主存中找，<strong>主存是易失性存储，断电后数据全部消失</strong>。</p><p>除了主存RAM之外，许多计算机已经在使用少量的<strong>非易失性随机访问存储如<code>ROM</code>(Read Only Memory)</strong>，在电源切断之后，非易失性存储的内容并不会丢失，ROM只读存储器在工厂中就被编程完毕，然后再也不能修改。ROM速度快且便宜，在有些计算机中，用于启动计算机的引导加载模块(BIOS)就存放在ROM中，另外一些I/O卡也采用ROM处理底层设备的控制。 </p><p><strong><code>EEPROM</code>（Electrically Erasable PROM，电可擦除可编程ROM）和<code>闪存</code>（flash memory）也是非易失性的</strong>，但是与ROM相反，他们可以擦除和重写。不过重写时花费的时间比写入RAM要多。在便携式电子设备中中，闪存通常作为存储媒介。闪存是数码相机中的胶卷，是便携式音译播放器的磁盘，还应用于固态硬盘。闪存在速度上介于RAM和磁盘之间，但与磁盘不同的是，闪存擦除的次数过多，就被磨损了。</p><p>还有一类存储器就是<strong><code>CMOS</code>，它是易失性的</strong>，许多计算机利用CMOS存储器来<strong>保持当前时间和日期</strong>。CMOS存储器和递增时间的电路由一小块<strong>电池驱动</strong>，所以，即使计算机没有加电，时间也仍然可以正确地更新，除此之外<strong>CMOS还可以保存配置的参数，比如，哪一个是启动磁盘等</strong>，之所以采用CMOS是因为它耗电非常少，一块工厂原装电池往往能使用若干年，但是当电池失效时，相关的配置和时间等都将丢失</p><h4 id="硬盘（磁盘-机械硬盘）"><a href="#硬盘（磁盘-机械硬盘）" class="headerlink" title="硬盘（磁盘/机械硬盘）"></a>硬盘（磁盘/机械硬盘）</h4><blockquote><p><img src="https://i.loli.net/2020/05/03/17kJ8TzIfXl4rix.png" alt="3"></p><img src="https://i.loli.net/2020/05/03/cNI7GgKnPJVzvMS.png" alt="4" style="zoom:80%;" /></blockquote><p>磁盘低速的原因是因为它一种机械装置，在磁盘中有一个或多个金属盘片，它们以5400，7200或10800rpm（RPM =revolutions per minute 每分钟多少转 ）的速度旋转。从边缘开始有一个机械臂悬在盘面上，这类似于老式黑胶唱片机上的拾音臂。信息卸载磁盘上的一些列的同心圆上，是一连串的2进制位（称为bit位），为了统计方法，8个bit称为一个字节Bytes，1024Bytes=1kB，1024kB=1MB，1024MB=1GB，1024GB=1TB，1024TB = 1PB所以我们平时所说的磁盘容量最终指的就是磁盘能写多少个2进制位。</p><p>每个磁头可以读取一段换新区域，称为<strong><code>磁道</code></strong>。</p><p>把一个机械手臂位置上所有的磁道合起来，组成一个<strong><code>柱面</code></strong>。</p><p>每个磁道划成若干<strong><code>扇区</code></strong>，站在硬盘的角度，一次性读写数据的最小单位为扇区，一个扇区通常为512Bytes。</p><p>操作系统一次性读写的单位是一个Block块，默认是8个扇区，也就是4096Bytes</p><h4 id="硬盘的IO延迟问题"><a href="#硬盘的IO延迟问题" class="headerlink" title="硬盘的IO延迟问题"></a>硬盘的IO延迟问题</h4><p><strong>数据都存放于一段一段的扇区，即磁道这个圆圈的一小段圆圈，从磁盘读取一段数据需要经历寻道时间和延迟时间</strong></p><p><strong>平均寻道时间：</strong></p><p>机械手臂从一个柱面随机移动到相邻的柱面的时间称为寻道时间，找到了磁道就意味着找到了数据所在的那个圈圈，但是还不知道数据具体这个圆圈的具体位置。受限于物理工艺水平。</p><p><strong>平均延迟时间：</strong></p><p>机械臂到达正确的磁道之后还必须等待旋转到数据所在的扇区下，这段时间称为延迟时间。受限于硬盘的转速！</p><p>IO延迟 = 平均寻道时间+平均延期时间。</p><blockquote><p><strong><code>优化程序运行效率的一个核心法则：能从内存取数据，就不要从硬盘取数据</code></strong></p></blockquote><h4 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h4><p>许多计算机支持虚拟内存机制，该机制使计算机可以运行大于物理内存的程序，方法是将正在使用的程序放入内存执行，而暂时不需要执行的程序放到磁盘的某块地方，这块地方成为虚拟内存，在linux中称为swap，这种机制的核心在于快速地映射内存地址，由cpu中的一个部件负责，成为存储器管理单元(Memory Management Unit， MMU)</p><blockquote><p>从一个程序切换到另外一个程序，称为上下文切换(context switch),缓存和MMU的出现提升了系统的性能，尤其是上下文切换。</p></blockquote><blockquote><p>PS：磁带：</p><p>在价钱相同的情况下比硬盘拥有更高的存储容量，虽然速度低于磁盘，但是因其大容量，在地震水灾火灾时可移动性强等特性，常被用来做备份。（常见于大型数据库系统中）</p></blockquote><h3 id="IO设备"><a href="#IO设备" class="headerlink" title="IO设备"></a>IO设备</h3><p><strong>IO设备 = 设备的控制器+设备本身</strong></p><p>cpu和存储器并不是操作系统唯一需要管理的资源，I/O设备也是非常重要的一环。</p><p>见1.1的图，<strong>I/O设备一般包括两个部分：设备控制器和设备本身</strong>。</p><p>控制器：是查找主板上的一块芯片或一组芯片（硬盘，网卡，声卡等都需要插到一个口上，这个口连的便是控制器），控制器负责控制连接的设备，它从操作系统接收命令，比如读硬盘数据，然后就对硬盘设备发起读请求来读出内容。</p><p>控制器的功能：通常情况下对设备的控制是非常复杂和具体的，控制器的任务就是为操作系统屏蔽这些复杂而具体的工作，提供给操作系统一个简单而清晰的接口</p><p>设备本身：有相对简单的接口且标准的，这样大家都可以为其编写驱动程序了。要想调用设备，必须根据该接口编写复杂而具体的程序，于是有了控制器提供设备驱动接口给操作系统。必须把设备驱动程序安装到操作系统中。</p><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>在第1节的结构在小型计算机中沿用了多年，并也用在早期的IBM PC中。但是随着处理器和存储器速度越来越快，单总线很难处理总线的交通流量了，于是出现了下图的多总线模式，他们处理I/O设备及cpu到存储器的速度都更快。</p><p>北桥即PCI桥：连接高速设备</p><p>南桥即ISA桥：连接慢速设备</p><blockquote><p><img src="https://images2015.cnblogs.com/blog/1036857/201701/1036857-20170118183358656-1969770652.png" alt=""></p></blockquote><p>主板图解：</p><p><img src="https://images2018.cnblogs.com/blog/1036857/201803/1036857-20180314164300354-1096940375.jpg" alt=""></p><h3 id="操作系统启动流程"><a href="#操作系统启动流程" class="headerlink" title="操作系统启动流程"></a>操作系统启动流程</h3><p>在计算机的主板上有一个基本的输入输出程序（Basic  Input Output System)</p><p>BIOS就相当于一个小的操作系统，它有底层的I/O软件，包括读键盘，写屏幕，进行磁盘I/O,该程序存放于一非易失性存储ROM中。</p><p><strong>启动流程：</strong></p><p>1.计算机加电</p><p>2.BIOS开始运行，检测硬件：cpu、内存、硬盘等</p><p>3.BIOS读取CMOS存储器中的参数，选择启动设备</p><p>4.从启动设备上读取第一个扇区的内容（MBR主引导记录512字节，前446为引导信息，后64为分区信息，最后两个为标志位）</p><p>5.根据分区信息读入bootloader启动装载模块，启动操作系统</p><p>6.然后操作系统询问BIOS，以获得配置信息。对于每种设备，系统会检查其设备驱动程序是否存在，如果没有，系统则会要求用户安装设备驱动程序。一旦有了全部的设备驱动程序，操作系统就将它们调入内核。然后初始有关的表格（如进程表），传进需要的进程，并在每个终端上启动登录程序或GUI</p><blockquote><p>补充：<strong>应用程序的启动流程</strong></p><ol><li>双击exe快捷方式，该快捷方式指向一个绝对路径</li><li>操作系统会根据路径找到exe程序在硬盘中的位置，控制其代码从硬盘加载到内存</li><li>然后CPU从内存中读取刚刚读入内存的程序代码执行，应用程序完成启动</li></ol></blockquote><h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>[1]    <a href="https://www.cnblogs.com/linhaifeng/p/6523843.html#4462371" target="_blank" rel="noopener">https://www.cnblogs.com/linhaifeng/p/6523843.html#4462371</a></p><p>[2]    <a href="https://zhuanlan.zhihu.com/p/108350791" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/108350791</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;先来了解一些基本概念：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;编程语言&lt;/code&gt;&lt;/strong&gt;本质是一门语言，语言就是一种事物与另外一种事物沟通的表达方式/工具，那么编程语言就是&lt;strong&gt;人&lt;/strong&gt;与&lt;strong&gt;计算机&lt;/strong&gt;之间沟通的方式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://www.pengspace.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机组成" scheme="https://www.pengspace.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/"/>
    
      <category term="计算机硬件" scheme="https://www.pengspace.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6/"/>
    
      <category term="操作系统" scheme="https://www.pengspace.top/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
