<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>鹏空间</title>
  
  <subtitle>学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.pengspace.top/"/>
  <updated>2020-12-12T06:05:08.202Z</updated>
  <id>https://www.pengspace.top/</id>
  
  <author>
    <name>AnswerCoder</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Git版本控制工具的使用</title>
    <link href="https://www.pengspace.top/2020/12/12/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.pengspace.top/2020/12/12/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-12-12T06:03:13.000Z</published>
    <updated>2020-12-12T06:05:08.202Z</updated>
    
    <content type="html"><![CDATA[<h2 id="版本控制概述"><a href="#版本控制概述" class="headerlink" title="版本控制概述"></a>版本控制概述</h2><p>版本控制是实现开发团队<strong>并行开发、提高开发效率</strong>的基础。其目的在于对软件开发进程中文件或目录的发展过程提供有效的追踪手段，保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和相互覆盖，通过对版本库的访问控制避免未经授权的访问和修改，达到有效保护企业软件资产和知识产权的目的。</p><a id="more"></a><p>版本控制的功能在于跟踪记录整个软件的开发过程，包括软件本身和相关文档，以便对不同阶段的软件及相关文档进行表示并进行差别分析，对软件代码进行可撤消的修改，便于汇总不同开发人员所做的修改，辅助协调和管理软件开发团队。</p><h2 id="常用版本控制工具"><a href="#常用版本控制工具" class="headerlink" title="常用版本控制工具"></a>常用版本控制工具</h2><h3 id="Visual-Source-Safe-VSS）"><a href="#Visual-Source-Safe-VSS）" class="headerlink" title="Visual Source Safe(VSS）"></a>Visual Source Safe(VSS）</h3><p>VSS是美国微软公司的产品，目前常用的版本为6.0版。VSS是配置管理的一种很好的入门级的工具。</p><p>易学易用是VSS的强项，VSS采用标准的windows操作界面，只要对微软的产品熟悉，就能很快上手。</p><p>VSS的配置管理的功能比较基本，提供文件的版本跟踪功能，对于build和基线的管理，VSS的打标签的功能可以提供支持。VSS提供share（共享)、branch(分支）和合并（merge)的功能，对于团队的开发进行支持。VSS不提供对流程的管理功能，如对变更的流程进行控制。</p><p>VSS不能提供对异地团队开发的支持。此外VSS只能在windows平台上运行，不能运行在其他操作系统上。</p><p>VSS的安全性不高，对于VSS的用户，可以在文件夹上设置不可读，可读，可读/写,可完全控制四级权限。但由于VSS的文件夹是要完全共享给用户后，用户才能进入，所以用户对VSS的文件夹都可以删除。这一点也是VSS的一个比较大的缺点。</p><p><strong>微软已不再对VSS提供技术支持。</strong></p><h3 id="Concurrent-Version-System-CVS）"><a href="#Concurrent-Version-System-CVS）" class="headerlink" title="Concurrent Version System(CVS）"></a>Concurrent Version System(CVS）</h3><p>CVS是开发源代码的配置管理工具，其源代码和安装文件都可以免费下载。</p><p>CVS是源于unix的版本控制工具，CVS的服务器管理需要进行各种命令行操作。目前，CVS的客户端有winCVS的图形化界面，服务器端也有CVSNT的版本，易用性正在提高。</p><p>CVS的功能除具备VSS的功能外，还具有：</p><p>它的客户机/服务器存取方法使得开发者可以从任何因特网的接入点存取最新的代码；它的无限制的版本管理检出(checkout)的模式避免了通常的 因为排它检出模式而引起的人工冲突；它的客户端工具可以在绝大多数的平台上使用。同样，CVS不提供对变更流程的自动管理功能。</p><p>一般来说，CVS的权限设置单一，通常只能通过CVSROOT/passwd，CVSROOT/readers，CVSROOT/writers文件同时还要设置CVS REPOS的物理目录权限来完成权限设置，无法完成复杂的权限控制；但是CVS通过CVS ROOT目录下的脚本，提供了相应功能扩充的接口，不但可以完成精细的权限控制，还能完成更加个性化的功能。</p><p>CVS是开发源码软件，没有生产厂家为其提供技术的支持。如发现问题，通常只能靠自己查找网上的资料进行解决。</p><h3 id="SVN"><a href="#SVN" class="headerlink" title="SVN"></a>SVN</h3><p>SVN全名Subversion，即版本控制系统。</p><p>SVN与CVS一样，是一个跨平台的软件，支持大多数常见的操作系统。作为一个开源的版本控制系统，Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏览文件的变动历史。Subversion 是一个通用的系统, 可用来管理任何类型的文件, 其中包括了程序源码。</p><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>Git是一个开源的<strong>分布式</strong>版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Torvalds 开始着手开发 Git 是为了作为一种过渡方案来替代 BitKeeper，后者之前一直是 Linux 内核开发人员在全球使用的主要源代码工具。开放源码社区中的有些人觉得 BitKeeper 的许可证并不适合开放源码社区的工作，因此 Torvalds 决定着手研究许可证更为灵活的版本控制系统。尽管最初 Git 的开发是为了辅助 Linux 内核开发的过程，但是我们已经发现在很多其他自由软件项目中也使用了 Git。</p><h3 id="Git和SVN的区别"><a href="#Git和SVN的区别" class="headerlink" title="Git和SVN的区别"></a>Git和SVN的区别</h3><ul><li><p>Git 是分布式的，SVN 不是：</p><p>这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。</p></li><li><p>Git 把内容按元数据方式存储，而 SVN 是按文件：</p><p>所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.git 等的文件夹里。</p></li><li><p>Git 分支和 SVN 的分支不同：</p><p>分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。<strong>Git 分支是指针指向某次提交，而 SVN 分支是拷贝的目录</strong>。这个特性使 Git 的分支切换非常迅速，且创建成本非常低。</p><p><strong>Git 有本地分支，SVN 无本地分支</strong>。在实际开发过程中，经常会遇到有些代码没写完，但是需紧急处理其他问题，若我们使用 Git，便可以创建本地分支存储没写完的代码，待问题处理完后，再回到本地分支继续完成代码。</p></li><li><p>Git 没有一个全局的版本号，而 SVN 有：</p><p>目前为止这是跟 SVN相比，Git 缺少的最大的一个特征。</p></li><li><p>Git 的内容完整性要优于 SVN：</p><p>Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网<br>络问题时降低对版本库的破坏。</p></li></ul><p><img src="https://i.loli.net/2020/11/27/7rwU4cupNyPqlbo.png" alt=""></p><h2 id="Git的使用"><a href="#Git的使用" class="headerlink" title="Git的使用"></a>Git的使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以进入官网<a href="https://git-scm.com/" target="_blank" rel="noopener">https://git-scm.com/</a>，选择适合自己电脑的版本下载并安装。</p><p><img src="https://i.loli.net/2020/11/27/pRV15kXo3ydm8Wa.png" alt=""></p><p>安装时一路next即可。需要注意的点有：</p><p><img src="https://i.loli.net/2020/11/27/M3mkjfQh1l8KICc.png" alt="选择Bash和GUI"></p><p>仅供参考。</p><p>安装完成后在桌面或任意文件夹单击鼠标右键，出现<em>Git Bash Here</em>/ <em>Git GUI Here</em>则说明安装成功</p><p><img src="https://i.loli.net/2020/11/27/LYXTGHfc9DWu2gd.png" alt=""></p><p>或者在cmd终端输入：<code>git --version</code>，出现版本说明安装成功</p><p><img src="https://i.loli.net/2020/11/27/8vGaIdZS5rLNeCT.png" alt="image-20201127135807275"></p><h3 id="Git工作区域"><a href="#Git工作区域" class="headerlink" title="Git工作区域"></a>Git工作区域</h3><p>git的工作区域分为3个区域：工作区、暂存区和仓库区。3个区的功能分别为：</p><ol><li>工作区：用来对代码进行修改（也就是我们的工作文件夹内部的文件本身,或者说是我们本地的文件夹）</li><li>暂存区：暂时存放准备放入仓库区的代码</li><li>仓库区：存放各个版本的代码</li></ol><p>三个区之间的联系和文件操作如下图所示</p><p><img src="https://i.loli.net/2020/11/27/sqL4HgNiS3FDbBz.png" alt=""></p><h3 id="Git初始化仓库和常用指令"><a href="#Git初始化仓库和常用指令" class="headerlink" title="Git初始化仓库和常用指令"></a>Git初始化仓库和常用指令</h3><p>初始化仓库的步骤如下：</p><ol><li>在我们想要进行版本控制的文件夹中，右键打开git bash</li><li>在文件夹内初始化git(创建git仓库)<br><code>git init</code> (会生成一个.git的隐藏文件）</li></ol><p>常用指令：</p><ul><li><p><strong>add 添加文件</strong></p><p>格式：<code>git add 文件名</code></p><p>作用：将工作区的文件提交（此时文件<strong>提交至暂存区</strong>）</p><blockquote><p>  注：如果文件名参数为<code>*</code>，表示提交当前目录下的所有文件。目录路径可以用<code>/</code>分隔开。</p></blockquote></li><li><p><strong>rm 删除文件</strong></p><p>格式：<code>git rm 文件名</code></p><p>作用：删除文件（工作区/库一起删除）</p><blockquote><p>  注：如果想要删除文件夹，则添加参数<code>-r</code>： <code>git rm -r 文件夹</code></p><p>  当我们需要删除暂存区或分支上的文件， 但本地又需要使用，只是不希望这个文件被版本控制， 可以使用下面迷命令只删除暂存区和版本库中的文件，保留工作区文件：</p><p>  <code>git rm -r --cached 文件夹名称</code></p></blockquote></li><li><p><strong>status 查看当前状态</strong></p><p>格式：<code>git status</code></p><p>作用：查看暂存区状态（有多少条指令待执行）</p></li><li><p><strong>commit 提交</strong></p><p>格式：<code>git commit -m &quot;提交描述&quot;</code></p><p>作用：执行暂存区的指令。提交描述表示这次提交的描述信息。</p></li></ul><h2 id="Git远程服务器"><a href="#Git远程服务器" class="headerlink" title="Git远程服务器"></a>Git远程服务器</h2><p>git常见的远程服务器有：</p><ul><li><p><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></p></li><li><p><a href="https://gitlab.com/users/sign_in" target="_blank" rel="noopener">GitLab</a></p></li><li><p><a href="https://gitee.com/" target="_blank" rel="noopener">Gitee（码云）</a></p></li></ul><p>其中，GitHub和GitLab都是国外服务商，在国内访问速度可能会受到限制。Gitee是国内的代码托管与开发协作平台，在国内的访问速度相比GitHub和GitLab要快很多。</p><blockquote><p>  <strong>==GitHub==</strong></p><p>  通过git管理github托管项目代码。</p><blockquote><p>  GitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名GitHub。</p><p>  GitHub于2008年4月10日正式上线，除了git代码仓库托管及基本的Web管理界面以外，还提供了订阅、讨论组、文本渲染、在线文件编辑器、协作图谱(报表)、代码片段分享(Gist)等功能。目前，其注册<br>  用户已经超过350万，托管版本数量也是非常之多，其中不乏知名开源项目 Ruby，on Rails、jQuery、python等。</p></blockquote><p>  <strong>==GitLab==</strong></p><blockquote><p>  GitHub 和 GitLab 都是基于 web 的 Git 仓库，使用起来二者差不多，它们都提供了分享开源项目的平台，为开发团队提供了存储、分享、发布和合作开发项目的中心化云存储的场所。</p><p>  GitHub 作为开源代码库，拥有超过 900万的开发者用户，目前仍然是最火的开源项目托管平台，GitHub 同时提供公共仓库和私有仓库，但如果使用私有仓库，是需要付费的。</p><p>  GitLab 解决了这个问题，你可以在上面创建<strong>私人的免费仓库</strong>。 GitLab 让开发团队对他们的代码仓库拥有更多的控制，相比较GitHub , 它有不少特色：</p><p>  (1) 允许免费设置仓库权限；</p><p>  (2) 允许用户选择分享一个 project 的部分代码；</p><p>  (3) 允许用户设置 project 的获取权限，进一步提升安全性；</p><p>  (4) 可以设置获取到团队整体的改进进度；</p><p>  (5) 通过innersourcing 让不在权限范围内的人访问不到该资源；</p><p>  所以，从代码的私有性上来看，GitLab是一个更好的选择。但是对于开源项目而言，GitHub 依然是代码托管的首选。</p></blockquote><p>  <strong>==Gitee(码云)==</strong></p><blockquote><p>  码云（Gitee）是 OSCHINA 推出的代码托管协作开发平台，支持 Git 和 SVN,提供免费的私有仓库托<br>  管。2016 年推出企业版，提供企业级代码托管服务，成为开发领域领先的 SaaS 服务提供商。</p><p>  Gitee除了访问速度更快以外，Gitee 还提供了<strong>免费的私有仓库</strong>供个人开发者使用。同时，Gitee 也有着国内数一数二的开源生态，这里有非常多的优秀开源项目和开发者，你可以在这里和他们无障碍地沟通交流，不管是找开源项目还是分享自己的开源项目，Gitee 都是极佳的选择。</p><p>  作为国内代码托管平台的佼佼者，目前已经有超过 500 万名开发者在 Gitee 上托管了 1000 余万个代码仓库，而其提供了研发管理、代码托管、文档管理服务的企业版的服务客户也超过了 10 万家。</p></blockquote></blockquote><p>下面针对Gitee说一下，Git远程服务器的使用</p><h3 id="Gitee的使用"><a href="#Gitee的使用" class="headerlink" title="Gitee的使用"></a>Gitee的使用</h3><h4 id="Gitee的一些基本概念"><a href="#Gitee的一些基本概念" class="headerlink" title="Gitee的一些基本概念"></a>Gitee的一些基本概念</h4><ol><li>仓库（<strong>Repository</strong>）<br>仓库即你的项目，你想在github上开源一个项目，那就必须要新建一个repository,如果你开源的项目<br>多，那你拥有的仓库也就很多</li><li>收藏（<strong>star</strong>）<br>仓库主页的star按钮，意思是收藏项目的人数。</li><li>复制克隆项目（<strong>fork</strong>）<br>在原项目的基础上新增代码和结构，也可以理解成拿别人的代码进行二次加工。Fork后，会在自己账号下，生成自己的相同仓库</li><li>发起请求（<strong>pull request</strong>，简称<strong>PR</strong>）<br>这个是基于fork的，当其他人改进完代码后，想将这个项目合并到原项目，则这个时候会给你发起一个pull request。如果接受了请求，这个时候就可以拥有改进的项目了。</li><li>关注（<strong>watch</strong>）<br>即观察，可以随时看到被关注项目的更新</li><li>事务卡片（<strong>Issue</strong>）<br>发现代码有bug,但是目前还没成型，需要讨论时使用。当别人发现你的问题时，会提个lssue。</li><li>Gitee主页<br>账号创建完后，点击导航栏gitee图标即可进入主页。左侧显示功能列表，右侧显示仓库动态。</li><li>仓库主页<br>仓库主页主要显示项目的信息，如:代码，版本，收藏，关注，fork等</li></ol><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>注册登录后，就可以创建仓库了，一个本地git库对应一个远程开源项目。</p><p><img src="https://i.loli.net/2020/11/27/PRDvlxUNTSz5oeK.png" alt=""></p><p><img src="https://i.loli.net/2020/11/27/9vxr7ZfkeudGJtS.png" alt=""></p><h4 id="本地Git操作远程仓库"><a href="#本地Git操作远程仓库" class="headerlink" title="本地Git操作远程仓库"></a>本地Git操作远程仓库</h4><p>本地配置gitee的一些配置教程可以参考<a href="https://gitee.com/help/articles/4107" target="_blank" rel="noopener">https://gitee.com/help/articles/4107</a>。</p><p>设置登录的账户信息: 用户名和邮箱地址是本地git客户端的一个变量，每次commit都会用用户名和邮箱纪录。<br>一些配置的方法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置用户名: </span></span><br><span class="line">git config --global user.name <span class="string">'用户名'</span></span><br><span class="line"><span class="comment">#设置邮箱: </span></span><br><span class="line">git config --global user.email <span class="string">'邮箱'</span></span><br></pre></td></tr></table></figure><blockquote><p>  查看git的配置: </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure></blockquote><p>git管理远程仓库的常用指令：</p><ul><li><code>git clone 仓库地址</code>：将远程仓库的项目复制到本地</li><li><code>git push</code>：将本地仓库提交到远程（注意先提交到缓存区，再提交到仓库，最后提交远程，也就是在给commit 之后再 push）</li><li><code>git pull</code>：更新本地仓库至最新改动</li></ul><h4 id="IDEA配置Git-Gitee"><a href="#IDEA配置Git-Gitee" class="headerlink" title="IDEA配置Git+Gitee"></a>IDEA配置Git+Gitee</h4><ol><li><p>IDEA配置Git客户端:</p><p>File - Settings - Version Control - Git</p><p>配置Path to Git Executable，就是git的所在路径<br><img src="https://i.loli.net/2020/11/27/9y3dg8eNqY7moTj.png" alt="image-20201127151002861"></p></li><li><p>下载gitee插件（GitHub等同理）</p><p>File - Settings - Plugins</p><p>搜索Gitee，然后点击Install。安装完毕后重启IDEA。<br><img src="https://i.loli.net/2020/11/27/DnQpXw5NEAZL4M9.png" alt=""></p></li><li><p>添加信息</p><p>File - Setting - Version Control - Gitee<img src="https://i.loli.net/2020/11/27/OCtmyaiE2xg4Qs8.png" alt=""></p><p>填写login和password，login填写邮箱。</p></li><li><p>上传和下载</p><p>上传：VCS - Import Into Version Control - Share Project To Gitee</p><p>下载：新建项目时：Get from Version Control</p><p><img src="https://i.loli.net/2020/11/27/M91ldHjWUvSN2nk.png" alt=""></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;版本控制概述&quot;&gt;&lt;a href=&quot;#版本控制概述&quot; class=&quot;headerlink&quot; title=&quot;版本控制概述&quot;&gt;&lt;/a&gt;版本控制概述&lt;/h2&gt;&lt;p&gt;版本控制是实现开发团队&lt;strong&gt;并行开发、提高开发效率&lt;/strong&gt;的基础。其目的在于对软件开发进程中文件或目录的发展过程提供有效的追踪手段，保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和相互覆盖，通过对版本库的访问控制避免未经授权的访问和修改，达到有效保护企业软件资产和知识产权的目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="工具使用" scheme="https://www.pengspace.top/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="Git" scheme="https://www.pengspace.top/tags/Git/"/>
    
      <category term="版本控制" scheme="https://www.pengspace.top/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>smartupload简单实现文件上传</title>
    <link href="https://www.pengspace.top/2020/12/12/smartupload%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>https://www.pengspace.top/2020/12/12/smartupload%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2020-12-12T06:01:24.000Z</published>
    <updated>2020-12-12T06:02:53.759Z</updated>
    
    <content type="html"><![CDATA[<p>文件上传实质上就是客户端发起请求，将一个大数据IO流上传到服务器</p><a id="more"></a><p><strong>步骤：</strong></p><p><strong>1.将jar包添加到项目中：smartupload.jar</strong></p><p><strong>2.创建smartupload对象并初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建对象</span></span><br><span class="line">SmartUpload smartUpload = <span class="keyword">new</span> SmartUpload();</span><br><span class="line"><span class="comment">//获得jsp的pageContent对象并初始化</span></span><br><span class="line">PageContext pageContext = JspFactory.getDefaultFactory().getPageContext(<span class="keyword">this</span>, req, resp, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="number">1024</span>, <span class="keyword">true</span>);</span><br><span class="line">smartUpload.initialize(pageContext);</span><br><span class="line"><span class="comment">//编码</span></span><br><span class="line">smartUpload.setCharset(<span class="string">"utf-8"</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>getPageContext()方法</strong></p><p>  <img src="https://i.loli.net/2020/11/26/bJ7gEMCIVv83SDa.png" alt=""></p><p>  参数的含义</p><p>  <img src="https://i.loli.net/2020/11/26/hJzWE5XqgsLcpG3.png" alt=""></p></blockquote><p><strong>3.调用SmartUpload对象的upload()方法上传文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件上传</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    smartUpload.upload();</span><br><span class="line">&#125; <span class="keyword">catch</span> (SmartUploadException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>截止目前，文件就被上传到了服务器，但服务器并没有保存</p><p><strong>4. 保存文件到指定位置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*保存文件*/</span></span><br><span class="line"><span class="comment">//得到smartUpload对象中文件数组的第1个文件</span></span><br><span class="line">File file = smartUpload.getFiles().getFile(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//得到该文件的信息</span></span><br><span class="line">String fileName = file.getFileName();</span><br><span class="line"><span class="comment">//指定存储路径</span></span><br><span class="line">String path = <span class="string">"uploadfile/"</span>+fileName;</span><br><span class="line"><span class="comment">//存储</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    file.saveAs(path,SmartUpload.SAVE_VIRTUAL);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SmartUploadException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，数据文件已经被存放到了某个指定路径下。接下来就可以自己决定如何在前端显示。</p><blockquote><p>  <code>public void saveAs(String path, int optionSaveAs)</code></p><p>  其中，path是另存的文件路径，optionSaveAs是另存的选项，该选项有三值：</p><ul><li><p>SAVEAS_PHYSICAL表明以操作系统的根目录为文件根目录另存文件，</p></li><li><p>SAVEAS_VIRTUAL表明以Web应用程序的根目录为文件根目录另存文件，</p></li><li><p>SAVEAS_AUTO则表示让组件决定，</p><p>当Web应用程序的根目录存在另存文件的目录时，它默认会选择SAVEAS_VIRTUAL，否则会选择SAVEAS_PHYSICAL。</p></li></ul></blockquote><blockquote><p>  smartupload常用方法</p><p>  <img src="https://i.loli.net/2020/11/26/3AyUuBT54MoI1sP.png" alt="image-20201126225644272"></p></blockquote><blockquote><p>  smaryupload中文文档：</p><p>  <a href="https://www.cnblogs.com/mycodelife/archive/2009/04/26/1444132.html" target="_blank" rel="noopener">https://www.cnblogs.com/mycodelife/archive/2009/04/26/1444132.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文件上传实质上就是客户端发起请求，将一个大数据IO流上传到服务器&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="文件上传" scheme="https://www.pengspace.top/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="smartupload" scheme="https://www.pengspace.top/tags/smartupload/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂AJAX技术</title>
    <link href="https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82AJAX%E6%8A%80%E6%9C%AF/"/>
    <id>https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82AJAX%E6%8A%80%E6%9C%AF/</id>
    <published>2020-12-12T05:58:17.000Z</published>
    <updated>2020-12-12T06:00:36.022Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AJAX简介"><a href="#AJAX简介" class="headerlink" title="AJAX简介"></a>AJAX简介</h2><p>AJAX（Asynchronous JavaScript and XML）即异步的 JavaScript 和 XML。AJAX 是与服务器交换数据，在不重新加载整个页面的情况下更新部分网页的技术。</p><a id="more"></a><p>ajax并非一种新的技术，而是几种原有技术的结合体。它由下列技术组合而成：</p><blockquote><ol><li><p>使用CSS和XHTML来表示。</p></li><li><p>使用DOM模型来交互和动态显示。</p></li><li><p>使用XMLHttpRequest来和服务器进行异步通信。</p></li><li><p>使用javascript来绑定和调用。</p></li></ol></blockquote><p><strong>AJAX 的核心是 XMLHttpRequest 对象。</strong></p><blockquote><p>  不同的浏览器创建 XMLHttpRequest 对象的方法是有差异的。</p><p>  IE 浏览器使用 ActiveXObject，而其他的浏览器使用名为 XMLHttpRequest 的 JavaScript 内建对象</p></blockquote><p><strong>AJAX属于前端技术，通过JS代码来编写。</strong></p><h2 id="AJAX工作原理"><a href="#AJAX工作原理" class="headerlink" title="AJAX工作原理"></a>AJAX工作原理</h2><p>Ajax的工作原理相当于在用户和服务器之间加了一个中间层(AJAX引擎)，使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器。像一些数据验证和数据处理等都交给Ajax引擎自己来做，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。</p><p><img src="https://i.loli.net/2020/11/26/SCFUDwdnKA8Mq1b.png" alt=""></p><p>浏览器的普通交互方式</p><p><img src="https://i.loli.net/2020/11/26/vYZBjVX8T1kHieA.jpg" alt=""></p><p>浏览器的AJAX交互方式</p><p><img src="https://i.loli.net/2020/11/26/sweN5ixgVCjq3KZ.jpg" alt="a3"></p><p>有了AJAX层，用户页面可以不必等待服务器返回响应才可以进行下一个请求，而是以异步的方式，不同的AJAX请求互相不需要等待，极大的提高了效率。</p><h2 id="XMLHttpRequest对象常用属性和方法"><a href="#XMLHttpRequest对象常用属性和方法" class="headerlink" title="XMLHttpRequest对象常用属性和方法"></a>XMLHttpRequest对象常用属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>onreadystatechange 属性</strong></p><p>onreadystatechange 属性存有处理服务器响应的函数。 下面的代码定义一个空的函数，可同时对<br>onreadystatechange 属性进行设置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>readyState属性</strong></p><p>readyState 属性存有服务器响应的状态信息。每当 readyState 改变时，onreadystatechange 函数就会被执行。<br>readyState 属性可能的值：</p><p><img src="https://i.loli.net/2020/11/26/bQ8muwY2EXLc4PH.png" alt="image-20201126212659531"></p><p>向上面的 onreadystatechange 函数添加一条 If 语句，来测试我们的响应是否已完成(意味着可获得数据)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line"><span class="comment">//从服务器的response获得数据</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>responseText 属性</strong></p><p>可以通过 responseText 属性来取回由服务器返回的数据。 在下面的代码中，将时间文本框的值设置为等于responseText：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="built_in">document</span>.myForm.time.value = xmlHttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其它属性如下：</p><p><img src="https://i.loli.net/2020/11/26/IYs3p7mf9ckCJXi.png" alt=""></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>open() 方法</strong></p><p>open() 有三个参数。第一个参数定义发送请求所使用的方法，第二个参数规定服务器端脚本的URL，第三个参数规定是否对请求进行异步地处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.open(<span class="string">"GET"</span>,<span class="string">"test.jsp?key=xxx&amp;key=xxx"</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>send() 方法</strong></p><p>send() 方法将请求送往服务器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlHttp.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  open和send方法中参数的使用</p><p>  <a href="https://blog.csdn.net/weixin_40292626/article/details/78708160" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40292626/article/details/78708160</a></p></blockquote><p>其他方法如下：</p><p><img src="https://i.loli.net/2020/11/26/HQK42zNWruhafdR.png" alt=""></p><h2 id="AJAX实现方法"><a href="#AJAX实现方法" class="headerlink" title="AJAX实现方法"></a>AJAX实现方法</h2><h3 id="原生JS方法"><a href="#原生JS方法" class="headerlink" title="原生JS方法"></a>原生JS方法</h3><p>实现AJAX的步骤如下：</p><ol><li>创建XMLHttpRequest对象。</li><li>设置请求方式。</li><li>调用回调函数。</li><li>发送请求。</li></ol><p><strong>1. 创建XMLHttpRequest对象</strong></p><p>一般我们手写AJAX的时候，首先要判断该浏览器是否支持XMLHttpRequest对象，如果支持则创建该对象，如果不支持则创建ActiveX对象。JS代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一步：创建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> xmlHttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//非IE</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">    <span class="comment">//IE</span></span><br><span class="line">    xmlHttp = <span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2. 设置请求方式</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二步：设置和服务器端交互的相应参数，向路径http://localhost:8080/JsLearning3/getAjax准备发送数据</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="string">"http://localhost:8080/JsLearning3/getAjax"</span>;</span><br><span class="line">xmlHttp.open(<span class="string">"POST"</span>, url, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>3. 调用回调函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三步：回调函数</span></span><br><span class="line">xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (xmlHttp.status == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> obj = <span class="built_in">document</span>.getElementById(id);</span><br><span class="line">            obj.innerHTML = xmlHttp.responseText;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(<span class="string">"AJAX服务器返回错误！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  <code>xmlHttp.status == 200</code>：200指服务器状态码：代表正确。</p><p>  更多状态码可以看我前面讲JSP的那篇文章：</p><p>  <a href="https://blog.csdn.net/qq_40932102/article/details/110235296" target="_blank" rel="noopener">https://blog.csdn.net/qq_40932102/article/details/110235296</a></p></blockquote><p><strong>4. 发送请求</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第四步：设置发送请求的内容和发送报送。然后发送请求</span></span><br><span class="line"><span class="keyword">var</span> uname= <span class="built_in">document</span>.getElementsByName(<span class="string">"userName"</span>)[<span class="number">0</span>].value;</span><br><span class="line"><span class="keyword">var</span> upass= <span class="built_in">document</span>.getElementsByName(<span class="string">"userPass"</span>)[<span class="number">0</span>].value ;</span><br><span class="line"><span class="comment">// 增加time随机参数，防止读取缓存</span></span><br><span class="line"><span class="keyword">var</span> params = <span class="string">"userName="</span> + uname+ <span class="string">"&amp;userPass="</span> +upass+ <span class="string">"&amp;time="</span> + <span class="built_in">Math</span>.random();</span><br><span class="line"><span class="comment">// 向请求添加HTTP头，POST如果有数据一定要加</span></span><br><span class="line">xmlHttp.setRequestHeader(<span class="string">"Content-type"</span>, <span class="string">"application/x-www-form-urlencoded;charset=UTF-8"</span>);</span><br><span class="line">xmlHttp.send(params);</span><br></pre></td></tr></table></figure><p>如果需要像 HTML 表单那样 POST 数据，要使用 setRequestHeader() 来添加HTTP头避免乱码。然后在 send() 方法中传入希望发送的数据。</p><h3 id="JQuery实现Ajax"><a href="#JQuery实现Ajax" class="headerlink" title="JQuery实现Ajax"></a>JQuery实现Ajax</h3><p>使用原生js的方式实现ajax，步骤繁琐，方法、属性、常用值较多不好记忆。</p><p>使用JQuery实现Ajax只需要调用JQuery封装好的ajax()方法即可，它可以通过发送 HTTP请求加载远程数据，是 jQuery 最底层的 Ajax 实现，具有较高灵活性。语法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:请求地址</span><br><span class="line">    type:<span class="string">"get | post | put | delete "</span> 默认是<span class="keyword">get</span>,</span><br><span class="line">    data:请求参数 &#123;<span class="string">"id"</span>:<span class="string">"123"</span>,<span class="string">"pwd"</span>:<span class="string">"123456"</span>&#125;,</span><br><span class="line">    dataType:请求数据类型<span class="string">"html | text | json | xml | script | jsonp "</span>,</span><br><span class="line">    success:<span class="function"><span class="keyword">function</span>(<span class="params">data,dataTextStatus,jqxhr</span>)</span>&#123; &#125;,<span class="comment">//请求成功时</span></span><br><span class="line">    error:<span class="function"><span class="keyword">function</span>(<span class="params">jqxhr,textStatus,error</span>)//请求失败时</span></span><br><span class="line"><span class="function">&#125;)</span></span><br></pre></td></tr></table></figure><p>JQuery中也有简单的get()和post()方法可以使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>(url,data,function(result) &#123; <span class="comment">//通过远程 HTTP GET 请求载入信息。</span></span><br><span class="line"><span class="comment">//将服务器返回的数据显示到页面的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">$.post(url,data,<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123; <span class="comment">//通过远程 HTTP POST 请求载入信息。</span></span><br><span class="line">    <span class="comment">//将服务器返回的数据显示到页面的代码</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//url:请求的路径</span></span><br><span class="line"><span class="comment">//data:发送的数据</span></span><br><span class="line"><span class="comment">//result：自动接收从servlet打印流打印的字符串，默认是String，不能接收JSON格式</span></span><br></pre></td></tr></table></figure><p><strong>返回的数据都被封装到了result变量里，get/post()中返回时text类型，ajax()中可以指定返回的数据类型</strong></p><p>根据传回的数据格式选择不同的方法，如果是简单的字符串，建议使用get/post()，如果传回的是复杂数据，<strong>以JSON格式传回，只能使用ajax（）</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AJAX简介&quot;&gt;&lt;a href=&quot;#AJAX简介&quot; class=&quot;headerlink&quot; title=&quot;AJAX简介&quot;&gt;&lt;/a&gt;AJAX简介&lt;/h2&gt;&lt;p&gt;AJAX（Asynchronous JavaScript and XML）即异步的 JavaScript 和 XML。AJAX 是与服务器交换数据，在不重新加载整个页面的情况下更新部分网页的技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="JQuery" scheme="https://www.pengspace.top/tags/JQuery/"/>
    
      <category term="AJAX" scheme="https://www.pengspace.top/tags/AJAX/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式和三层架构</title>
    <link href="https://www.pengspace.top/2020/12/12/MVC%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    <id>https://www.pengspace.top/2020/12/12/MVC%E6%A8%A1%E5%BC%8F%E5%92%8C%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/</id>
    <published>2020-12-12T05:56:15.000Z</published>
    <updated>2020-12-12T05:57:44.746Z</updated>
    
    <content type="html"><![CDATA[<p>为了便于管理繁杂的代码，以及降低代码的耦合性，于是衍生出了MVC模式，可以使开发者思路更加清晰，且代码更加利于维护。</p><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>Web MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样，Web MVC标准架构如下图所示：</p><p><img src="https://i.loli.net/2020/11/26/VAHzbtaiFC1yDc3.png" alt="image-20201126203504738"></p><a id="more"></a><p><code>M(Model) 模型</code> : 应用程序的核心功能，管理这个模块中用的数据和值，<strong>包含Dao层和Bean层</strong></p><p><code>V(View )视图</code>: 视图提供模型的展示，管理模型如何显示给用户，它是应用程序的外观，<strong>一般指JSP或HTML前端页面</strong></p><p><code>C(Controller)控制器</code>: 对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽。<strong>包含Servlet层和Service层</strong></p><p>MVC用于将web（UI）层进行职责解耦</p><h2 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h2><p>通常意义上的三层架构就是将整个业务应用划分为：<strong>表现层（UI）、业务逻辑层（BLL）、数据访问层（DAL）</strong>。区分层次的目的即为了「高内聚，低耦合」的思想。</p><ul><li>表现层（UI）：通俗讲就是展现给用户的界面，即用户在使用一个系统的时候他的所见所得。 jsp/html</li><li>业务逻辑层（BLL）：针对具体问题的操作，也可以说是对数据层的操作，对数据业务逻辑处理。<br>servlet，service</li><li>数据访问层（DAL）：该层所做事务直接操作数据库，针对数据的增添、删除、修改、更新、查找等。dao</li></ul><blockquote><p>  表现层实现的代表作品是Struts，springmvc框架，</p><p>  业务层实现的代表作品是Spring</p><p>  持久层实现的代表作品是Hibernate,mybatis。</p></blockquote><p>层就相当于一个黑盒子，我们不用知道它内部怎么实现，只需要知道如何去调用它就行了。每层只与上下相邻的两层打交道。当一层内部由于技术变迁发生变化时，只要接口不变，其他层不用做任何改变。分层之后灵活性提高，也便于团队分工开发。</p><h2 id="三层架构和MVC的区别与联系"><a href="#三层架构和MVC的区别与联系" class="headerlink" title="三层架构和MVC的区别与联系"></a>三层架构和MVC的区别与联系</h2><p><img src="https://i.loli.net/2020/11/26/A95vVS3qPnzY82y.jpg" alt=""></p><p>MVC是 Model-View-Controller，严格说这三个加起来以后才是三层架构中的UI层，也就是说，MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。</p><p>MVC可以是三层中的一个表现层框架，属于表现层。三层和mvc可以共存。</p><p>三层是基于业务逻辑来分的，而MVC是基于页面来分的。</p><p>MVC主要用于表现层，三层主要用于体系架构，三层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，(Model View Controller)模型－视图－控制器</p><p>MVC是表现模式（Presentation Pattern），三层架构是典型的架构模式（Architecture Pattern）</p><p>三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是相互协作关系。即使将MVC当作架构模式，也不是分层模式。</p><p>MVC和三层架构基本没有可比性，是应用于不同领域的技术。</p><blockquote><p>  <a href="https://www.cnblogs.com/zhhh/archive/2011/06/10/2077519.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhhh/archive/2011/06/10/2077519.html</a>，这篇文章对MVC和三层的关系是这样说的：</p><p>  <strong>三层是三层，MVC是MVC，它们毫无关系的。</strong></p><p>  <strong>三层</strong>是从整个应用程序架构的角度来分的三层（如果程序需要，还可以分多层）。</p><p>  三层是为了解决整个应用程序中各个业务操作过程中不同阶段的代码封装的问题，为了使程序员更加专注的处理某阶段的业务逻辑。</p><p>  比如将数据库操作代码封装到一层中，提供一些方法根据参数直接返回用户需要的相应数据，这样在处理具体的业务逻辑的时候，就不用关心数据的存储问题了。</p><p>  <strong>MVC</strong>是在应用程序（BS结构）的视图层划分出来的不同功能的几个模块。</p><p>  MVC主要是为了解决应用程序用户界面的样式替换问题，把展示数据的 HTML 页面尽可能的和业务代码分离。MVC把纯净的界面展示逻辑（用户界面）独立到一些文件中（Views），把一些和用户交互的程序逻辑（Controller）单独放在一些文件中，在 Views 和 Controller 中传递数据使用一些专门封装数据的实体对象，这些对象，统称为Models。</p><p>  之所以说MVC和三层毫无关系，是因为它们二者使用范围不同：三层可以应用于任何语言、任何技术的应用程序；而MVC只是为了解决BS应用程序视图层各部分的耦合关系。它们互不冲突，可以同时存在，也可根据情况使用其中一种。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了便于管理繁杂的代码，以及降低代码的耦合性，于是衍生出了MVC模式，可以使开发者思路更加清晰，且代码更加利于维护。&lt;/p&gt;
&lt;h2 id=&quot;MVC-模式&quot;&gt;&lt;a href=&quot;#MVC-模式&quot; class=&quot;headerlink&quot; title=&quot;MVC 模式&quot;&gt;&lt;/a&gt;MVC 模式&lt;/h2&gt;&lt;p&gt;Web MVC中的M(模型)-V(视图)-C(控制器)概念和标准MVC概念一样，Web MVC标准架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/26/VAHzbtaiFC1yDc3.png&quot; alt=&quot;image-20201126203504738&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="MVC" scheme="https://www.pengspace.top/tags/MVC/"/>
    
      <category term="三层架构" scheme="https://www.pengspace.top/tags/%E4%B8%89%E5%B1%82%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>过滤器(Filter)和监听器(Listener)</title>
    <link href="https://www.pengspace.top/2020/12/12/%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8-Listener/"/>
    <id>https://www.pengspace.top/2020/12/12/%E8%BF%87%E6%BB%A4%E5%99%A8-Filter-%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8-Listener/</id>
    <published>2020-12-12T05:54:10.000Z</published>
    <updated>2020-12-12T05:55:31.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="过滤器-Filter"><a href="#过滤器-Filter" class="headerlink" title="过滤器(Filter)"></a>过滤器(Filter)</h2><h3 id="过滤器定义"><a href="#过滤器定义" class="headerlink" title="过滤器定义"></a>过滤器定义</h3><p>过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理.</p><p><img src="https://i.loli.net/2020/11/26/IPunhxFN9Vsjbqo.png" alt=""></p><p>过滤器的特点：在servlet之前和之后都会被执行</p><a id="more"></a><h3 id="Filter使用"><a href="#Filter使用" class="headerlink" title="Filter使用"></a>Filter使用</h3><ol><li><p>创建一个类<strong>实现Fiter接口</strong>（javax.servlet.Filter）例如：以下代码是简单的字符编码过滤器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"encodingFilter"</span>,urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//具体的执行逻辑</span></span><br><span class="line">        req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resp.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">        resp.setContentType(<span class="string">"text/html;charset = utf-8"</span>);</span><br><span class="line">        <span class="comment">//执行完过滤跳转到原请求目的地</span></span><br><span class="line">        chain.doFilter(req,resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关闭过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>部署Filter过滤器</strong></p><p><strong>方式一：在web.xml文件中部署</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>过滤器名称<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>过滤器所在的路径<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>过滤器名称<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>需要过滤的资源或请求<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式二：通过@WebFilter注解部署</strong></p><p>如上面字符编码过滤器代码所示。</p><p>@WebFilter常用属性如下：</p><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>filterName</td><td>String</td><td>指定过滤器的 name 属性，等价于</td></tr><tr><td>value</td><td>String[]</td><td>该属性等价于 urlPatterns 属性。但是两者不应该同时使用。</td></tr><tr><td>urlPatterns</td><td>String[]</td><td>指定一组过滤器的 URL 匹配模式。等价于标签。</td></tr><tr><td>servletNames</td><td>String[]</td><td>指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中 的取值。</td></tr></tbody></table></li></ol><h3 id="Fiter使用场景"><a href="#Fiter使用场景" class="headerlink" title="Fiter使用场景"></a>Fiter使用场景</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.防止用户未登录就执行后续操作</span><br><span class="line">  String name=(String)session.getAttribute("key");</span><br><span class="line">  if(name==null)&#123;</span><br><span class="line">  //跳转到登录页面</span><br><span class="line">  &#125;</span><br><span class="line">2.设置编码方式--统一设置编码</span><br><span class="line">3.加密解密(密码的加密和解密)</span><br><span class="line">4.非法文字筛选</span><br><span class="line">5.下载资源的限制</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>##监听器(Listener)</p><h3 id="监听器定义及分类"><a href="#监听器定义及分类" class="headerlink" title="监听器定义及分类"></a>监听器定义及分类</h3><p>监听器就是监听某个域对象的的状态变化的组件。</p><blockquote><p>  监听器的相关概念：</p><ul><li>事件源：被监听的对象(三个域对象request、session、servletContext) </li><li>监听器：监听事件源对象事件源对象的状态的变化都会触发监听器 </li><li>注册监听器：将监听器与事件源进行绑定 </li><li>响应行为：监听器监听到事件源的状态变化时所涉及的功能代码（程序员编写代码）</li></ul></blockquote><p><strong>分类：</strong></p><p>第一维度按照被监听的对象划分：ServletRequest域、HttpSession域、ServletContext域 </p><p>第二维度按照监听的内容分：监听域对象的创建与销毁的、监听域对象的属性变化的</p><p><img src="https://i.loli.net/2020/11/26/3Wpr5yiDcYEf2IN.png" alt=""></p><h3 id="监听器使用"><a href="#监听器使用" class="headerlink" title="监听器使用"></a>监听器使用</h3><p> 根据不同的监听域，实现不同的接口来创建Listener监听器。比如我们创建一个类来监听Session对象的创建与销毁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@webListenet</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySessionListener</span> <span class="keyword">implements</span> <span class="title">HttpSessionListener</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"session创建"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionDestroyed</span><span class="params">(HttpSessionEvent se)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"session销毁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>监听器部署</strong></p><p>在web.xml文件中添加以下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>监听器所在的路径<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>                                    </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者使用@WebListener注解</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;过滤器-Filter&quot;&gt;&lt;a href=&quot;#过滤器-Filter&quot; class=&quot;headerlink&quot; title=&quot;过滤器(Filter)&quot;&gt;&lt;/a&gt;过滤器(Filter)&lt;/h2&gt;&lt;h3 id=&quot;过滤器定义&quot;&gt;&lt;a href=&quot;#过滤器定义&quot; class=&quot;headerlink&quot; title=&quot;过滤器定义&quot;&gt;&lt;/a&gt;过滤器定义&lt;/h3&gt;&lt;p&gt;过滤器实际上就是对web资源进行拦截，做一些处理后再交给下一个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/26/IPunhxFN9Vsjbqo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;过滤器的特点：在servlet之前和之后都会被执行&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="filter" scheme="https://www.pengspace.top/tags/filter/"/>
    
      <category term="listener" scheme="https://www.pengspace.top/tags/listener/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂jSP</title>
    <link href="https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82jSP/"/>
    <id>https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82jSP/</id>
    <published>2020-12-12T05:51:56.000Z</published>
    <updated>2020-12-12T05:53:25.366Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h2><p>JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准，在传统的网页HTML文件中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件。</p><a id="more"></a><p>JSP 技术是以 Java 语言作为脚本语言的，JSP 网页为整个服务器端的 Java 库单元提供了一个接口来服务于HTTP的应用程序。</p><p><strong>语法</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">声明标签: &lt;%!变量或者方法声明%&gt;</span><br><span class="line">表达式标签: &lt;%= 表达式%&gt; 在页面上显示的效果</span><br><span class="line">程序代码标签: &lt;%java代码%&gt; 页面上动态展示内容</span><br><span class="line">&lt;!-- html注释内容,查看源码时能看到 --&gt;</span><br><span class="line">&lt;%-- jsp注释,查看页面源码时看不到 --%&gt;</span><br></pre></td></tr></table></figure><p><strong>原理</strong></p><p><font color=red>JSP本质上也是servlet</font></p><p>将jsp文件翻译成java文件并编译成class文件，其中包含的HTML代码以流的方式被响应回浏览器显示</p><blockquote><p>  <strong>JSP中出现的状态码（服务器状态码）</strong>        </p><p>  状态码是指由服务器根据HTTP协议所提交的信息，返回的HTTP头信息代码。</p><table><thead><tr><th>状态码</th><th>消息</th><th>描述</th></tr></thead><tbody><tr><td>100</td><td>Continue</td><td>只有一部分请求被服务器接收，但只要没被服务器拒绝，客户端就会延续这个请求</td></tr><tr><td>101</td><td>Switching Protocols</td><td>服务器交换机协议</td></tr><tr><td>200</td><td>OK</td><td>请求被确认</td></tr><tr><td>201</td><td>Created</td><td>请求时完整的，新的资源被创建</td></tr><tr><td>202</td><td>Accepted</td><td>请求被接受，但未处理完</td></tr><tr><td>300</td><td>Multiple Choices</td><td>一个超链接表，用户可以选择一个超链接并访问，最大支持5个超链接</td></tr><tr><td>301</td><td>Moved Permanently</td><td>被请求的页面已经移动到了新的URL下</td></tr><tr><td>302</td><td>Found</td><td>被请求的页面暂时性地移动到了新的URL下</td></tr><tr><td>303</td><td>See Other</td><td>被请求的页面可以在一个不同的URL下找到</td></tr><tr><td>400</td><td>Bad Request</td><td>服务器无法识别请求</td></tr><tr><td>403</td><td>Forbidden</td><td>禁止访问所请求的页面</td></tr><tr><td>404</td><td>Not Found</td><td>服务器无法找到所请求的页面</td></tr><tr><td>405</td><td>Method Not Allowed</td><td>请求中所指定的方法不被允许</td></tr><tr><td>500</td><td>Internal Server Error</td><td>请求不完整，服务器遇见了出乎意料的状况</td></tr><tr><td>501</td><td>Not Implemented</td><td>请求不完整，服务器不提供所需要的功能</td></tr><tr><td>502</td><td>Bad Gateway</td><td>请求不完整，服务器从上游服务器接受了一个无效的响应</td></tr><tr><td>503</td><td>Service Unavailable</td><td>请求不完整，服务器暂时重启或关闭</td></tr><tr><td>504</td><td>Gateway Timeout</td><td>网关超时</td></tr><tr><td>505</td><td>HTTP Version Not Supported</td><td>服务器不支持所指定的HTTP版本</td></tr></tbody></table></blockquote><h2 id="JSP的内置对象"><a href="#JSP的内置对象" class="headerlink" title="JSP的内置对象"></a>JSP的内置对象</h2><p>JSP中一共预先定义了9个对象，分别为：request、response、session、application、out、<br>pagecontext、config、page、exception</p><ol><li><p><strong>request对象</strong></p><p>该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）<strong>request对象的作用域为一次请求。</strong>所属类型:HttpServletRequest。</p></li><li><p><strong>response对象</strong></p><p>response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，<strong>它只在JSP页面内有效</strong>。所属类型:HttpServletResponse</p></li><li><p><strong>session对象</strong></p><p>session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为<code>&quot;Key/value&quot;</code>。 所属类型:HttpSession</p></li><li><p><strong>application对象</strong></p><p>application 对象可将信息保存在服务器中，直到服务器关闭，application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的「全局变量」。所属类型:ServletContext</p></li><li><p><strong>out 对象</strong></p><p>out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。例如：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">out.print(<span class="string">"&lt;script type='text/javascript'&gt;alert('用户名不存在');location.href='index.jsp'&lt;/script&gt;"</span>);</span><br></pre></td></tr></table></figure></li><li><p><strong>pageContext 对象</strong></p><p>pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用pageContext对象。</p></li><li><p><strong>config 对象</strong></p><p>config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。</p></li><li><p><strong>page 对象</strong></p><p>page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。</p></li><li><p><strong>exception 对象</strong></p><p>exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--先在可能发生错误的页面中添加errorPage属性:--%&gt;</span><br><span class="line">&lt;%@ page pageEncoding=<span class="string">"utf-8"</span> errorPage=<span class="string">"error.jsp"</span> contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%--在error.jsp页面中设置isErrorPage=<span class="string">"true"</span> 的属性--%&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> isErrorPage=<span class="string">"true"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>jsp对象的作用域:</strong></p><p>  pageContext &lt; request  &lt; session &lt; application</p><p>  pageContext :当前页面</p><p>  request:单次请求<br>  session:浏览器访问期间(会话期间)<br>  application:服务器启动期间,所存的数据可以跨浏览器</p></blockquote></li></ol><h2 id="JSP的指令"><a href="#JSP的指令" class="headerlink" title="JSP的指令"></a>JSP的指令</h2><p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p><p>语法格式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">"value"</span> %&gt;</span><br><span class="line">directive：指令名称 attribute 属性名 value:属性值</span><br></pre></td></tr></table></figure><table><thead><tr><th>指令名称</th><th>描述</th></tr></thead><tbody><tr><td>page</td><td>定义网页依赖属性，比如脚本语言、error页面、缓存需求等等</td></tr><tr><td>include</td><td>包含其他文件</td></tr><tr><td>taglib</td><td>引入标签库的定义</td></tr></tbody></table><ol><li><p><strong>page指令</strong></p><p>Page指令为容器提供当前页面的使用说明，一个JSP页面可以包含多个page指令</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page attribute=<span class="string">"value"</span> %&gt;</span><br></pre></td></tr></table></figure><p>page指令的属性</p><table><thead><tr><th>常用属性</th><th>属性值</th><th>属性描述</th></tr></thead><tbody><tr><td>language</td><td>java</td><td>解释该JSP文件时采用的语言，一般为java语言，默认为java</td></tr><tr><td>extends</td><td>任何类的全名</td><td>编译该JSP文件时继承哪个类，JSP为Servlet，因此当指明继承普通类时需要实现Servlet的init、destroy等方法</td></tr><tr><td>import</td><td>引入该JSP中用到的类、包等</td><td>import是唯一可以声明多次的page指令属性，中间用英文逗号隔开&lt;%@page import=包名.类名，包名.类名%&gt;</td></tr><tr><td>session</td><td>true/false</td><td>该JSP内是否内置Session对象，如果为true，则内置Session对象，可直接使用，否则反之，默认为true</td></tr><tr><td>autoFlush</td><td>true/false</td><td>是否运行缓存，如果为true，则使用out.println()等方法输出的字符串并不是立刻到达客户端服务器的，而是暂时存到缓存里，缓存满了或者程序行完毕或者执行out.flush()操作时才到客户端，默认为true。</td></tr><tr><td>buffer</td><td>none或者数字KB</td><td>指定缓存大小，当autoFlush设为true时有效，例如&lt;%@ page buffer=10kb%&gt;</td></tr><tr><td>isThreadSafe</td><td>true/false</td><td>是否线程安全，如果为true，则运行多个线程同时运行该jsp程序，否则只运行一个线程，其余线程等待，默认为false</td></tr><tr><td>isErrorPage</td><td>true/false</td><td>指定该页面是否为错误显示页面，如果为true，则该JSP内置有一个Exception对象 exception，可直接使用，否则没有，默认为false</td></tr><tr><td>errorPage</td><td>某个JSP页面的相对路径</td><td>指明一个错误页面，如果该JSP程序抛出一个未捕捉的异常，则转到 errorPage指定的页面，errorPage指定的页面通常isErrorPage属性为true，且内置的exception对象为未捕捉的异常</td></tr><tr><td>contentType</td><td>有效的文档类型</td><td>客户端浏览器根据该属性判断文档类型，例如 HTML格式为text/html、纯文本格式为text/plain、JPG图像为image/jpeg、GIF图像为image/gif、WORD文档为application/msword，该属性常跟着charset设置编码一起，作用是通知服务器和浏览器都使用同一个码表</td></tr><tr><td>pageEncoding</td><td>字符集编码如：UTF-8</td><td>设置页面字符集编码</td></tr></tbody></table></li><li><p><strong>Include指令</strong></p><p>JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"文件相对 url 地址"</span> %&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>Taglib指令</strong></p><p>JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。</p><p>Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">"uri"</span> prefix=<span class="string">""</span> %&gt;</span><br></pre></td></tr></table></figure><p>uri属性确定标签库的位置，prefix属性指定标签库的前缀(可自定义)。</p></li></ol><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>EL（Expression Language）：简化对象和变量访问的一种语法</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">语法格式：$&#123;需要取出数据的键值&#125;</span><br></pre></td></tr></table></figure><p>当表达式没有指定变量或者对象的范围时，那么容器会依次从pageContext—&gt;request—&gt;session—&gt;application中查找该变量或对象，我们可以通过隐含对象获得指定作用域的值</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pageScope.key&#125; 用于获取当前页面的属性值</span><br><span class="line">$&#123;requestScope.key&#125; 用于获取请求范围的属性值</span><br><span class="line">$&#123;sessionScope.key&#125; 用于获取会话范围的属性值</span><br><span class="line">$&#123;applicationScope.key&#125; 用于获取程序范围的属性值</span><br></pre></td></tr></table></figure><p><font color = red>EL表达式不可以直接取出变量，只能通过将变量放入作用域的方式</font></p><p><strong>EL中基础操作符</strong></p><p>EL表达式支持大部分Java所提供的算术和逻辑操作符：</p><table><thead><tr><th align="left"><strong>操作符</strong></th><th align="left"><strong>描述</strong></th></tr></thead><tbody><tr><td align="left">.</td><td align="left">访问一个Bean属性或者一个映射条目</td></tr><tr><td align="left">[]</td><td align="left">访问一个数组或者链表的元素</td></tr><tr><td align="left">( )</td><td align="left">组织一个子表达式以改变优先级</td></tr><tr><td align="left">+</td><td align="left">加</td></tr><tr><td align="left">-</td><td align="left">减或负</td></tr><tr><td align="left">*</td><td align="left">乘</td></tr><tr><td align="left">/ or div</td><td align="left">除</td></tr><tr><td align="left">% or mod</td><td align="left">取模</td></tr><tr><td align="left">== or eq</td><td align="left">测试是否相等</td></tr><tr><td align="left">!= or ne</td><td align="left">测试是否不等</td></tr><tr><td align="left">&lt; or lt</td><td align="left">测试是否小于</td></tr><tr><td align="left">&gt; or gt</td><td align="left">测试是否大于</td></tr><tr><td align="left">&lt;= or le</td><td align="left">测试是否小于等于</td></tr><tr><td align="left">&gt;= or ge</td><td align="left">测试是否大于等于</td></tr><tr><td align="left">&amp;&amp; or and</td><td align="left">测试逻辑与</td></tr><tr><td align="left">|| or or</td><td align="left">测试逻辑或</td></tr><tr><td align="left">! or not</td><td align="left">测试取反</td></tr><tr><td align="left">empty</td><td align="left">测试是否空值</td></tr></tbody></table><blockquote><p>  <strong>关于EL表达式更多内容可以参考：<a href="https://www.runoob.com/jsp/jsp-expression-language.html" target="_blank" rel="noopener">https://www.runoob.com/jsp/jsp-expression-language.html</a></strong></p></blockquote><h2 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h2><p>JSTL(JSP标准标签库)是一个JSP标签集合，它封装了JSP应用的通用核心功能。</p><p>JSTL支持通用的、结构化的任务，比如迭代，条件判断，XML文档操作，国际化标签，SQL标签。 除了这些，它还提供了一个框架来使用集成JSTL的自定义标签。</p><p>根据JSTL标签所提供的功能，可以将其分为5个类别。核心标签、格式化标签、sql标签、xml标签、jstl函数</p><blockquote><p>  要使用JSTL首先需要导入jar包</p><p>  下载 jakarta-taglibs-standard-1.1.2.zip 包并解压，将 jakarta-taglibs-standard-1.1.2/lib/ 下的两个 jar 文<br>  件：standard.jar 和 jstl.jar 文件拷贝到 /WEB-INF/lib/ 下，并配置。</p></blockquote><p><strong>语法：</strong></p><ol><li><p>在JSP页面中引入<code>&lt;%@ taglib prefix=”页面使用的名称” uri=”功能范围的路径”%&gt;</code></p><table><thead><tr><th>功能范围</th><th>说明</th><th>Uri</th><th>前缀prefix</th></tr></thead><tbody><tr><td>core</td><td>核心标签</td><td><a href="http://java.sun.com/jsp/jstl/core" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/core</a></td><td>c</td></tr><tr><td>i18n</td><td>格式化标签</td><td><a href="http://java.sun.com/jsp/jstl/fmt" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/fmt</a></td><td>fmt</td></tr><tr><td>sql</td><td>sql标签</td><td><a href="http://java.sun.com/jsp/jstl/sql" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/sql</a></td><td>sql</td></tr><tr><td>xml</td><td>xml标签</td><td><a href="http://java.sun.com/jsp/jstl/xml" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/xml</a></td><td>x</td></tr><tr><td>functions</td><td>jstl函数</td><td><a href="http://java.sun.com/jsp/jstl/function" target="_blank" rel="noopener">http://java.sun.com/jsp/jstl/function</a></td><td>fn</td></tr></tbody></table></li><li><p>通过标签库前缀和标记及属性进行操作<code>&lt;前缀:标记 属性=&quot;值&quot;,属性=&quot;值&quot;&gt;</code></p></li></ol><p><strong>核心标签</strong></p><p>核心标签有以下几种标记</p><ul><li>表达式操作 out、set、remove、catch</li><li>流程控制 if、choose、when、otherwise</li><li>迭代操作 forEach、forTokens</li><li>URL操作 import、param、url、redirect</li></ul><p>常用的标记及其属性：</p><ul><li><p>＜c:set&gt; ：主要用来将变量存储至JSP范围中 或是JavaBean的属性或Map对象中</p><table><thead><tr><th>名称</th><th>说明</th><th>是否必须写</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>要被存储的值</td><td>否</td><td>无</td></tr><tr><td>var</td><td>存入的变量名称</td><td>否</td><td>无</td></tr><tr><td>scope</td><td>var变量的JSP范围</td><td>否</td><td>Page</td></tr><tr><td>target</td><td>JavaBean或Map对象</td><td>否</td><td>无</td></tr><tr><td>property</td><td>指定target对象的属性</td><td>否</td><td>无</td></tr></tbody></table></li><li><p>＜c:out&gt;主要用来显示数据的内容</p><table><thead><tr><th>名称</th><th>说明</th><th>是否必须写</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>需要显示出来的值</td><td>是</td><td>无</td></tr><tr><td>default</td><td>如果value的值为null，则显示default的值</td><td>否</td><td>无</td></tr><tr><td>escapeXml</td><td>是否转换特殊字符，如：＜转换成 &amp; lt;</td><td>否</td><td>True</td></tr></tbody></table></li><li><p>＜c:remove&gt; 主要负责移除变量</p><table><thead><tr><th>名称</th><th>说明</th><th>是否必须写</th><th>默认值</th></tr></thead><tbody><tr><td>var</td><td>欲移除的变量名称</td><td>是</td><td>无</td></tr><tr><td>Scope</td><td>var变量的jsp范围</td><td>否</td><td>Page</td></tr></tbody></table></li><li><p>＜c:if&gt; 主要用于进行if判断,如果为true,则输出标签体中的内容</p><table><thead><tr><th>名称</th><th>说明</th><th>是否必须写</th><th>默认值</th></tr></thead><tbody><tr><td>test</td><td>表达式的结果为true，则执行体内容，false则相反</td><td>是</td><td>无</td></tr><tr><td>var</td><td>如果 用来存储test运算的结果(true或false)</td><td>否</td><td>无</td></tr><tr><td>scope</td><td>Var变量的JSP范围</td><td>否</td><td>page</td></tr></tbody></table></li><li><p>＜c:choose &gt;,＜c:when &gt;,＜c:otherwise &gt; 作用相当于if-else</p><table><thead><tr><th>名称</th><th>说明</th><th>是否必须写</th><th>默认值</th></tr></thead><tbody><tr><td>test</td><td>表达式的结果为true，则执行体内容，false则相反</td><td>是</td><td>无</td></tr></tbody></table></li><li><p>＜c:forEach&gt; 循环控制，它可以将数组,集合(Collection)中的成员循序浏览一遍。</p><table><thead><tr><th>名称</th><th>说明</th><th>必须</th><th>默认值</th></tr></thead><tbody><tr><td>var</td><td>用来存放现在指定的成员</td><td>是</td><td>无</td></tr><tr><td>items</td><td>被迭代的集合对象（需要使用EL表达式）</td><td>否</td><td>无</td></tr><tr><td>varStatus</td><td>用来代指被迭代的集合对象</td><td>否</td><td>无</td></tr><tr><td>begin</td><td>开始的位置</td><td>否</td><td>0</td></tr><tr><td>end</td><td>结束的位置</td><td>否</td><td>最后一个成员</td></tr><tr><td>step</td><td>每次迭代的间隔数</td><td>否</td><td>1</td></tr></tbody></table></li></ul><p><strong>格式化标签</strong></p><p>常用的标记及其属性：</p><ul><li><p>&lt; fmt:formatDate &gt; 将日期类型格式化为指定模式的字符串</p><table><thead><tr><th>名称</th><th>说明</th><th>默认值</th></tr></thead><tbody><tr><td>value</td><td>将要被格式化的数据</td><td></td></tr><tr><td>pattern</td><td>格式化的模式，与SimpleDateFormat的参数设置一样,如yyyy-MM-dd</td><td></td></tr><tr><td>var</td><td>格式化后的字符串所要存放的变量，若不指定var，则会将格式化的结果直接显示在页面</td><td></td></tr><tr><td>scope</td><td>变量存放的域属性空间</td><td>page</td></tr><tr><td>type</td><td>其取值为date、time、both，表示给出的value是日期、时间、还是两者都包含</td><td>date</td></tr></tbody></table></li><li><p>&lt; fmt:parseDate &gt; 用于将指定字符串转化为日期类型</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>value</td><td>服务器获取的时间</td></tr><tr><td>pattern</td><td>转换的格式</td></tr><tr><td>var</td><td>页面显示的变量</td></tr></tbody></table></li><li><p>&lt; fmt:formatNumber &gt; 按照指定格式对数字进行格式化</p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>maxIntegerDigits</td><td>整数部分最多的位数</td></tr><tr><td>minIntegerDigits</td><td>整数部分最少的位数</td></tr><tr><td>maxFrctionDigits</td><td>小数部分最多的位数</td></tr><tr><td>minFrctionDigits</td><td>小数部分最少的位数</td></tr><tr><td>var</td><td>存储格式化结果的变量</td></tr><tr><td>scope</td><td>var属性的作用域</td></tr><tr><td>integerOnly</td><td>是否只解析整型数true或者浮点数false</td></tr></tbody></table></li></ul><blockquote><p>  <strong>关于JSTL更多内容可以参考：<a href="https://www.runoob.com/jsp/jsp-jstl.html" target="_blank" rel="noopener">https://www.runoob.com/jsp/jsp-jstl.html</a></strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;JSP简介&quot;&gt;&lt;a href=&quot;#JSP简介&quot; class=&quot;headerlink&quot; title=&quot;JSP简介&quot;&gt;&lt;/a&gt;JSP简介&lt;/h2&gt;&lt;p&gt;JSP（全称Java Server Pages）是由 Sun Microsystems 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，而动态生成 HTML、XML 或其他格式文档的Web网页的技术标准，在传统的网页HTML文件中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="jsp" scheme="https://www.pengspace.top/tags/jsp/"/>
    
      <category term="EL表达式" scheme="https://www.pengspace.top/tags/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="JSTL标签库" scheme="https://www.pengspace.top/tags/JSTL%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂java Servlet</title>
    <link href="https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82java-Servlet/"/>
    <id>https://www.pengspace.top/2020/12/12/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82java-Servlet/</id>
    <published>2020-12-12T05:49:39.000Z</published>
    <updated>2020-12-12T05:53:10.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="servlet简介"><a href="#servlet简介" class="headerlink" title="servlet简介"></a>servlet简介</h2><p>Servlet（Server Applet），全称Java Servlet，是用Java编写的，<font color=red>运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。</font>其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。</p><a id="more"></a><p>下图显示了 Servlet 在 Web 应用程序中的位置。</p><p><img src="https://i.loli.net/2020/11/26/sl8OL1tcj4WDmfN.png" alt=""></p><h2 id="Servlet工作模式："><a href="#Servlet工作模式：" class="headerlink" title="Servlet工作模式："></a>Servlet工作模式：</h2><p>① 客户端发送请求至服务器</p><ul><li>这些请求可以是显式的数据，包括网页上的 HTML 表单，或者也可以是来自 applet 或自定义的 HTTP 客户端程序的表单</li><li>也可以是隐式的 HTTP 请求数据。这包括 cookies、媒体类型和浏览器能理解的压缩格式等等。</li></ul><p>② 服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器</p><p>③ 服务器将响应返回客户端，同第①个，这些响应也可以是显式的数据或隐式的数据</p><h2 id="Servlet工作原理："><a href="#Servlet工作原理：" class="headerlink" title="Servlet工作原理："></a>Servlet工作原理：</h2><p>(1)Servlet接口定义了Servlet与servlet容器之间的契约。这个契约是：Servlet容器将Servlet类载入内存，并产生Servlet实例和调用它具体的方法。<font color=red>在一个应用程序中，每种Servlet类型只能有一个实例</font>。</p><p>(2)用户请求使Servlet容器调用Servlet的Service()方法，并传入一个ServletRequest对象和一个ServletResponse对象。这些对象都是由Servlet容器（例如TomCat）封装好的，并不需要程序员去实现，程序员可以直接使用。</p><ul><li>ServletRequest中封装了当前的Http请求，ServletResponse表示当前用户的Http响应</li></ul><p>(3)对于每一个应用程序，Servlet容器还会创建一个ServletContext对象。这个对象中封装了上下文（应用程序）的环境详情。<font color=red>每个应用程序只有一个ServletContext</font>。每个Servlet容器也都有一个封装Servlet配置的ServletConfig对象。</p><h2 id="Servlet的使用"><a href="#Servlet的使用" class="headerlink" title="Servlet的使用"></a>Servlet的使用</h2><p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。Servlet 可以使用 <strong>javax.servlet</strong> 和 <strong>javax.servlet.http</strong> 包创建，它是 Java 企业版的标准组成部分。它们之间的关系如下图所示：</p><p><img src="https://i.loli.net/2020/11/26/1CgmXzM8NBK4vcx.png" alt=""></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>创建一个类<strong>实现Servlet接口</strong>，重写其中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="comment">//初始化方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest res, ServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理get/post请求的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//销毁的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>继承HttpServlet类（常用）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest res, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理get请求的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest res, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//处理get请求的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="部署配置"><a href="#部署配置" class="headerlink" title="部署配置"></a>部署配置</h3><p>容器（Tomcat）在得到客户端的请求后，但不知道去交给哪一个servlet去处理，所以需要进行部署，有两种方式：</p><p><strong>方式一：web.xml文件部署Servlet的映射关系</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>自定义名称<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>处理请求的类的完整路径<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span><span class="comment">&lt;!-- mapping 表示映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>自定义名称<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>请求名<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>  这个xml标签的执行顺序：</p><p>  请求过来以后-&gt;web.xml-&gt;servlet-mapping标签中的url-pattern标签中的内容和请求名进行匹配-&gt;匹配成功后找对应的servlet-mapping标签中的servlet-name-&gt;去servlet标签中找和上一个servlet-name相同的name值-&gt;去找servlet标签中的servlet-class中处理类的完整路径。</p></blockquote><p><strong>方式二：@WebServlet注解</strong></p><p><strong>注解这个方式是Servlet3.0版本后才支持的</strong>，它里面可以添加如下属性</p><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>String</td><td>指定Servlet 的 name 属性，默认为类的全限定名</td></tr><tr><td>value或者urlPatterns</td><td>String</td><td>指定Servlet处理的url。等价于web.xml中的<code>&lt;url-pattern&gt;</code>标签。</td></tr><tr><td>asyncSupported</td><td>boolean</td><td>指定Servlet是否支持异步操作模式</td></tr><tr><td>displayName</td><td>String</td><td>指定servlet的显示名</td></tr><tr><td>initParams</td><td>webInitParam[]</td><td>配置初始化参数</td></tr><tr><td>loadOnStartup</td><td>int</td><td>指定servlet的加载顺序，默认不配置或数值为负数时表示客户端第一次请求Servlet时再加载；0或正数表示启动应用就加载，正数情况下，数值越小，加载该Servlet的优先级越高；</td></tr></tbody></table><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(value = <span class="string">"/login"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span>  </span>&#123;</span><br><span class="line"><span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h2><p>当客户端首次发送第一次请求后，由容器(web服务器(tomcat))去解析请求，根据请求找到对应的servlet，判断该类的对象是否存在，不存在则创建servlet实例，调取init()方法进行初始化操作，初始化完成后调取service()方法，由service()判断客户端的请求方式，如果是get，则执行doGet()，如果是post则执行doPost()。处理方法完成后，作出响应结果给客户端。单次请求处理完毕。</p><p>当用户发送第二次以后的请求时，会判断对象是否存在，但是不再执行init()，而直接执行service方法，调取doGet()/doPost()方法。</p><p>当服务器关闭时调取destroy()方法进行销毁。</p><p><img src="https://i.loli.net/2020/11/26/5sKVlqR1SDomOpF.png" alt=""></p><h2 id="Servlet接收-响应请求"><a href="#Servlet接收-响应请求" class="headerlink" title="Servlet接收/响应请求"></a>Servlet接收/响应请求</h2><p>客户端发送数据给服务器端的请求方式：</p><table><thead><tr><th>请求方式</th><th>请求类型</th><th>举例</th></tr></thead><tbody><tr><td>通过form表单</td><td>get/post提交</td><td>&lt; form action=”请求” method=”get/post”&gt;&lt; /form&gt;</td></tr><tr><td>通过a标签发送数据</td><td>get提交</td><td>&lt; a href = “请求”&gt;&lt; /a&gt;</td></tr><tr><td>通过地址栏直接拼接</td><td>get请求</td><td>url/请求?key=value&amp;key=value</td></tr><tr><td>js提交数据</td><td>get请求</td><td>location.href=“目标请求?key=value&amp;key=value”</td></tr></tbody></table><blockquote><p>  <strong>get/post请求的比较：</strong></p><ol><li><p>地址栏呈现</p><ul><li>GET请求：请求的数据会附加在URL之后，以<code>?</code>分割URL和传输数据，多个参数用<code>&amp;</code>连接。</li><li>POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。</li></ul><p>因此，GET请求的数据会暴露在地址栏中，而POST请求则不会。</p></li><li><p>传输数据的大小</p><ul><li>在HTTP规范中，没有对URL的长度和传输的数据大小进行限制。但是在实际开发过程中，对于GET，特定的浏览器和服务器对URL的长度有限制。因此，在使用GET请求时，传输数据会受到URL长度的限制。</li><li>对于POST，由于不是URL传值，理论上是不会受限制的，但是实际上各个服务器会规定对POST提交数据大小进行限制，Apache、IIS都有各自的配置。</li></ul></li><li><p>安全性</p><p>POST的安全性比GET的高。比如：在进行登录操作，通过GET请求，用户名和密码都会暴露再URL上，因为登录页面有可能被浏览器缓存以及其他人查看浏览器的历史记录的原因，此时的用户名和密码就很容易被他人拿到。除此之外，GET请求提交的数据还可能会造成Cross-site request frogery攻击</p></li></ol></blockquote><p>HttpServletRequest和HttpServletResponse对象中分别封装了当前的Http请求和响应，它们中都有一些方法来处理请求和响应。</p><p>HttpServletRequest类常用方法：</p><table><thead><tr><th>修饰</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>getParameter(String name)</td><td>根据表单组件名称获取提交数据，返回值是String（服务器在接收数据时使用字符串统一接收）</td></tr><tr><td>String[]</td><td>getParameterValues(String name)</td><td>获取表单组件对应多个值时的请求数据</td></tr><tr><td>void</td><td>setCharacterEncoding(String charset)</td><td>指定每个请求的编码(针对post请求才起作用)</td></tr><tr><td>RequestDispatcher</td><td>getRequestDispatcher(String path)</td><td><strong>转发</strong>,返回一个RequestDispatcher对象，该对象的forward( )方法用于转发请求</td></tr><tr><td>Session</td><td>getSession()</td><td>取得当前会话的Session对象</td></tr><tr><td>void</td><td>setAttribute(“key”,value)</td><td>存值</td></tr><tr><td>void</td><td>getAttribute(“key”)</td><td>取值，需要向下转型</td></tr></tbody></table><p>HttpServletResponse类常用方法：</p><table><thead><tr><th>修饰</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void</td><td>addCookie(Cookie var1)</td><td>给这个响应添加一个cookie</td></tr><tr><td>void</td><td>sendRedirect(String var1)</td><td><strong>重定向</strong>，发送一条响应码，将浏览器跳转到指定的位置</td></tr><tr><td>PrintWriter</td><td>getWriter()</td><td>获得字符流，通过字符流的write(String s)方法可以将字符串设置到response 缓冲区中，随后Tomcat会将response缓冲区中的内容组装成Http响应返回给浏览器端，可以返回html/js代码等</td></tr><tr><td>void</td><td>setContentType()</td><td>设置响应内容的类型</td></tr></tbody></table><blockquote><p>  <strong>重定向与转发的区别</strong></p><p>  转发：<code>httpServletRequest.getRequestDispatcher(&quot;目标地址&quot;).forward(传递参数)</code></p><p>  重定向：<code>httpServletResponse.sendRedirect(&quot;目标地址&quot;)</code></p><p>  相同点：都用来跳转页面</p><p>  不同点：</p><ul><li><p>重定向时地址栏会改变，request中存储的数据会丢失。转发时地址栏显示的是请求页面的地址，request数据可以保存。</p></li><li><p>转发属于一次请求一次响应，重定向属于两次请求(地址栏修改了两次)两次响应。</p><p><img src="https://i.loli.net/2020/11/26/qinVUdSPcCf4uvb.png" alt=""></p></li></ul></blockquote><h2 id="会话（Session和Cookie）"><a href="#会话（Session和Cookie）" class="headerlink" title="会话（Session和Cookie）"></a>会话（Session和Cookie）</h2><p>会话的概念：从打开浏览器到关闭浏览器,期间访问服务器就称为一次会话</p><p>会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。</p><ul><li>Cookie通过在客户端记录信息确定用户身份</li><li>Session通过在服务器端记录信息确定用户身份。</li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p><strong>session会话的数据可以在多个页面中共享,即使重定向页面,数据不会丢失</strong></p><p><strong>Session常用方法：</strong></p><table><thead><tr><th>修饰</th><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void</td><td>setAttribute(String key,Object value)</td><td>以key/value的形式保存对象值,将数据存储在服务器端</td></tr><tr><td>Object</td><td>getAttribute(String key)</td><td>通过key获取对象值</td></tr><tr><td>Enumeration</td><td>getAttributeNames()</td><td>返回Session中存在的属性名(key)</td></tr><tr><td>long</td><td>getLastAccessedTime()</td><td>返回Session的最后活跃时间。</td></tr><tr><td>long</td><td>getCreationTime()</td><td>返回Session的创建日期。返回类型为long，常被转化为Date类型，例如：Date createTime = new Date(session.get CreationTime())</td></tr><tr><td>void</td><td>invalidate()</td><td>设置session对象失效</td></tr><tr><td>String</td><td>getId()</td><td><strong>获取sessionid,当第一次登录成功后，session会产生一个唯一的id</strong>，浏览器之后访时如果发现id值还是之前id，那么说明 当前访问的属于同一个会话</td></tr><tr><td>void</td><td>setMaxInactiveInterval(int interval)</td><td>设定session的有效时间，单位为s秒，默认的有效时间:30分钟</td></tr><tr><td>int</td><td>getMaxInactiveInterval()</td><td>获取session的有效时间(以秒为单位)</td></tr><tr><td>boolean</td><td>isNew()</td><td>返回该Session是否是新创建的</td></tr><tr><td>void</td><td>removeAttribute(String key)</td><td>从session中删除指定名称(key)所对应的对象</td></tr></tbody></table><p><strong>Session的生命周期</strong></p><p>Session保存在服务器端。<strong>为了获得更高的存取速度，服务器一般把Session放在内存</strong>里。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。因此，Session里的信息应该尽量精简。</p><p>Session在用户第一次访问服务器的时候自动创建。需要注意<strong>只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session</strong>。如果尚未生成Session，也可以用<code>request.getSession(true)</code>强制生成Session。</p><p>Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session“活跃（active）”了一次。</p><p>由于会有越来越多的用户访问服务器，因此Session也会越来越多。为防止内存溢出，服务器会把长时间内没有活跃的Session从内存删除。这个时间就是<strong>Session的超时时间</strong>。如果超过了超时时间没访问过服务器，Session就自动失效了。</p><p>Session的超时时间为<code>maxInactiveInterval</code>属性，可以通过对应的<code>getMaxInactiveInterval()</code>获取，通过<code>setMaxInactiveInterval(long interval)</code>修改。Session的超时时间也可以在web.xml中修改。另外，通过调用Session的<code>invalidate()</code>方法可以使Session失效。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span>  //30分钟</span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie是客户端(一般指浏览器)请求服务器后,服务器发给客户端的一个辨认标识，保存在客户端，当客户端再次向服务器发送请求时，会携带着这个辨认标识，服务器就可以通过这个标识来识别客户端的身份或状态等。</p><p><strong>Cookie的设置和获取</strong></p><p>通过HttpServletResponse.addCookie的方式设置Cookie</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"jieguo"</span>,<span class="string">"true"</span>);</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p>服务端获取客户端携带的cookie：通过HttpServletRequest获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="keyword">if</span>(cookies != <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">for</span>(Cookie c : cookies)&#123;</span><br><span class="line">        String name = c.getName();<span class="comment">//获取Cookie名称</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"jieguo"</span>.equals(name))&#123;</span><br><span class="line">            String value = c.getValue();<span class="comment">//获取Cookie的值</span></span><br><span class="line">            bool = Boolean.valueOf(value);<span class="comment">//将值转为Boolean类型</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>删除Cookie</strong></p><p>通过设置同名Cookie的最大存活时间为0，删除Cookie是指使浏览器不再保存Cookie，使Cookie立即失效</p><p>举例：使name为username的Cookie立即失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个name为username的Cookie</span></span><br><span class="line">Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">"username"</span>, <span class="string">"aaa"</span>);</span><br><span class="line"><span class="comment">//2.设置Cookie的有效时间为0</span></span><br><span class="line">cookie.setMaxAge(<span class="number">0</span>);<span class="comment">//删除cookie的关键</span></span><br><span class="line"><span class="comment">//3.将cookie发送给浏览器，来替换同名Cookie</span></span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure><p><strong>Cookie的有效时间</strong></p><p>Cookie发送给浏览器以后，浏览器并不会永久保存，也就是到了一定的时间以后浏览器会自动销毁Cookie。<br>Cookie的默认有效时间为一次会话(一次打开关闭浏览器的过程)，我们也可以手动指定Cookie的有效时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//setMaxAge用来设置Cookie的最大有效时间，需要int型的参数，代表有效的秒数</span></span><br><span class="line">cookie.setMaxAge(秒数)；</span><br><span class="line">    <span class="comment">//当参数大于0时，会设置为指定的秒数</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">30</span>);</span><br><span class="line">    <span class="comment">//当参数等于0时,浏览器不会保存Cookie,Cookie立即失效</span></span><br><span class="line">    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//当参数小于0时，和不设置是一样，当前会话有效</span></span><br><span class="line">    cookie.setMaxAge(-<span class="number">100</span>);</span><br><span class="line"><span class="comment">//设置一个永久有效的Cookie，并非永久，只是使Cookie的生命很长而已</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">365</span>*<span class="number">10</span>);</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>Session和Cookie的区别</strong></p><ul><li>Cookie数据保存在客户端，Session数据保存在服务器端。</li><li>Session是由应用服务器维持的一个服务器端的存储空间，用户在连接服务器时，会由服务器生成一个唯一的SessionID，用该SessionID 为标识符来存取服务器端的Session存储空间。而SessionID这一数据则是保存到客户端，用Cookie保存的，用户提交页面时，会将这一SessionID提交到服务器端，来存取Session数据。这一过程，是不用开发人员干预的。所以一旦客户端禁用Cookie，那么Session也会失效。</li><li>Cookies是属于Session对象的一种。但有不同，Cookies不会占服务器资源，是存在客服端内存或者一个Cookie的文本文件中；而Session则会占用服务器资源。所以，尽量不要使用Session，而使用Cookies。但是我们一般认为Cookie是不可靠的，Cookies是保存在本机上的，但是其信息的完全可见性且易于本地编辑性，往往可以引起很多的安全问题。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;servlet简介&quot;&gt;&lt;a href=&quot;#servlet简介&quot; class=&quot;headerlink&quot; title=&quot;servlet简介&quot;&gt;&lt;/a&gt;servlet简介&lt;/h2&gt;&lt;p&gt;Servlet（Server Applet），全称Java Servlet，是用Java编写的，&lt;font color=red&gt;运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。&lt;/font&gt;其主要功能在于交互式地浏览和修改数据，生成动态Web内容。狭义的Servlet是指Java语言实现的一个接口，广义Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="servlet" scheme="https://www.pengspace.top/tags/servlet/"/>
    
      <category term="session" scheme="https://www.pengspace.top/tags/session/"/>
    
      <category term="cookie" scheme="https://www.pengspace.top/tags/cookie/"/>
    
  </entry>
  
  <entry>
    <title>JavaWeb环境搭建(Tomcat)</title>
    <link href="https://www.pengspace.top/2020/12/12/JavaWeb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-Tomcat/"/>
    <id>https://www.pengspace.top/2020/12/12/JavaWeb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-Tomcat/</id>
    <published>2020-12-12T05:47:17.000Z</published>
    <updated>2020-12-12T05:50:09.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>超文本传输协议（<code>HyperText Transfer Protocol</code>，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p><a id="more"></a><p>HTTP的发展是由蒂姆·伯纳斯-李于1989年在欧洲核子研究组织（CERN）所发起。HTTP的标准制定由万维网协会（World Wide Web Consortium，W3C）和互联网工程任务组（Internet Engineering Task Force，IETF）进行协<br>调，最终发布了一系列的RFC，其中最著名的是1999年6月公布的 RFC 2616，定义了HTTP协议中现今广泛使用的一个版本——HTTP 1.1。</p><p><img src="https://i.loli.net/2020/11/18/hfFxIbpreuc3siy.png" alt="五层协议"></p><p>HTTP协议是基于TCP/IP协议之上的应用层协议。</p><p>HTTP是一种不保存状态，即无状态（stateless)协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。</p><h3 id="请求-响应的步骤"><a href="#请求-响应的步骤" class="headerlink" title="请求/响应的步骤"></a>请求/响应的步骤</h3><ol><li><p><strong>客户端连接到Web服务器</strong></p><p>一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。</p></li><li><p><strong>发送HTTP请求</strong></p><p>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由请求行、请求头部、空行和请求数据4部分组成。</p></li><li><p><strong>服务器接受请求并返回HTTP响应</strong></p><p>Web服务器解析请求，定位请求资源。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由状态行、响应头部、空行和响应数据4部分组成。</p></li><li><p><strong>释放TCP连接</strong></p><p>在HTTP/1.0中默认使用<strong>短连接</strong>。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></p><p>在使用<strong>长连接</strong>的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><blockquote><p>  HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</p></blockquote></li><li><p><strong>客户端浏览器解析HTML内容</strong></p><p>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><blockquote><p>  例如：在浏览器地址栏键入URL，按下回车之后会经历以下流程：</p><ol><li>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;</li><li>解析出 IP 地址后，根据该 IP 地址和默认端口 80，和服务器建立TCP连接;</li><li>浏览器发出读取文件(URL 中域名后面部分对应的文件)的HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器；</li><li>服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器;</li><li>浏览器将该 html 文本并显示内容;</li></ol></blockquote><h3 id="HTTP请求方法"><a href="#HTTP请求方法" class="headerlink" title="HTTP请求方法"></a>HTTP请求方法</h3><p>HTTP/1.1协议中共定义了八种方法（动作）来以不同方式操作指定的资源：</p><ul><li><strong><font color=red>GET</font></strong><br>向指定的资源发出「显式」请求。使用GET方法应该只用在读取数据，而不应当被用于产生「副作用」的操作中，例如在Web Application中。其中一个原因是GET可能会被网络爬虫等随意访问。</li><li><strong>HEAD</strong><br>与GET方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中「关于该资源的信息」(元信息或称元数据)。</li><li><strong><font color=red>POST</font></strong><br>向指定资源提交数据，请求服务器进行处理（例如提交表单或者上传文件）。数据被包含在请求本文中。这个请求可能会创建新的资源或修改现有资源，或二者皆有。</li><li><strong><font color=red>PUT</font></strong><br>向指定资源位置上传其最新内容。</li><li><strong><font color=red>DELETE</font></strong><br>请求服务器删除Request-URI所标识的资源。</li><li><strong>TRACE</strong><br>回显服务器收到的请求，主要用于测试或诊断。</li><li><strong>OPTIONS</strong><br>这个方法可使服务器传回该资源所支持的所有HTTP请求方法。用<code>*</code>来代替资源名称，向Web服务器发送OPTIONS请求，可以测试服务器功能是否正常运作。</li></ul><h3 id="C-S与B-S"><a href="#C-S与B-S" class="headerlink" title="C/S与B/S"></a>C/S与B/S</h3><p><code>C/S</code>：又称Client/Server或客户/服务器模式。服务器通常采用高性能的PC、工作站或小型机，客户端需要安装专用的客户端软件。如QQ，微信等软件</p><p><code>B/S</code>：是Brower/Server的缩写，客户机上只要安装一个浏览器（Browser）。Browser/Server是建立在广域网的基础上的。</p><p><strong>C/S和B/S结构各自的优、缺点：</strong></p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>C/S</td><td>1.  交互性强，客户端有着一套完整的应用程序，相对B/S有着更加强大的功能，还可以实现子程序之间的切换； <br>2. 安全性强，只适用于局域网，相对来说其安全比较好； <br>3. 处理信息能力强，C/S的通信量相对B/S是少了很多的；<br>4. 速度较快，更加利于处理大量数据。</td><td>1. 只适用于局域网； <br>2. 客户端要安装专用的客户端软件； <br>3. 每当系统升级时，每一台客户机需要重新安装； <br>4. 操作系统可能会有限制。</td></tr><tr><td>B/S</td><td>1. 客户端零维护；<br>2. 系统扩展容易； <br>3. 在电脑可上网的前提下，可以在任何操作系统上使用并且不需要安装专门的软件 。</td><td>1. 相对C/S来说交互能力差，不能够在子程序间自由切换；<br>2. 安全性较差，B/S其安全性只能靠数据库服务器上管理密码的数据库来保证；<br>3. 逻辑结构比C/S多一层，处理速度较慢</td></tr></tbody></table><h3 id="Web服务器的分类"><a href="#Web服务器的分类" class="headerlink" title="Web服务器的分类"></a>Web服务器的分类</h3><p>Web服务器是运行及发布Web应用的容器，只有将开发的Web项目放置到该容器中，才能使网络中的所有用户通过浏览器进行访问。开发Java Web应用所采用的服务器主要是与JSP/Servlet兼容的Web服务器，比较常用的有<br>Tomcat、Resin、JBoss、WebSphere 和 WebLogic 等。</p><ul><li><p><strong>Tomcat 服务器</strong></p><p>目前最为流行的Tomcat服务器是Apache-Jarkarta开源项目中的一个子项目，是一个小型、轻量级的支持JSP和Servlet 技术的Web服务器，也是初学者学习开发JSP应用的首选。</p></li><li><p><strong>Resin 服务器</strong></p><p>Resin是Caucho公司的产品，是一个非常流行的支持Servlet和JSP的服务器，速度非常快。Resin本身包含了一个支持HTML的Web服务器，这使它不仅可以显示动态内容，而且显示静态内容的能力也毫不逊色，因此许多网站都是使用Resin服务器构建</p></li><li><p><strong>JBoss服务器</strong><br>JBoss是一个种遵从JavaEE规范的、开放源代码的、纯Java的EJB服务器，对于J2EE有很好的支持。JBoss采用JML API实现软件模块的集成与管理，其核心服务又是提供EJB服务器，不包含Servlet和JSP的Web容器，不过它可以和Tomcat完美结合</p></li><li><p><strong>WebSphere 服务器</strong></p><p>WebSphere是IBM公司的产品，可进一步细分为 WebSphere Performance Pack、Cache Manager 和WebSphere Application Server等系列，其中WebSphere Application Server 是基于Java 的应用环境，可以运行于 Sun Solaris、Windows NT 等多种操作系统平台，用于建立、部署和管理Internet和Intranet Web应用程序。</p></li><li><p><strong>WebLogic 服务器</strong><br>WebLogic 是BEA公司的产品（现在已经被Oracle收购），可进一步细分为 WebLogic Server、WebLogic Enterprise 和 WebLogic Portal 等系列，其中 WebLogic Server 的功能特别强大。WebLogic 支持企业级的、多层次的和完全分布式的Web应用，并且服务器的配置简单、界面友好。对于那些正在寻求能够提供Java平台所拥有的一切应用服务器的用户来说，WebLogic是一个十分理想的选择</p></li></ul><h3 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h3><blockquote><p>  tomcat的使用是基于java的，所以要保证我们的电脑已经有了java环境。</p></blockquote><h4 id="安装与配置"><a href="#安装与配置" class="headerlink" title="安装与配置"></a>安装与配置</h4><ol><li><p>去官网下载对应版本的Tomcat</p><p>官网地址：<a href="https://tomcat.apache.org/" target="_blank" rel="noopener">https://tomcat.apache.org/</a></p><p><img src="https://i.loli.net/2020/11/19/LFWV4eRbshPjHT2.png" alt=""></p></li><li><p>解压或安装到一个没有特殊符号的目录中（最好不要包含中文路径）我这里下载的是zip包，解压即可</p><p><img src="https://i.loli.net/2020/11/19/ZU4FcjzMwsgvBmI.png" alt=""></p></li><li><p>配置环境变量</p><p>右键点击此电脑，打开属性，找到高级系统设置-&gt;环境变量-&gt;系统变量</p><p>(1) 新建一个变量CATALINA_HOME，值为tomcat安装的路径，结尾不要分号</p><p><img src="https://i.loli.net/2020/11/19/R48ChW7Ke62lBJX.png" alt=""></p><p>(2) 配置Path变量，找到系统变量中的Path变量，点击编辑，新建一个，值为<code>%CATALINA_HOME%\bin</code></p><p><img src="https://i.loli.net/2020/11/19/NLkDgfbMwEXK37z.png" alt="image-20201119154624242"></p><p>(3) 配置ClassPath变量，找到系统变量中的ClassPath变量(没有就新建一个)，值为<code>%CATALINA_HOME%\servlet-api.jar</code></p><p><img src="https://i.loli.net/2020/11/19/Sr8WiypNugD5bhv.png" alt=""> </p></li><li><p>将tomcat9安装到windows服务中<strong>（可做可不做）</strong></p><p>打开cmd命令行输入<code>service install Tomcat9</code></p><p><img src="https://i.loli.net/2020/11/19/9lVhyzNZaGBHLgi.png" alt=""></p><p>如果报以下错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The file Tomcat9.exe was not found... </span><br><span class="line">Either the CATALINA_HOME environment variable is not defined correctly or ....省略</span><br></pre></td></tr></table></figure><p>找到环境变量Path，编辑文本，去除<code>%CATALINA_HOME%\bin</code>后面的分号，安装成功后再加上分号。</p></li></ol><blockquote><p>  <strong>注意：</strong> 第四步将tomcat9安装到windows服务中，可做可不做，做这步的目的就是使解压后bin文件夹下的tomcat9.exe和tomcat9w.exe也可以运行，使得绿色解压版和exe安装版安装tomcat的功能一样完整。</p></blockquote><p>至此，配置工作完成！打开bin文件夹，双击startup.bat(或tomcat9.exe)启动tomcat服务，因为配置了环境变量也可以直接在cmd中输入startup.bat(或tomcat9.exe)，它会自动打开一个控制台界面。不要关闭控制台界面，打开浏览器，输入<a href="http://localhost:8080，出现Tomcat的网页，证明安装并配置成功！最后关闭控制台，关闭控制台即关闭Tomcat服务。">http://localhost:8080，出现Tomcat的网页，证明安装并配置成功！最后关闭控制台，关闭控制台即关闭Tomcat服务。</a></p><p><img src="https://i.loli.net/2020/11/19/gJXnYDIEoVxWpU1.png" alt=""></p><h4 id="tomcat内目录的含义"><a href="#tomcat内目录的含义" class="headerlink" title="tomcat内目录的含义"></a>tomcat内目录的含义</h4><p><img src="https://i.loli.net/2020/11/19/6BX4YlwgFntjVka.png" alt=""></p><ol><li><p><strong>bin</strong>：该目录下存放的是二进制可执行文件，有两个exe文件：tomcat9.exe、tomcat9w.exe，前者是在控制台下启动Tomcat，后者是弹出GUI窗口启动Tomcat；有有两个bat文件：startup.bat和shutdown.bat，startup.bat用来启动Tomcat，shutdown.bat用来停止Tomcat；</p></li><li><p><strong>conf</strong>：这是一个<strong>非常非常重要</strong>的目录，这个目录下有四个最为重要的文件：</p><ul><li><p>server.xml：配置整个服务器信息。例如修改端口号，添加虚拟主机等；</p></li><li><p>tomcat-users.xml：存储tomcat用户的文件，这里保存的是tomcat的用户名及密码，以及用户的角色信息。可以按着该文件中的注释信息添加tomcat用户，然后就可以在Tomcat主页中进入Tomcat Manager页面了；</p></li><li><p>web.xml：部署描述符文件，这个文件中注册了很多MIME类型，即文档类型。这些MIME类型是客户端与服务器之间说明文档类型的，如用户请求一个html网页，那么服务器还会告诉客户端浏览器响应的文档是text/html类型的，这就是一个MIME类型。客户端浏览器通过这个MIME类型就知道如何处理它了，但如果服务器响应的是一个exe文件，那么浏览器就不可能显示它，而是应该弹出下载窗口才对。</p><p>MIME就是用来说明文档的内容是什么类型的！</p></li><li><p>context.xml：对所有应用的统一配置，通常我们不会去修改它。</p></li></ul></li><li><p><strong>lib</strong>：Tomcat的类库，里面是一大堆jar文件。如果需要添加Tomcat依赖的jar文件，可以把它放到这个目录中，当然也可以把应用依赖的jar文件放到这个目录中，这个目录中的jar所有项目都可以共享之，但这样你的应用放到其他Tomcat下时就不能再共享这个目录下的Jar包了，所以建议只把Tomcat需要的Jar包放到这个目录下；</p></li><li><p><strong>logs</strong>：这个目录中都是日志文件，记录了Tomcat启动和关闭的信息，如果启动Tomcat时有错误，那么异常也会记录在日志文件中。</p></li><li><p><strong>temp</strong>：存放Tomcat的临时文件，这个目录下的东西可以在停止Tomcat后删除！</p></li><li><p><strong>webapps</strong>：存放web项目的目录，其中每个文件夹都是一个项目；如果这个目录下已经存在了目录，那么都是tomcat自带的项目。其中ROOT是一个特殊的项目，在地址栏中没有给出项目目录时，对应的就是ROOT项目。</p><p>如:<a href="http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字" target="_blank" rel="noopener">http://localhost:8080/examples，进入示例项目。其中examples就是项目名，即文件夹的名字</a></p></li><li><p><strong>work</strong>：运行时生成的文件，最终运行的文件都在这里。通过webapps中的项目生成的！可以把这个目录下的内容删除，再次运行时会生再次生成work目录。当客户端用户访问一个JSP文件时，Tomcat会通过JSP生成Java文件，然后再编译Java文件生成class文件，生成的java和class文件都会存放到这个目录下。</p></li><li><p>LICENSE：许可证。</p></li><li><p>NOTICE：说明文件。</p></li></ol><blockquote><p>  通过url访问服务器:</p><p>  url:<code>http://服务器的ip地址:端口号/项目名/被访问的页面</code></p><p>  示例:<a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a></p><p>  注: (1)启动tomcat后，tomcat会加载部署在服务器端的所有项目</p><p>  (2) 浏览器访问的页面是服务器端的页面，基本上服务器的项目和工作空间的项目要保持一致</p></blockquote><h4 id="IntelliJ-IDEA配置Tomcat"><a href="#IntelliJ-IDEA配置Tomcat" class="headerlink" title="IntelliJ IDEA配置Tomcat"></a>IntelliJ IDEA配置Tomcat</h4><ol><li>点击Run—Edit Configurations…</li></ol><p><img src="https://i.loli.net/2020/11/19/1Cn2XGP9qJDSbps.png" alt="image-20201119140937936"></p><ol start="2"><li>点击左侧<code>+</code>号，找到Tomcat Server—Local</li></ol><p><img src="https://i.loli.net/2020/11/19/jNtDmAagkslSCHQ.png" alt="image-20201119141510118"></p><ol start="3"><li><p>在Tomcat Server -&gt; local-&gt; Server -&gt; Application server项目下，点击 Configuration ，找到本地 Tomcat 服务器，再点击 OK按钮。</p><p><img src="https://i.loli.net/2020/11/19/lzRZYnPJ7isoBuD.png" alt=""></p></li></ol><p>至此，IntelliJ IDEA配置Tomcat完成。</p><h4 id="创建JavaWeb项目"><a href="#创建JavaWeb项目" class="headerlink" title="创建JavaWeb项目"></a>创建JavaWeb项目</h4><ol><li><p>点击左上角的File–&gt;New–&gt;Project，选择Java Enterprise，在Application Sever中找到自己的Tomcat，同时勾中Web Application 和 Create web.xml，点击next，输入项目名称和路径，点击finish即可。</p><p><img src="https://i.loli.net/2020/11/19/ObvQ3RBUK5f4ptT.png" alt=""></p></li><li><p>创建好之后文件结构如下：</p><p><img src="https://i.loli.net/2020/11/19/phctYUqvHFOK87P.png" alt=""></p></li><li><p>在WEB-INF文件夹下创建classes和lib文件夹，名字不可改</p><ul><li>classes用来存放java文件编译后的字节码文件</li><li>lib用来存放项目所需的jar依赖包</li></ul></li><li><p>配置jar包和classes包</p><p>(1) 在File中找到Project Structure，点击Modules，选择Paths，选中Use module compile output path，把路径改成刚刚创建的classes文件夹，点击apply</p><p><img src="https://i.loli.net/2020/11/19/2IEsGwbJ7cfHZWo.png" alt=""></p><p>如果classes文件夹没有变颜色，就右键点击classes文件夹，选择Mark Diectory as —&gt;Exclued</p><p><img src="https://i.loli.net/2020/11/19/qVIJ6zkiA8pamwF.png" alt="image-20201119152102261"></p><p>(2) 选择Dependencies，点右边的<code>+</code>号 选择1 JARs or directories，选择刚创建的lib文件夹，点ok，选择Jar  Directory，点击ok。</p><p><img src="https://i.loli.net/2020/11/19/oRJ6tG2417QYXyB.png" alt="image-20201119150048728"></p></li><li><p>部署项目:将本地项目安装到服务器中</p><p>(1) idea主界面顶部菜单栏点击Run ，选择Edit Configurations，可以配置一些信息</p><p><img src="https://i.loli.net/2020/11/19/YBGwXlTr8RtyEgC.png" alt="image-20201119151516787"></p><p>(2) 运行</p><p><img src="https://i.loli.net/2020/11/19/yYjEz69HNfcUKVs.png" alt="image-20201119151559538"></p></li></ol><pre><code>![](https://i.loli.net/2020/11/19/lWfI9AZjS8RKsuB.png)</code></pre><p>运行成功</p><h4 id="tomcat常用操作"><a href="#tomcat常用操作" class="headerlink" title="tomcat常用操作"></a>tomcat常用操作</h4><h5 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h5><p>修改配置文件:/conf/server.xml 的port</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">"8888"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span><span class="attr">redirectPort</span>=<span class="string">"8443"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>如果将端口号改成80，则访问项目时的请求路径就可以省略端口号。</p><h5 id="管理项目"><a href="#管理项目" class="headerlink" title="管理项目"></a>管理项目</h5><p>给tomcat增加管理员信息：配置conf/tomcat-users.xml</p><p>在tomcat-users.xml文件中添加下面代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">role</span> <span class="attr">rolename</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">username</span>=<span class="string">"tomcat"</span> <span class="attr">password</span>=<span class="string">"tomcat"</span> <span class="attr">roles</span>=<span class="string">"manager-gui"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/19/T8Jt6WEqbKahwuR.png" alt=""></p><p>点击Manager App会弹出下面这个框，我们输入tomcat-users.xml文件中添加的管理员账户密码就可以看到当前tomcat服务器中的所有web应用。</p><p><img src="https://i.loli.net/2020/11/19/O9NwRqvClfs4kHu.png" alt=""></p><p><img src="https://i.loli.net/2020/11/19/amVHeL2jqshwYtA.png" alt=""></p><p>注意:tomcat启动的时候会加载webapps下的所有项目</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;超文本传输协议（&lt;code&gt;HyperText Transfer Protocol&lt;/code&gt;，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="https://www.pengspace.top/tags/JavaWeb/"/>
    
      <category term="tomcat" scheme="https://www.pengspace.top/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库高级</title>
    <link href="https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/"/>
    <id>https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E7%BA%A7/</id>
    <published>2020-11-16T11:41:42.000Z</published>
    <updated>2020-11-16T11:49:21.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DQL数据查询进阶"><a href="#DQL数据查询进阶" class="headerlink" title="DQL数据查询进阶"></a>DQL数据查询进阶</h2><p>这里所用到的表结构如下图所示：</p><p><img src="https://i.loli.net/2020/11/11/T2PUqaGgcXIZv18.png" alt=""></p><a id="more"></a><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>子查询即嵌套在其他查询中的查询。可以利用嵌套关系完成一些复杂情况的查询。</p><blockquote><p>  <strong>例子 1：利用子查询进行过滤</strong></p><p>  订单存储在两个表中。对于包含订单号、客户ID、订单日期的每个订单，orders表存储⼀行。 各订单的物品存储在相关的orderitems表中。orders表不存储客户信息。它只存储客户的ID。实际的客户信息存储在customers表中。现在，假如需要列出订购了物品TNT2的所有客户，可以用下面的方式查询</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- 从oderitems表中查询所有包含物品TNT2中的订单编号order_num;</span><br><span class="line">-- 将上一步查询出的order_num作为在oders表中查询的条件，查询出符合条件的用户编号cust_id;</span><br><span class="line">-- 再将上一步查询出的cust_id作为在customers表中查询的条件,就可以查询出订购了物品TNT2的所有客户啦</span><br><span class="line">SELECT cust_name,cust_contact</span><br><span class="line">FROM customers</span><br><span class="line">WHERE cust_id IN (</span><br><span class="line">   SELECT cust_id</span><br><span class="line">FROM orders</span><br><span class="line">WHERE order_num IN (</span><br><span class="line">       SELECT order_numFROM orderitems WHERE prod_id &#x3D; &#39;TNT2&#39;</span><br><span class="line">   )</span><br><span class="line">); </span><br><span class="line">-- 查询结果：</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| cust_name      | cust_contact |</span><br><span class="line">+----------------+--------------+</span><br><span class="line">| Coyote Inc.    | Y Lee        |</span><br><span class="line">| Yosemite Place | Y Sam        |</span><br><span class="line">+----------------+--------------+</span><br></pre></td></tr></table></figure><p>  <strong>例子 2：作为计算字段使用子查询</strong></p><p>  假如需要显示customers表中每个客户的订单总数。订单与相应的客户ID存储在orders表中。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 从customers表中检索客户列表。对于检索出的每个客户，统计其在orders表中的订单数目。</span><br><span class="line">SELECT cust_id,cust_name,</span><br><span class="line">(SELECT COUNT(*)</span><br><span class="line">FROM orders</span><br><span class="line">WHERE orders.cust_id &#x3D; customers.cust_id) as ordersNum</span><br><span class="line">FROM customers</span><br><span class="line">ORDER BY cust_name;</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+-----------+</span><br><span class="line">| cust_id | cust_name      | ordersNum |</span><br><span class="line">+---------+----------------+-----------+</span><br><span class="line">|   10001 | Coyote Inc.    |         2 |</span><br><span class="line">|   10005 | E Fudd         |         1 |</span><br><span class="line">|   10002 | Mouse House    |         0 |</span><br><span class="line">|   10003 | Wascals        |         1 |</span><br><span class="line">|   10004 | Yosemite Place |         1 |</span><br><span class="line">+---------+----------------+-----------+</span><br></pre></td></tr></table></figure><p>  这条SELECT 语句对customers 表中每个客户返回3 列：cust_name、cust_state和ordersNum。ordersNum是一个计算字段，它是由圆括号中的子查询<code>SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) as ordersNum)</code>建立的。该子查询对检索出的每个客户执行一次。在此例子中，该子查询执行了5次，因为检索出了5个客户。</p><blockquote><p>  子查询中的WHERE子句与前面使用的WHERE子句稍有不同，因为它使用了完全限定列名。这种方式叫做相关子查询，它是涉及外部查询的子查询。任何时候只要列名可能有多义性，就必须使用这种语法。因为有两个cust_id列，一个在customers中，另一个在orders中，需要⽐比较这两个列列以正确地把订单与它们相应的顾客匹配</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE orders.cust_id &#x3D; customers.cust_id</span><br></pre></td></tr></table></figure></blockquote></blockquote><h3 id="联表查询"><a href="#联表查询" class="headerlink" title="联表查询"></a>联表查询</h3><p>SQL最强大的功能之⼀就是能在数据检索查询的执行中联结（join）表。在能够有效地使⽤用联结前，必须了了解关系表以及关系数据库设计的⼀些基础知识</p><h4 id="表关系"><a href="#表关系" class="headerlink" title="表关系"></a>表关系</h4><p>MySQL作为一个关系型数据，最大的特点便是通过表与表之间的关系，可以有效地存储和方便地处理数据</p><p><strong>关系表的设计就是要保证把信息分解成多个表，一类数据一个表。各表通过某些常用的值（即关系设计中的关系(relational)）互相关联。</strong></p><p>表与表之间的关系，通过外键进行关联。<strong>外键存在于两个拥有相同字段的表中，其中一个表的主键在另一个表中作为外键</strong>查找数据时，可以通过外键确定数据对应关系。</p><p>表关系又下面三种</p><ul><li><p>一对一关系：就是在一个表A中的一条数据，对应着另外一张表B中的一条数据，反过来也是。</p></li><li><p>一对多（多对一）关系：在一个表A中的一条数据对应着另外一个表B中的多条数据，但反过来另一个表B中的一条数据也只能对应表A中的一条数据，比如，爸爸和儿女，一个爸爸可以有很多儿女，但一个儿女只能有一个爸爸。</p></li><li><p>多对多关系：在一个表A中的一条数据对应另一个表B中的多条数据，同时，表B中的一条数据也对应着表A中的多条数据</p><p><img src="https://i.loli.net/2020/11/11/ki3lRrb2MfgV7hX.png" alt=""></p></li></ul><blockquote><p>  有关<strong>表关系</strong>更详细的内容可以看这两篇文章</p><p>  <a href="https://cloud.tencent.com/developer/article/1585927" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1585927</a></p><p>  <a href="https://blog.csdn.net/weixin_40001125/article/details/88252494" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40001125/article/details/88252494</a></p></blockquote><h4 id="表联结查询"><a href="#表联结查询" class="headerlink" title="表联结查询"></a>表联结查询</h4><p>如果数据存储在多个表中，怎样⽤用单条SELECT语句句检索出数据？</p><p>答案是使⽤用联结。简单地说，联结是⼀种机制，用来在一条SELECT语句中关联表，因此称之为联<br>结。</p><p>使⽤用特殊的语法，可以联结多个表返回一组输出，联结在运行时关联表中正确的行。</p><h5 id="内联结（等值连接）——INNER-JOIN"><a href="#内联结（等值连接）——INNER-JOIN" class="headerlink" title="内联结（等值连接）——INNER JOIN"></a>内联结（等值连接）——INNER JOIN</h5><p>获取两个表中字段匹配关系的记录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 表名1.字段名1,表名2.字段名2... FROM 表名1 INNER JOIN 表名2 ON 表名1.字段名3 &#x3D; 表名2.字段名3;</span><br></pre></td></tr></table></figure><p>也可以省略 INNER ，只写一个 JOIN。</p><p><img src="https://i.loli.net/2020/11/11/B9bHELYmCAZwiJ1.png" alt=""></p><blockquote><p>  举例：我们需要查询出所有的商品及对应的供应商信息：    </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors INNER JOIN products</span><br><span class="line">ON vendors.vend_id &#x3D; products.vend_id</span><br><span class="line">-- 查询结果</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| vend_name   | prod_name      | prod_price |</span><br><span class="line">+-------------+----------------+------------+</span><br><span class="line">| ACME        | Bird seed      |      10.00 |</span><br><span class="line">| ACME        | Carrots        |       2.50 |</span><br><span class="line">| ACME        | Detonator      |      13.00 |</span><br><span class="line">| ACME        | Safe           |      50.00 |</span><br><span class="line">| ACME        | Sling          |       4.49 |</span><br><span class="line">| ACME        | TNT (1 stick)  |       2.50 |</span><br><span class="line">| ACME        | TNT (5 sticks) |      10.00 |</span><br><span class="line">| Anvils R Us | .5 ton anvil   |       5.99 |</span><br><span class="line">| Anvils R Us | 1 ton anvil    |       9.99 |</span><br><span class="line">| Anvils R Us | 2 ton anvil    |      14.99 |</span><br><span class="line">| Jet Set     | JetPack 1000   |      35.00 |</span><br><span class="line">| Jet Set     | JetPack 2000   |      55.00 |</span><br><span class="line">| LT Supplies | Fuses          |       3.42 |</span><br><span class="line">| LT Supplies | Oil can        |       8.99 |</span><br><span class="line">+-------------+----------------+------------+</span><br></pre></td></tr></table></figure><p>  上面语句等价于：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_name,prod_name,prod_price</span><br><span class="line">FROM vendors,products</span><br><span class="line">WHERE vendors.vend_id &#x3D; products.vend_id</span><br></pre></td></tr></table></figure></blockquote><p>多表联结：SQL对⼀一条SELECT语句句中可以联结的表的数目没有限制。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT 表名1.字段名1,表名2.字段名2... </span><br><span class="line">FROM 表名1 </span><br><span class="line">INNER JOIN 表名2 ON 表名1.字段名3 &#x3D; 表名2.字段名3</span><br><span class="line">INNER JOIN 表名3 ON 表名2.字段名4 &#x3D; 表名3.字段名4</span><br><span class="line">...</span><br><span class="line">(WHERE 过滤条件);</span><br><span class="line">-- ON 后面跟联结条件</span><br></pre></td></tr></table></figure><h5 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h5><p>自联结在查询一些特定数据时可以作为子嵌套查询的替代</p><p>这时候，就需要自己与自己进行联结，为了区分，需要用AS取一个别名</p><blockquote><p>  举例：</p><p>  假如你发现某物品（其ID为DTNTR）存在问题，因此想知道生产该物品的供应商生产的其他物品是否也存在这些问题。此查询要求首先找到生产ID为DTNTR的物品的供应商，然后找出这个供应商生产的其他物品。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-- 1.自联结 JOIN</span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1 </span><br><span class="line">JOIN products AS p2</span><br><span class="line">ON p1.vend_id &#x3D; p2.vend_id </span><br><span class="line">WHERE p2.prod_id &#x3D; &#39;DTNTR&#39;;</span><br><span class="line">-- 2.自联结 WHERE</span><br><span class="line">SELECT p1.prod_id,p1.prod_name</span><br><span class="line">FROM products AS p1,products AS p2</span><br><span class="line">WHERE p1.vend_id &#x3D; p2.vend_id AND p2.prod_id &#x3D; &#39;DTNTR&#39;;</span><br><span class="line">-- 3.子查询</span><br><span class="line">SELECT prod_id,prod_name</span><br><span class="line">FROM products</span><br><span class="line">WHERE vend_id &#x3D; (SELECT vend_id FROM products WHERE prod_id &#x3D; &#39;DTNTR&#39;);</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+</span><br><span class="line">| prod_id | prod_name      |</span><br><span class="line">+---------+----------------+</span><br><span class="line">| DTNTR   | Detonator      |</span><br><span class="line">| FB      | Bird seed      |</span><br><span class="line">| FC      | Carrots        |</span><br><span class="line">| SAFE    | Safe           |</span><br><span class="line">| SLING   | Sling          |</span><br><span class="line">| TNT1    | TNT (1 stick)  |</span><br><span class="line">| TNT2    | TNT (5 sticks) |</span><br><span class="line">+---------+----------------+</span><br></pre></td></tr></table></figure></blockquote><p>自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候<strong>处理联结远比处理子查询快得多</strong>。</p><h5 id="外部联结"><a href="#外部联结" class="headerlink" title="外部联结"></a>外部联结</h5><ul><li><p>左联结 LEFT JOIN：以左侧表为基准，去关联右侧的表进行联结，如果有未关联的数据，那么结果为null</p></li><li><p>右联结 RIGHT JOIN：以右侧表为基准，去关联左侧的表进行联结，如果有未关联的数据，那么结果为null</p><p>  <img src="https://i.loli.net/2020/11/11/NszZBtwy3GSOMcU.png" alt=""></p></li></ul><blockquote><p>  例如：我们要对每个客户下了多少订单进行计数，<strong>包括那些至今尚未下订单的客户</strong>；</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">-- 1.内部联结。它检索所有客户及其订单：</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM customers INNER JOIN orders </span><br><span class="line">ONcustomers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br><span class="line">-- 明显这种方式不能达到我们的要求，它不包含至今尚未下订单的客户 10002</span><br><span class="line"></span><br><span class="line">-- 2.外部联结。检索所有客户，包括那些没有订单的客户</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM customers LEFT JOIN orders </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">-- 也可以写成这样</span><br><span class="line">SELECT customers.cust_id,orders.order_num </span><br><span class="line">FROM orders RIGHT JOIN customers </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id;</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+-----------+</span><br><span class="line">| cust_id | order_num |</span><br><span class="line">+---------+-----------+</span><br><span class="line">|   10001 |     20005 |</span><br><span class="line">|   10001 |     20009 |</span><br><span class="line">|   10002 |      NULL |</span><br><span class="line">|   10003 |     20006 |</span><br><span class="line">|   10004 |     20007 |</span><br><span class="line">|   10005 |     20008 |</span><br><span class="line">+---------+-----------+</span><br><span class="line"></span><br><span class="line">-- 加入订单量计数</span><br><span class="line">SELECT customers.cust_id,customers.cust_name,COUNT(orders.order_num) AS num_ord</span><br><span class="line">FROM customers LEFT JOIN orders </span><br><span class="line">ON customers.cust_id &#x3D; orders.cust_id</span><br><span class="line">GROUP BY customers.cust_id;</span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line">| cust_id | cust_name      | num_ord |</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line">|   10001 | Coyote Inc.    |       2 |</span><br><span class="line">|   10002 | Mouse House    |       0 |</span><br><span class="line">|   10003 | Wascals        |       1 |</span><br><span class="line">|   10004 | Yosemite Place |       1 |</span><br><span class="line">|   10005 | E Fudd         |       1 |</span><br><span class="line">+---------+----------------+---------+</span><br><span class="line"></span><br><span class="line">-- 列出所有产品以及订购数量量，包括没有⼈人订购的产品；</span><br><span class="line">select products.prod_id,products.prod_name,count(orderitems.order_num) AS num_ord</span><br><span class="line">from products left join orderitems</span><br><span class="line">on products.prod_id &#x3D; orderitems.prod_id</span><br><span class="line">group by products.prod_id;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>表联结注意事项</strong></p><ul><li>保证使⽤用正确的联结条件，否则将返回不不正确的数据。</li><li>应该总是提供联结条件，否则会得出笛卡⼉儿积。</li><li>在一个联结中可以包含多个表，甚至对于每个联结可以采⽤用不同的联结类型。虽然这样做是合法的，一般也很有用，但应该在一起测试它们前，分别测试每个联结。这将使故障排除更为简单</li></ul></blockquote><h3 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h3><p>MySQL也允许执行多个查询（多条SELECT语句句），并将结果作为单个查询结果集返回。这些组合查询通常称为并（union）或复合查询（compound query）。</p><p><strong>UNION规则</strong></p><ul><li>UNION必须由两条或两条以上的SELECT语句组成，语句之间用关键字UNION分隔（因此，如果组合4条SELECT语句句，将要使用3个UNION关键字）。</li><li>UNION中的每个查询必须包含相同的列、表达式或聚集函数（不过各个列不需要以相同的次序列出）</li><li>列数据类型必须兼容：类型不必完全相同，但必须是DBMS可以隐含地转换的类型（例如，不同的数值类型或不同的日期类型）。</li></ul><blockquote><p>  举例：假如需要价格小于等于5的所有物品的一个列表，而且还想包括供应商1001和1002生产的所有物品。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002);</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line"></span><br><span class="line">-- UNION会从查询结果集中自动去除了重复的行 这是UNION的默认行为，但是如果需要，可以改变它。</span><br><span class="line">-- 如果想返回所有匹配的行，可使用UNION ALL</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002);</span><br><span class="line"></span><br><span class="line">-- 结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |-- 重复数据</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">|    1002 | FU1     |       3.42 | -- 重复数据</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure><p>  <strong>对组合查询结果排序</strong></p><p>  SELECT语句的输出用ORDER BY子句排序。在⽤UNION组合查询时，只能使⽤一条ORDER BY子句，它必须出现在最后一条SELECT语句之后。<strong>ORDER BY子句是对整个结果集排序</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE prod_price &lt;&#x3D; 5</span><br><span class="line">UNION</span><br><span class="line">SELECT vend_id,prod_id,prod_price FROM products WHERE vend_id in(1001,1002)</span><br><span class="line">ORDER BY prod_price;</span><br><span class="line"></span><br><span class="line">-- 查询结果</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">| vend_id | prod_id | prod_price |</span><br><span class="line">+---------+---------+------------+</span><br><span class="line">|    1003 | FC      |       2.50 |</span><br><span class="line">|    1003 | TNT1    |       2.50 |</span><br><span class="line">|    1002 | FU1     |       3.42 |</span><br><span class="line">|    1003 | SLING   |       4.49 |</span><br><span class="line">|    1001 | ANV01   |       5.99 |</span><br><span class="line">|    1002 | OL1     |       8.99 |</span><br><span class="line">|    1001 | ANV02   |       9.99 |</span><br><span class="line">|    1001 | ANV03   |      14.99 |</span><br><span class="line">+---------+---------+------------+</span><br></pre></td></tr></table></figure></blockquote><h2 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h2><p>事务（Transaction）是由⼀系列对系统中数据进行访问与更新的操作所组成的一个程序执行逻辑单元。</p><p><img src="https://i.loli.net/2020/11/13/mEoWeQDFin72Rhd.png" alt=""></p><p>事务的基本语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start transaction;或者 begin;</span><br><span class="line">-- 事务操作的语句</span><br><span class="line">commit; -- 使得当前的修改确认</span><br><span class="line">rollback; -- 使得当前的修改被放弃</span><br></pre></td></tr></table></figure><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ol><li><p><strong>原子性（Atomicity）</strong></p><p> 事务的原子性是指事务必须是一个原子的操作序列单元。事务中包含的各项操作在一次执行过程中，要么全部执行成功，要么全部执行失败。</p><p> 事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，<br> 会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体。</p></li><li><p><strong>一致性（Consistency）</strong></p><p> 事务的一致性是指事务的执行不能破坏数据库数据的完整性和一致性，不能时数据发生错乱</p></li><li><p><strong>隔离性（Isolation）</strong></p><p> 事务的隔离性是指在<strong>并发环境</strong>中，<strong>并发的事务</strong>是互相隔离的，各有各自的数据空间。</p></li><li><p><strong>持久性（Duration）</strong></p><p> 事务的持久性是指事务一旦提交后，数据库中的数据必须被永久的保存下来。即使服务器系统崩溃或服务器宕机，只要数据库重新启动，那么一定能够将其恢复到事务成功结束后的状态。</p></li></ol><h3 id="事务并发常见问题"><a href="#事务并发常见问题" class="headerlink" title="事务并发常见问题"></a>事务并发常见问题</h3><ul><li><p>脏读（Dirty Read）：读取到了没有提交的数据。</p><p>例如：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据就是脏数据。</p></li><li><p>不可重复读（Unrepeatale Read）：同⼀条命令返回不同的结果集</p><p>例如：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。</p></li><li><p>幻读（Phantom Read）：重复查询的过程中，数据就发生了量的变化。</p></li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><table><thead><tr><th>事务隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(READ_UNCOMMITTED)</td><td>允许</td><td>允许</td><td>允许</td></tr><tr><td>读已提交(READ_COMMITTED)</td><td>禁止</td><td>允许</td><td>允许</td></tr><tr><td>可重复读(REPEATABLE_READ)</td><td>禁止</td><td>禁止</td><td>可能会</td></tr><tr><td>顺序读(SERIALIZABLE)</td><td>禁止</td><td>禁止</td><td>禁止</td></tr></tbody></table><blockquote><p>  4种事务隔离级别从上往下，级别越高，并发性越差，安全性就越高。 一般数据默认级别是读已提交或可重复读。</p></blockquote><blockquote><p>  <strong>查看和设置事务隔离级别的语句</strong></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查看当前会话中事务的隔离级别</span><br><span class="line">select @@tx_isolation;</span><br><span class="line">-- 设置当前会话中的事务隔离级别</span><br><span class="line">set session transaction isolation level read uncommitted | read committed | repeatable read |  SERIALIZABLE</span><br></pre></td></tr></table></figure></blockquote><ol><li><p><strong>读未提交(READ_UNCOMMITTED)</strong></p><p>该隔离级别允许脏读取，其隔离级别是最低的。一个事务正在处理某⼀数据，并对其进行了更新，但同时尚未完成事务，因此还没有提交事务，而与此同时，允许另一个事务也能够访问该数据。</p></li><li><p><strong>读已提交(READ_COMMITTED)</strong></p><p>不同的事务执行的时候只能获取到已经提交的数据。 这样就不会出现上面的脏读的情况了。但是在同一个事务中执行同一个读取，结果不一致，即不可重复读问题</p></li><li><p><strong>可重复读(REPEATABLE_READ)</strong></p><p>保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别限制了不可重复读和脏读，但是有可能出现幻读的数据。</p></li><li><p><strong>顺序读(SERIALIZABLE)</strong></p><p>最严格的事务隔离级别，不允许事务并发，必须依次排序执行。</p></li></ol><p><strong>不同的隔离级别的锁的情况</strong></p><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁。它与RC的区别是能够查询到未提交的数据。</li><li>读已提交（RC）：有行级的锁，没有间隙锁，读不到没有提交的数据。</li><li>可重复读（RR）：有行级的锁，也有间隙锁，每次读取的数据都是一样的，并且没有幻读的情况。</li><li>序列列化（S）：有行级锁，也有间隙锁，读表的时候，就已经上锁了。</li></ol><h2 id="MySQL存储过程"><a href="#MySQL存储过程" class="headerlink" title="MySQL存储过程"></a>MySQL存储过程</h2><p>存储过程简单来说，就是为以后的使用而保存的一条或多条MySQL语句的集合。</p><p>存储过程就像脚本语⾔言中函数定义⼀样，是一组为了完成特定功能的SQL语句集，经过编译之后存储在数据库中，在需要时直接调用。</p><p><strong>创建存储过程</strong> ：<code>create procedure 存储过程名()</code> </p><blockquote><p>  <code>\d //</code>：修改MySQL默认的语句结尾符<code>;</code>改为<code>//</code> 。</p><p>  <code>create procedure 存储过程名()</code>  创建语句</p><p>  <code>BEGIN</code>和<code>END</code>语句用来限定存储过程体</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 定义存储过程 向users表中循环插入80条数据</span><br><span class="line">\d &#x2F;&#x2F;</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">set @i&#x3D;10;</span><br><span class="line">while @i&lt;90 do</span><br><span class="line">insert into users values(null,concat(&#39;user:&#39;,@i),@i,0); -- </span><br><span class="line">set @i&#x3D;@i+1;</span><br><span class="line">end while;</span><br><span class="line">end;</span><br><span class="line">&#x2F;&#x2F;</span><br></pre></td></tr></table></figure><p><strong>调用存储过程</strong>： <code>call 存储过程名()</code></p><p><strong>查看存储过程</strong>：<code>show create procedure 存储过程名\G</code></p><p><strong>删除存储过程</strong>：<code>drop procedure 存储过程名</code></p><h2 id="MySQL触发器"><a href="#MySQL触发器" class="headerlink" title="MySQL触发器"></a>MySQL触发器</h2><p>触发器是指MySQL<strong>响应</strong>写操作(增、删、改)而<strong>自动执行</strong>的一条或一组定义在BEGIN和END之间的MySQL语句。</p><p>或可理理解为：提前定义好一个或一组操作,在指定的SQL操作前或后来触发指定的SQL自动执行，触发器就像是JavaScript中的事件一样。</p><p><strong>触发器语法</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-- 创建触发器</span><br><span class="line">\d &#x2F;&#x2F;</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event</span><br><span class="line">ON tbl_name FOR EACH ROW </span><br><span class="line">BEGIN</span><br><span class="line">trigger_stmt;</span><br><span class="line">END;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">\d ; -- 结束之后要把语句结束符改回来</span><br><span class="line">-- 说明：</span><br><span class="line"># trigger_name：触发器名称</span><br><span class="line"># trigger_time:触发时间，可取值：BEFORE或AFTER</span><br><span class="line"># trigger_event：触发事件，可取值：INSERT、UPDATE或DELETE。</span><br><span class="line"># tb1_name：指定在哪个表上</span><br><span class="line"># trigger_stmt：触发理SQL语句。</span><br><span class="line"></span><br><span class="line">-- 查看所有的 触发器器</span><br><span class="line">show triggers\G;</span><br><span class="line"></span><br><span class="line">-- 删除触发器</span><br><span class="line">drop trigger trigger_name;</span><br></pre></td></tr></table></figure><blockquote><p>  在使用触发器时，可以建立虚拟表来方便某些操作</p><ul><li>在INSERT触发器代码内，可引用⼀个名为NEW的虚拟表，访问被 插入的行;</li><li>在DELETE触发器代码内，可引用一个名为OLD的虚拟表，访问被删除的行;<ul><li>OLD中的值全都是只读的，不能更新。</li><li>在AFTER DELETE的触发器中无法获取OLD虚拟表</li></ul></li><li>在UPDATE触发器代码中<ul><li>可以引用一个名为OLD的虚拟表访问更新以前的值<br>可以引用一个名为NEW的虚拟表访问新更新的值;</li></ul></li></ul></blockquote><h2 id="MySQL的视图"><a href="#MySQL的视图" class="headerlink" title="MySQL的视图"></a>MySQL的视图</h2><p><strong>视图的定义及特性</strong></p><p>视图是虚拟的表。与包含数据的表不一样，视图只包含使用时动态检索数据的查询语句。</p><p>视图本身不不包含数据，它们返回的数据是从其他表中检索出来的。</p><p><strong>视图的作用</strong></p><ul><li><p>重用SQL语句，简化复杂的SQL操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节。</p></li><li><p>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</p></li><li><p>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</p></li></ul><blockquote><p>  <strong>注意：视图不能索引，也不不能有关联的触发器或默认值</strong>。</p></blockquote><p><strong>视图的语法和使用</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-- 创建视图</span><br><span class="line">create view 视图名 as 要封装的select语句;</span><br><span class="line">-- 例如：</span><br><span class="line">create view v_users as select id,name,age from users where age &gt;&#x3D; 25 and age&lt;&#x3D; 35;</span><br><span class="line"></span><br><span class="line">-- 查看当前库中所有的视图</span><br><span class="line">show tables; -- 可以查看到所有的表和视图</span><br><span class="line">show table status where comment&#x3D;&#39;view&#39;\G; -- 只查看当前库中的所有视图</span><br><span class="line"></span><br><span class="line">-- 删除视图v_t1:</span><br><span class="line">drop view 视图名;</span><br></pre></td></tr></table></figure><h2 id="MySQL索引与优化"><a href="#MySQL索引与优化" class="headerlink" title="MySQL索引与优化"></a>MySQL索引与优化</h2><h3 id="索引概述"><a href="#索引概述" class="headerlink" title="索引概述"></a>索引概述</h3><p><strong>定义</strong></p><p>MySQL官方对索引的定义为：<strong>索引(Index)是帮助MySQL高效获取数据的数据结构。</strong></p><p>索引类似图书的目录，是一种有序结构，可以提高数据检索的效率，降低数据库的IO成本。</p><p><strong>分类</strong></p><table><thead><tr><th>索引类型</th><th>说明</th></tr></thead><tbody><tr><td>主键索引</td><td>根据主键建立的索引。<strong>不允许重复，不允许空值</strong>。<br>如果表中没有定义主键，InnoDB 会选择一个唯⼀的非空索引代替；如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。</td></tr><tr><td>唯一索引</td><td>用来建立索引的列的值必须是<strong>唯一的，允许空值</strong></td></tr><tr><td>普通索引</td><td>用表中普通列构建的索引，没有任何限制</td></tr><tr><td>全文索引</td><td>用大文本对象的列构建的索引（5.6之前MyISAM支持，InnoDB不支持；8.0之前不支持中文。）</td></tr><tr><td>组合索引</td><td>用多个列组合构建的索引，这多个列的值不允许空值，<strong>需遵循“最左”原则</strong></td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-- 创建索引和删除索引</span><br><span class="line">-- 1.主键索引 </span><br><span class="line">-- 1.创建表时，直接创建主键索引 PRIMARY KEY</span><br><span class="line">CREATE TABLE users( </span><br><span class="line">        id int NOT NULL AUTO_INCREMENT PRIMARY KEY</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4;</span><br><span class="line">-- 2.修改时添加主键和自增</span><br><span class="line">alter table users modify uid int primary key AUTO_INCREMENT;</span><br><span class="line">-- 删除主键索引注意需要先取消自增，再删除主键</span><br><span class="line">-- 先取消自增,修改字段</span><br><span class="line">alter table users modify uid int;</span><br><span class="line">-- 删除主键</span><br><span class="line">alter table users drop primary key;</span><br><span class="line">-- 2.唯一索引 </span><br><span class="line">-- 1.创建表时,直接创建唯一索引UNIQUE KEY</span><br><span class="line">    CREATE TABLE users(</span><br><span class="line">    name varchar(10) NOT NULL ,</span><br><span class="line">    UNIQUE KEY name(name),-- name为索引名</span><br><span class="line">    )ENGINE&#x3D;InnoDB DEFAULT CHARSET-utf8mb4</span><br><span class="line">    --  2.添加唯一索引UNIQUE当前列要求唯一，但允许为空</span><br><span class="line">    alter table users add untque u_name(name); -- u_name为索引名</span><br><span class="line">    -- 删除唯一索引</span><br><span class="line">    alter table users drop index u_name;</span><br><span class="line">-- 3.普通索引</span><br><span class="line">-- 1.创建表时，直接创建普通索引 KEY</span><br><span class="line">    CREATE TABLE users(</span><br><span class="line">    email varchar ( 10 ) NOT NULL ,</span><br><span class="line">    KEY  index_email(email)-- index_email为索引名</span><br><span class="line">    )ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8mb4</span><br><span class="line">    -- 2.添加索引</span><br><span class="line">    alter table users add index in_email(email);</span><br><span class="line">    -- 删除普通索引</span><br><span class="line">    drop index in_email on users;</span><br><span class="line">-- 4.添加全文索引</span><br><span class="line">ALERT TABLE 表名 ADD FULLTEXT INDEX 索引名(要建立索引的字段);</span><br><span class="line">-- 5.组合索引 </span><br><span class="line">-- 添加索引</span><br><span class="line">alter table users add index in_x(email,phone,uname)</span><br><span class="line">-- 删除索引</span><br><span class="line">alter table users drop index in_x;</span><br></pre></td></tr></table></figure><h3 id="索引原理-索引与B-Tree"><a href="#索引原理-索引与B-Tree" class="headerlink" title="索引原理-索引与B+Tree"></a>索引原理-索引与B+Tree</h3><blockquote><p>  <strong>哈希索引</strong></p><p>  只有memory（内存）存储引擎支持哈希索引，哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能。</p></blockquote><p>正常情况下，如果不指定索引的类型，那么一般是指B+Tree索引。</p><p>存储引擎以不同的方式使用B+Tree索引。性能也各有不同，InnoDB时按照原数格式进行存储的。</p><p>首先，要了解B+树之前，我们先了解一下B树，<strong>B树是一种自平衡树状结构，一般多用于存储系统上</strong>，比如数据库或文件系统。</p><blockquote><p>  一个n阶的B树，每个节点可以存储n-1个值</p></blockquote><p><img src="https://i.loli.net/2020/11/14/R9swUcgBDSIWZ5p.png" alt=""></p><p>可以看到B树每个叶子节点都带有数据，在效率上还是存在一些弊端，可以进行优化，提高查询效率，便演变出了B+树，如下图所示</p><p><img src="https://i.loli.net/2020/11/14/FeBMcODgiwTVfqA.png" alt="image-20201114211729600"></p><p>使用B+树的优势</p><ol><li><p>磁盘读写代价更低</p><p>B树的数据和索引都在同一个节点上，那么每个块中包含的索引是少量的，如果想要取出比较深层的数据，意味着要读取更多的块，才能得到想要的索引和数据，那么就增加了IO次数；</p><p>而B+树中每个块能存储的索引是B树的很多倍，那么获取比较深层的数据，也只需要读取少量的块<br>就可以，那么就减少了磁盘的IO次数</p></li><li><p>随机IO的次数更少</p><p>随机I/O是指读写操作时间连续，但访问地址不连续，时长约为10ms。</p><p>顺序I/O是指读取和写入操作基于逻辑块逐个连续访问来自相邻地址的数据，时长约为0.1ms</p><p>在相同情况下，B树要进行更多的随机IO，而B+树需要更多的顺序IO，因此B+树，效率也更快</p></li><li><p>查询速度更稳定</p><p>由于B+Tree非叶子节点不存储数据（data)，因此所有的数据都要查询至叶子节点，而叶子节点的<br>高度都是相同的，因此所有数据的查询速度都是一样的。</p></li></ol><h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p><strong>聚簇索引：</strong>索引即数据，找到索引便找到了数据</p><p><strong>非聚簇索引：</strong>索引是一个文件，数据在另一个文件，根据索引文件找到数据的key值，然后到数据文件中根据key值找到数据</p><p><img src="https://i.loli.net/2020/11/14/g98ev1TwkP5cAUS.png" alt=""></p><blockquote><p>  <strong>MyISAM的索引方案</strong></p><p>  InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了了，而MyISAM的索引方案虽然也使用树形结构，但是却将索引和数据分开存储，也就是把索引信息单独存到一个文件中，这个文件称为索引文件。</p><p>  MyISAM会单独为表的主键创建⼀个索引，只不过在索引的叶子节点中存储的不是完整的数据记录，而是主键值 + 行号的组合。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！其它非主键索引也是一样的，这种情况我们称为“回行”。所以在MyISAM中所有的索引都是非聚簇索引，也叫二级索引。</p><p>  <img src="https://i.loli.net/2020/11/14/PbsI1ugyhd9UZGz.png" alt=""></p><p>  <strong>MyISAM和InnoDB的区别</strong></p><ul><li><p>数据存储方式：</p><ul><li>InnoDB由两种文件组成，表结构、数据和索引</li><li>MyISAM由三种文件组成，表结构、数据、索引</li></ul></li><li><p>索引的方式：</p><ul><li>索引的底层都是基于B+Tree的数据结构建立</li><li>InnoDB中主键索引为聚簇索引，辅助索引是非聚簇索引</li><li>MyISAM中数据和索引存在不同的文件中，因此都是非聚簇索引</li></ul></li><li><p>事务的支持：</p><ul><li>InnoDB支持事务</li><li>MyISAM不支持事务</li></ul></li></ul></blockquote><h3 id="慢查询与SQL优化"><a href="#慢查询与SQL优化" class="headerlink" title="慢查询与SQL优化"></a>慢查询与SQL优化</h3><h4 id="慢查询与Explain执行计划"><a href="#慢查询与Explain执行计划" class="headerlink" title="慢查询与Explain执行计划"></a>慢查询与Explain执行计划</h4><p>MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。</p><p>默认情况下，MySQL数据库并不启动慢查询目思，需要手动来设置这个参数。如果不是调优需要的话，一般不建议启动该参数，开启慢查询日志会或多或少带来一定的性能影响。</p><p><img src="https://i.loli.net/2020/11/14/dlLvRoOMuDXxQY8.png" alt=""></p><p><strong>Explain执行计划</strong></p><p>一条查询语句在经过MySQL查询优化器的各种基于成本和规则的优化会后生成一个所谓的执行计划。这个执行计划展示了接下来具体执行查询的方式，比如多表连接的顺序是什么，对于每个表采用什么访问方法来具体执行查询等等。MySQL为我们提供了EXPLAIN语句来帮助我们查看某个语句的具体执行计划。</p><p><img src="https://i.loli.net/2020/11/14/V5hRgPtf2BxEYM1.png" alt=""></p><table><thead><tr><th>参数</th><th>参数解释</th></tr></thead><tbody><tr><td>id</td><td>在一个大的查询语句中每个 SELECT关键字都对应一个唯一的 id</td></tr><tr><td>select_type</td><td>SELECT关键字对应的那个查询的类型</td></tr><tr><td>table</td><td>表名</td></tr><tr><td>partitions</td><td>匹配的分区信息</td></tr><tr><td>type</td><td>针对单表的访问方法</td></tr><tr><td>possible_keys</td><td>可能用到的索引</td></tr><tr><td>key</td><td>实际上使用的索引</td></tr><tr><td>key_len</td><td>实际使用到的索引长度</td></tr><tr><td>ref</td><td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td></tr><tr><td>rows</td><td>预估的需要读取的记录条数</td></tr><tr><td>ﬁltered</td><td>某个表经过搜索条件过滤后剩余记录条数的百分比</td></tr><tr><td>Extra</td><td>一些额外的信息</td></tr></tbody></table><h3 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h3><p><strong>索引优化</strong></p><ul><li><p>适当建立索引</p><ul><li>创建并使用自增数字来建立主键索引</li><li>为经常作为where条件的字段建立索引</li><li>添加索引的字段尽可能的保持唯一性</li><li>可考虑使用组合索引并进行<em>索引覆盖</em>(多个字段组合成一个联合索引，在查询时，所要的字段和查询条件中的索引是一致的)</li><li>索引绝不是加的越多越好，每建立一个索引都会建立一棵B+树，并且需要维护，很费性能和存储空间。</li></ul></li><li><p>合理使用索引，查询时避免索引失效</p><ul><li>不要在查询的索引列上使用函数</li><li>不要在查询的索引列上进行运算</li><li>避免查询条件左右类型不匹配发生隐式转换</li><li>使用like模糊查询时避免通配符%放在第一位</li><li>多个单列索引并不是最佳选择，可以使用组合索引</li><li>使用组合查询时谨记最左前缀原则（从最左字段开始使用索引：查询条件中使用了组合索引的第一个字段，索引才会被使用。因此，在组合索引中索引列的顺序至关重要。如果不是按照索引的最左列开始查找，则无法使用索引。）</li></ul></li></ul><p><strong>SQL语句的优化</strong></p><ul><li>避免嵌套语句（子查询）</li><li>避免多表查询（复杂查询简单化）</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DQL数据查询进阶&quot;&gt;&lt;a href=&quot;#DQL数据查询进阶&quot; class=&quot;headerlink&quot; title=&quot;DQL数据查询进阶&quot;&gt;&lt;/a&gt;DQL数据查询进阶&lt;/h2&gt;&lt;p&gt;这里所用到的表结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/11/T2PUqaGgcXIZv18.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.pengspace.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL数据库基础</title>
    <link href="https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.pengspace.top/2020/11/16/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-16T11:36:21.000Z</published>
    <updated>2020-11-16T11:49:29.169Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库介绍"><a href="#数据库介绍" class="headerlink" title="数据库介绍"></a>数据库介绍</h2><ul><li><p>什么是数据库</p><p>数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库。<br>专业的数据库是专门对数据进行创建，访问，管理，搜索等操作的软件，比起我们自己用文件读写的方式，用它对数据进行管理更加的方便，快速，安全。</p></li></ul><a id="more"></a><ul><li><p>数据库特点及作用</p><ul><li>对数据进行持久化的保存</li><li>方便数据的存储和查询，速度快，安全，方便</li><li>可以处理并发访问</li><li>更加安全的权限管理访问机制</li></ul></li><li><p>常见的数据库</p><p>数据库分两大类，一类是 <a href="https://baike.baidu.com/item/%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93/8999831?fr=aladdin" target="_blank" rel="noopener">关系型数据库</a>。另一类叫做 <a href="https://baike.baidu.com/item/NoSQL/8828247?fromtitle=%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93&fromid=6376860&fr=aladdin" target="_blank" rel="noopener">非关系型数据库</a>。</p><ul><li>关系型数据库： MySQL，Oracle，PostgreSQL，SQLserver…</li><li>非关系型数据库：Redis内存数据库，MongoDB文档数据库…</li></ul><p><img src="https://i.loli.net/2020/11/07/fdz4w9cKgm5eoqu.png" alt=""></p><p>关系型数据库与非关系型数据库对比可以看这篇文章:</p><p><a href="https://my.oschina.net/u/3647687/blog/1534979" target="_blank" rel="noopener">https://my.oschina.net/u/3647687/blog/1534979</a></p></li></ul><blockquote><p>  ‘</p><p>  MySQL是最流行的关系型数据库管理系统</p><p>  关于数据库的一些概念</p><ul><li><p>数据库 Database</p></li><li><p>数据表 Tables</p></li><li><p>数据字段 filed</p></li><li><p>行 row ：每一行就是一条数据</p></li><li><p>列 col</p><p><img src="https://i.loli.net/2020/11/07/tqBQ3OWFiJYAVXM.png" alt=""></p><p><img src="https://i.loli.net/2020/11/07/4JtSwzNr2am3qZb.png" alt=""></p></li></ul></blockquote><h2 id="MySql基础操作"><a href="#MySql基础操作" class="headerlink" title="MySql基础操作"></a>MySql基础操作</h2><h3 id="使用MySql的三种方式："><a href="#使用MySql的三种方式：" class="headerlink" title="使用MySql的三种方式："></a>使用MySql的三种方式：</h3><blockquote><p>  方式一：通过在命令行敲命令来操作</p><p>  方式二：通过图型界面工具,如 Navicat 等</p><p>  方式三：通过编程语言(python,php,java,go…)执行mysql命令</p></blockquote><h3 id="SQL-Structure-query-language-结构化查询语言"><a href="#SQL-Structure-query-language-结构化查询语言" class="headerlink" title="SQL ( Structure query language ) 结构化查询语言"></a>SQL ( Structure query language ) 结构化查询语言</h3><blockquote><p>  SQL语言分为4个部分：DDL（定义）、DML（操作）、DQL（查询）、DCL（控制）</p></blockquote><p>####SQL语句中的快捷指令</p><blockquote><p>  <code>\G</code> 格式化输出（文本式，竖立显示）</p><p>  <code>\s</code> 查看服务器端信息</p><p>  <code>\c</code> 结束命令输入操作</p><p>  <code>\q</code>退出当前sql命令行模式</p><p>  <code>\h</code> 查看帮助</p></blockquote><h3 id="数据库操作步骤-windows命令行"><a href="#数据库操作步骤-windows命令行" class="headerlink" title="数据库操作步骤(windows命令行)"></a>数据库操作步骤(windows命令行)</h3><ol><li><strong>开启数据库服务：</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start 你电脑中mysql服务的服务名</span><br></pre></td></tr></table></figure><blockquote><p>  你mysql服务的服务名一般安装时就指定好的，默认是mysql。如果不是可以从系统服务里找一下</p><p>  windows中查看你的mysql服务名</p><ol><li><p><kbd>win</kbd>+<kbd>R</kbd>键 打开运行，输入<code>services.msc</code>，确定</p><p><img src="https://i.loli.net/2020/11/07/dHBwemsUYk8Kr79.png" alt="image-20201107184754395"></p></li><li><p>找到你mysql的服务名</p><p><img src="https://i.loli.net/2020/11/07/Wv9U7rtKES5ohRZ.png" alt="image-20201107185331055"></p></li></ol></blockquote><p><img src="https://i.loli.net/2020/11/07/9NtUVPWJTiYzwGZ.png" alt=""></p><blockquote><p>  关闭数据库服务：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net stop 你电脑中mysql服务的服务名</span><br></pre></td></tr></table></figure></blockquote><ol start="2"><li><strong>连接数据库：</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 服务器地址 -u 用户名 -p (密码) -P 端口</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/07/iCOfXvus3qG7A26.png" alt="image-20201107190657607"></p><p>如果时本地操作可以省略 -h 和 -P，写成这样即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p (密码)</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>操作(增删改)</strong></li></ol><p>后面会详细讲解</p><ol start="4"><li><strong>退出MySql</strong></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exit;</span><br><span class="line">-- 或者</span><br><span class="line">quit;</span><br></pre></td></tr></table></figure><p>也可以用快捷命令<code>\q</code></p><h2 id="MySql数据类型"><a href="#MySql数据类型" class="headerlink" title="MySql数据类型"></a>MySql数据类型</h2><blockquote><p>  数据类型是定义列中可以存储什么类型的数据以及该数据实际怎样存储的基本规则</p><p>  数据类型限制存储在数据列中的数据的类型。例如，数值数据类型列只能接受数值类型的的数据</p><p>  在设计表时，应该特别重视所用的数据类型。使用错误的数据类型可能会严重地影响应用程序的功能和性能。</p><p>  后续更改包含数据的列不是一件小事（而且这样做可能会导致数据丢失），定义之后一般不会再修改字段的数据类型</p></blockquote><p><strong>基本常用的数据类型</strong></p><blockquote><p>  数据类型：整型、浮点型、字符串、日期等</p></blockquote><h3 id="字符串数据类型"><a href="#字符串数据类型" class="headerlink" title="字符串数据类型"></a>字符串数据类型</h3><p>最常用的数据类型是串数据类型。它们存储串，如名字、地址、电 话号码、邮政编码等。</p><p>最常用的有三种基本的串类型，分别为<strong>定长串<code>char</code></strong>、<strong>变长串<code>varchar</code></strong>和<strong>变成文本<code>text</code></strong></p><p><strong>定长串：<code>char</code></strong></p><ul><li><p>接受长度固定的字符串，其长度是在创建表时指定的。不允许存储多于指定长度字符的数据。</p></li><li><p>指定长度后，就会分配固定的存储空间用于存放数据</p></li></ul><blockquote><p>  <code>char(7)</code> 不管实际插入多少字符，它都会占用7个字符位置</p></blockquote><p><strong>变长串 ：<code>varchar</code></strong></p><ul><li>存储可变长度的字符串 </li></ul><blockquote><p>  <code>varchar(7)</code> 如果实际插入4个字符，那么它只占4个字符位置，当然插入的数据长度不能超过7个字符。</p></blockquote><blockquote><p>  <strong>注意：</strong></p><p>  既然变长串数据类型这样灵活，为什么还要使用定长串数据类型？</p><p>  回答：因为性能，MySQL处理定长列远比处理变长列快得多。</p></blockquote><p><strong>变长文本：<code>text</code></strong></p><p>变长文本类型存储，最大长度为64K</p><p><img src="https://i.loli.net/2020/11/07/YMBXG18lpdgKWVm.png" alt="串类型"></p><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>数值数据类型存储数值。MySQL支持多种数值数据类型，每种存储的数值具有不同的取值范围。支持的取值范围越大，所需存储空间越多。</p><p><img src="https://i.loli.net/2020/11/07/TrcszjHbp2lK7FR.png" alt="数值类型"></p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">decimal(5, 2) <span class="comment">--表示数值总共5位, 小数占2位</span></span><br><span class="line">tinyint <span class="comment">--1字节(8位) 0-255/-128-127</span></span><br><span class="line">int <span class="comment">--4字节。 -21亿-21亿/0-42亿</span></span><br><span class="line"><span class="comment">-- MySQL中没有专门存储货币的数据类型，一般情况下使用DECIMAL(8, 2)或float</span></span><br></pre></td></tr></table></figure><blockquote><p>  <strong>有符号或无符号</strong></p><p>  所有数值数据类型（除BIT和BOOLEAN外）都可以有符号或无符号</p><p>  有符号数值列可以存储正或负的数值</p><p>  无符号数值列只能存储正数。</p><p>  默认情况为有符号，但如果你知道自己不需要存储负值，可以使用UNSIGNED关键字</p></blockquote><h3 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h3><p>MySQL使用专门的数据类型来存储日期和时间值</p><p><img src="https://i.loli.net/2020/11/07/i9WorwyE14DXhZg.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">datetime <span class="comment">-- 8字节 范围：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</span></span><br></pre></td></tr></table></figure><h3 id="二进制数据类型"><a href="#二进制数据类型" class="headerlink" title="二进制数据类型"></a>二进制数据类型</h3><p>二进制数据类型可存储任何数据（甚至包括二进制信息），如图像、多媒体、字处理文档等</p><blockquote><p>  通常情况下，不会使用二进制数据类型进行存储到数据库中</p></blockquote><p><img src="https://i.loli.net/2020/11/07/xiOq49MkGC7mR2p.png" alt="二进制类型"></p><h3 id="表的字段约束"><a href="#表的字段约束" class="headerlink" title="表的字段约束"></a>表的字段约束</h3><ul><li><code>unsigned</code> 无符号(给数值类型使用，表示为正数，不写可以表示正负数都可以)</li><li>字段类型后面加括号限制宽度<ul><li>char(5)、varchar(7) 在字符类型后面加限制，表示字符串的长度</li><li>int(4) 没有意义，默认无符号的int为int(11)，有符号的int(10)，在数字类型后面只加(x)限制宽度没有意义。</li><li><code>int(4) unsigned zerofill</code>只有当给int类型设置有前导零(zerofill)时，设置int的宽度才有意义(不够长度会在前面补 0)。</li></ul></li><li><code>not null</code> 不能为空，在操作数据库时如果输入该字段的数据为NULL ，就会报错</li><li><code>default</code> 设置默认值</li><li><code>primary key</code> 主键不能为空，且唯一。一般和自动递增一起配合使用。</li><li><code>auto_increment</code> 定义列为自增属性，一般用于主键，数值会自动加1</li><li><code>unique</code> 唯一索引(数据不能重复:用户名)可以增加查询速度，但是会降低插入和更新速度</li></ul><h3 id="MySQL的运算符"><a href="#MySQL的运算符" class="headerlink" title="MySQL的运算符"></a>MySQL的运算符</h3><ul><li><p>算术运算符： +、 -、 *、 /或DIV、 %或MOD</p></li><li><p>比较运算符： =、 &gt;、 &lt;、 &gt;=、 &lt;=、!=</p></li><li><p>数据库特有的比较： in、not in、is null、is not null、like、between、and</p></li><li><p>逻辑运算符： and、or、not</p></li><li><p>like: 支持特殊符号 % 和 _  </p><p>其中 % 表示任意数量的任意字符， _ 表示任意一位字符</p><p><strong>详细内容可以看<a href="https://www.runoob.com/mysql/mysql-operator.html" target="_blank" rel="noopener">菜鸟编程MySQL运算符</a></strong></p></li></ul><h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><blockquote><p>  <font color=red>表中每一行都应该有可以唯一标识自己的一列，用于记录两条记录不能重复</font>，任意两行都不具有相同的主键值</p><p>  应该总是定义主键 虽然并不总是都需要主键，但大多数数据库设计人员都应保证他们创建的每个表具有一个主键，以便于以后的数据操作和管理。</p></blockquote><p><strong>对于主键的要求</strong></p><ul><li><p>记录一旦插入到表中，主键最好不要再修改</p></li><li><p>不允许NULL</p></li><li><p>不在主键列中使用可能会更改的值。（例如，如果使用一个名字作为主键以标识某个供应商，当该供应商合并或更改其名字时，就得更改这个主键。）</p></li><li><p>自增整数类型：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键</p></li><li><p>可以使用多个列作为联合主键，但联合主键并不常用。使用多列作为主键时，所有列值的组合必须是唯一的</p></li></ul><h2 id="MySql数据库表引擎与字符集"><a href="#MySql数据库表引擎与字符集" class="headerlink" title="MySql数据库表引擎与字符集"></a>MySql数据库表引擎与字符集</h2><h3 id="服务器处理客户端请求"><a href="#服务器处理客户端请求" class="headerlink" title="服务器处理客户端请求"></a>服务器处理客户端请求</h3><p>其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。</strong></p><p>那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：</p><p><img src="https://i.loli.net/2020/11/08/iW2HgJZTRpaGBby.png" alt=""></p><blockquote><p>  虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。</p></blockquote><h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p><code>MySQL</code> 服务器把<strong>数据的存储和提取操作</strong>都封装到了一个叫<strong>存储引擎</strong>的模块里。我们知道表是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是存储引擎负责的事情。为了实现不同的功能， <code>MySQL</code> 提供了各式各样的存储引擎，不同存储引<br>擎管理的表具体的存储结构可能不同，采用的存取算法也可能不同。</p><blockquote><p>  存储引擎以前叫做<strong>表处理器</strong>，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。</p></blockquote><p>为了管理方便，人们把<strong>连接管理、查询缓存、语法解析、查询优化</strong>这些并不涉及真实数据存储的功能划分为<br><code>MySQL server</code> 的功能，把真实存取数据的功能划分为存储引擎的功能。各种不同的存储引擎向上边的<code>MySQL server</code> 层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像”读取索引第一条内容”、”读取索引下一条内容”、”插入记录”等等。</p><p>所以在MySQL server 完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。</p><p>MySQL 支持非常多种存储引擎：</p><table><thead><tr><th>存储引擎</th><th>描述</th></tr></thead><tbody><tr><td><code>ARCHIVE</code></td><td>用于数据存档（行被插入后不能再修改）</td></tr><tr><td><code>BLACKHOLE</code></td><td>丢弃写操作，读操作会返回空内容</td></tr><tr><td><code>CSV</code></td><td>在存储数据时，以逗号分隔各个数据项</td></tr><tr><td><code>FEDERATED</code></td><td>用来访问远程表</td></tr><tr><td><code>InnoDB</code></td><td>具备外键支持功能的事务存储引擎</td></tr><tr><td><code>MEMORY</code></td><td>置于内存的表</td></tr><tr><td><code>MERGE</code></td><td>用来管理多个MyISAM表构成的表集合</td></tr><tr><td><code>MyISAM</code></td><td>主要的非事务处理存储引擎</td></tr><tr><td><code>NDB</code></td><td>MySQL集群专用存储引擎</td></tr></tbody></table><h4 id="MyISAM和InnoDB表引擎的区别"><a href="#MyISAM和InnoDB表引擎的区别" class="headerlink" title="MyISAM和InnoDB表引擎的区别"></a>MyISAM和InnoDB表引擎的区别</h4><ol><li><p><strong>事务支持</strong></p><p>MyISAM不支持事务，而InnoDB支持。</p><blockquote><p>  事物：访问并更新数据库中数据的执行单元。事物操作中，要么都执行要么都不执行</p></blockquote></li><li><p><strong>存储结构</strong></p><p>MyISAM：每个MyISAM在磁盘上存储成三个文件。</p><ul><li>.frm文件存储表结构。</li><li>.MYD文件存储数据。</li><li>.MYI文件存储索引。</li></ul><p>InnoDB：主要分为两种文件进行存储。</p><ul><li>.frm 存储表结构</li><li>.ibd 存储数据和索引 （也可能是多个.ibd文件，或者是独立的表空间文件）</li></ul></li><li><p><strong>表锁差异</strong></p><p>MyISAM：<strong>只支持表级锁</strong>，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。 </p><p>InnoDB：<strong>支持事务和行级锁，是innodb的最大特色。</strong>行锁大幅度提高了多用户并发操作的性能。但是InnoDB的行锁，<strong>InnoDB的行锁是基于索引建立的，如果索引失效或者没有索引，那么，行锁失效，由行锁升级为表锁。</strong></p></li><li><p><strong>表主键</strong></p><p>MyISAM：允许没有任何索引和主键的表存在，索引都是保存行的地址。 </p><p>InnoDB：如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键(用户不可见)，数据是主索引的一部分，附加索引保存的是主索引的值。InnoDB的主键范围更大，最大是MyISAM的2倍。</p></li><li><p><strong>表的具体行数</strong></p><p>MyISAM：保存有表的总行数，如果<code>select count(*) from table;</code>会直接取出出该值。 </p><p>InnoDB：没有保存表的总行数(只能遍历)，如果使用<code>select count(*) from table;</code>就会遍历整个表，消耗相当大，但是在加了wehre条件后，myisam和innodb处理的方式都一样。</p></li><li><p><strong>CURD操作</strong></p><p>MyISAM：如果执行大量的<code>SELECT</code>，MyISAM是更好的选择。 </p><p>InnoDB：如果你的数据执行大量的<code>INSERT</code>或<code>UPDATE</code>，出于性能方面的考虑，应该使用InnoDB表。<code>DELETE</code> 从性能上InnoDB更优，但<code>DELETE FROM table</code>时，InnoDB不会重新建立表，而是一行一行的删除，在innodb上如果要清空保存有大量数据的表，最好使用<code>truncate table</code>这个命令。</p></li><li><p><strong>外键</strong></p><p>MyISAM：不支持 </p><p>InnoDB：支持</p></li><li><p><strong>查询效率</strong></p><p>MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。</p><p>推荐考虑使用InnoDB来替代MyISAM引擎，原因是InnoDB自身很多良好的特点，比如事务支持、存储过程、视图、行级锁定等等，在并发很多的情况下，相信InnoDB的表现肯定要比MyISAM强很多。</p><p>另外，任何一种表都不是万能的，只有恰当的针对业务类型来选择合适的表类型，才能最大的发挥MySQL的性能优势。如果不是很复杂的Web应用，非关键应用，还是可以继续考虑MyISAM的，这个具体情况可以自己斟酌。</p></li><li><p><strong>MyISAM和InnoDB两者的应用场景：</strong></p><p>MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的<code>SELECT</code>查询，那么MyISAM是更好的选择。 </p><p>InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的<code>INSERT</code>或<code>UPDATE</code>操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。现在默认最常使用InnoDB。</p></li></ol><h3 id="字符集和编码"><a href="#字符集和编码" class="headerlink" title="字符集和编码"></a>字符集和编码</h3><blockquote><p>  我们知道在计算机中只能存储二进制数据，那该怎么存储字符串呢？当然是建立字符与二进制数据的映射关系了，建立这个关系最起码要搞清楚两件事儿：</p><ol><li><p>你要把哪些字符映射成二进制数据？也就是界定清楚字符范围。</p></li><li><p>怎么映射？</p><p> 将一个字符映射成一个二进制数据的过程也叫做<strong>编码</strong>，将一个二进制数据映射到一个字符的过程叫做<strong>解码</strong>。</p></li></ol></blockquote><p>人们抽象出一个字符集的概念来描述某个字符范围的编码规则，以下是一些常用字符集：</p><ul><li><p><code>ASCII</code> 字符集</p><p>共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。由于总共才128个字符，所以可以使用1个字节来进行编码，我们看一些字符的编码方式：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'L' -&gt; 01001100（十六进制：0x4C，十进制：76）</span><br><span class="line">'M' -&gt; 01001101（十六进制：0x4D，十进制：77）</span><br></pre></td></tr></table></figure></li><li><p><code>ISO 8859-1</code> 字符集</p><p>共收录256个字符，是在ASCII 字符集的基础上又扩充了128个西欧常用字符(包括德法两国的字母)，也可以<br>使用1个字节来进行编码。这个字符集也有一个别名<code>latin1</code> 。</p></li><li><p><code>GB2312</code> 字符集</p><p>收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个。同时这种字符集又兼容<code>ASCII</code>  字符集，所以在编码方式上显得有些奇怪：</p><ul><li>如果该字符在ASCII 字符集中，则采用1字节编码。否则采用2字节编码。</li></ul><p>这种表示一个字符需要的字节数可能不同的编码方式称为<strong>变长编码方式</strong>。比方说字符串’爱u’ ，其中’爱’ 需要用2个字节进行编码，编码后的十六进制表示为0xCED2 ， ‘u’ 需要用1个字节进行编码，编码后的十六进制表示为0x75 ，所以拼合起来就是0xCED275 。</p></li><li><p><code>GBK</code> 字符集</p><p><code>GBK</code> 字符集只是在收录字符范围上对<code>GB2312</code> 字符集作了扩充，编码方式上兼容<code>GB2312</code> 。</p></li><li><p><code>Unicode</code> 字符集</p><p>也称为万国码，收录地球上能想到的所有字符，而且还在不断扩充。这种字符集兼容<code>ASCII</code> 字符集，采用变长编码方式，编码一个字符需要使用1～4个字节，比如：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'L' -&gt; 01001100（十六进制：0x4C）</span><br><span class="line">'啊' -&gt; 111001011001010110001010（十六进制：0xE5958A）</span><br></pre></td></tr></table></figure><blockquote><p>  我们常用的<code>utf8</code>只是<code>Unicode</code>字符集的一种编码方案，<code>Unicode</code>字符集可以采用<code>utf8</code>、<code>utf16</code>、<code>utf32</code>这几种编码方案，<code>utf8</code>使用1～4个字节编码一个字符，<code>utf16</code>使用2个或4个字节编码一个字符，<code>utf32</code>使用4个字节编码一个字符</p></blockquote></li></ul><p>对于同一个字符，不同字符集也可能有不同的编码方式。比如对于汉字’我’ 来说， <code>ASCII</code> 字符集中根本没有收录这个字符， utf8 和gb2312 字符集对汉字’我’的编码方式如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">utf8编码：  111001101000100010010001 (3个字节，十六进制表示是：0xE68891)</span><br><span class="line">gb2312编码：1100111011010010 (2个字节，十六进制表示是：0xCED2)</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>更多关于字符集和编码的内容可以看下面这篇文章</strong></p><p>  <strong><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html</a></strong></p></blockquote><h4 id="MySQL中的utf8和utf8mb4"><a href="#MySQL中的utf8和utf8mb4" class="headerlink" title="MySQL中的utf8和utf8mb4"></a>MySQL中的utf8和utf8mb4</h4><p>我们上边说<code>utf8</code> 字符集表示一个字符需要使用1～4个字节，但是我们常用的一些字符使用1～3个字节就可以表示了。而在MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以MySQL的设计人员定义了两个概念：</p><ul><li><code>utf8mb3</code> ：阉割过的utf8 字符集，只使用1～3个字节表示字符。</li><li><code>utf8mb4</code> ：正宗的utf8 字符集，使用1～4个字节表示字符。</li></ul><p><strong>注意：</strong>在MySQL 中，utf8指的是utf8mb3，所以之后在MySQL中提到utf8 就意味着使用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请使用utf8mb4 。</p><blockquote><p>  <strong>字符集的查看</strong></p><p>  MySQL 支持多种字符集，查看当前MySQL 中支持的字符集可以用下边这个语句：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show charset;</span><br></pre></td></tr></table></figure></blockquote><h2 id="Mysql数据库与数据表操作"><a href="#Mysql数据库与数据表操作" class="headerlink" title="Mysql数据库与数据表操作"></a>Mysql数据库与数据表操作</h2><blockquote><p>  <strong>库和表的概念与关系</strong></p><p>  库就像是文件夹，库中可以有很多个表，表就像是我们的excel表格文件一样，每一个表中都可以存储很多数据。</p><p>  mysql中可以有很多不同的库，库中可以有很多不同的表，表中可以定义不同的列（字段），表中可以根据结构去存储很多的数据。</p></blockquote><h3 id="数据库的操作"><a href="#数据库的操作" class="headerlink" title="数据库的操作"></a>数据库的操作</h3><h4 id="数据库创建"><a href="#数据库创建" class="headerlink" title="数据库创建"></a>数据库创建</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 链接mysql数据库后，进入mysql后可以操作数据</span><br><span class="line"># 创建库</span><br><span class="line">create database if not exists test default charset&#x3D;utf8mb4;</span><br><span class="line">-- 1. 数据库 test 如果不存在则创建数据库，存在则不创建</span><br><span class="line">-- 2. 创建 test 数据库，并设置字符集为utf8</span><br><span class="line">-- 3. 无特殊情况都要求字符集为utf8或者utf8mb4的字符编码</span><br></pre></td></tr></table></figure><h4 id="查看所有库"><a href="#查看所有库" class="headerlink" title="查看所有库"></a>查看所有库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有库</span><br><span class="line">show databases;</span><br></pre></td></tr></table></figure><h4 id="打开库-进入库-选择库"><a href="#打开库-进入库-选择库" class="headerlink" title="打开库/进入库/选择库"></a>打开库/进入库/选择库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># use 库名</span><br><span class="line">use test;</span><br></pre></td></tr></table></figure><h4 id="删除库"><a href="#删除库" class="headerlink" title="删除库"></a>删除库</h4><blockquote><p>  <font color=red>删库有风险，动手需谨慎！！！</font></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除库，库中的所有数据都将在磁盘中删除。</span><br><span class="line">drop database 库名</span><br></pre></td></tr></table></figure><h3 id="数据表的操作"><a href="#数据表的操作" class="headerlink" title="数据表的操作"></a>数据表的操作</h3><h4 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h4><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(字段名，类型，[字段约束]，…)；</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 以下创建一个 users 的表</span><br><span class="line">create table if not exists users(</span><br><span class="line">-- 创建ID字段，为正整数，不允许为空 主键，自动递增</span><br><span class="line">id int unsigned not null primary key auto_increment,</span><br><span class="line">-- 创建存储 名字 的字段，为字符串类型，最大长度5个字符，不允许为空</span><br><span class="line">username varchar(5) not null,</span><br><span class="line">-- 创建存储 密码 的字段，固定长度 32位字符， 不允许为空</span><br><span class="line">password char(32) not null,</span><br><span class="line">-- 创建存储 年龄 的字段，不允许为空，默认值为 20</span><br><span class="line">age tinyint not null default 20</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8mb4;</span><br><span class="line">-- 表引擎innodb 字符集utf8mb4</span><br><span class="line"></span><br><span class="line"># 查看表结构</span><br><span class="line">desc users;</span><br><span class="line"></span><br><span class="line">#查看建表语句</span><br><span class="line">show create table users;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/07/ERAg51wJ43vdKNF.png" alt=""></p><p><strong>创建表的基本原则：</strong></p><ul><li>表明和字段名 尽可能的符合命名规范，并且最好能够‘见名之意’</li><li>表中数据必须有唯一标识，即主键定义。无特殊情况，主键都为数字并自增即可</li><li>表中字段所对应的类型设置合理，并限制合理长度</li><li>表引擎推荐使用innodb，并无特殊情况都要求为utf8或者utf8mb4的字符编码</li></ul><h4 id="修改表结构"><a href="#修改表结构" class="headerlink" title="修改表结构"></a>修改表结构</h4><p>语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 action (更改的选项)</span><br></pre></td></tr></table></figure><h5 id="添加字段"><a href="#添加字段" class="headerlink" title="添加字段"></a>添加字段</h5><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add 添加的字段信息</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 在 users 表中 追加 一个 num 字段 int类型 不为空 默认加在最后面</span><br><span class="line">alter table users add num int not null;</span><br><span class="line">-- 在指定字段后面追加字段 在 users 表中 age字段后面 添加一个 email 字段</span><br><span class="line">alter table users add email varchar(50) after age;</span><br><span class="line">-- 在指定字段后面追加字段，在 users 表中 age字段后面 添加一个 phone</span><br><span class="line">alter table users add phone char(11) not null after age;</span><br><span class="line">-- 在表的最前面添加一个字段</span><br><span class="line">alter table users add aa int first;</span><br></pre></td></tr></table></figure><h5 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 删除字段 alter table 表名 drop 被删除的字段名</span><br><span class="line">alter table users drop aa;</span><br></pre></td></tr></table></figure><h5 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h5><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 change|modify 被修改的字段信息</span><br><span class="line"># change: 可以修改字段名，</span><br><span class="line"># modify: 不能修改字段名。</span><br></pre></td></tr></table></figure><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 修改表中的 num 字段 类型,使用 modify 不修改字段名</span><br><span class="line">alter table users modify num tinyint not null default 12;</span><br><span class="line"># 修改表中的 num 字段 为 int 并且 字段名改为 mm</span><br><span class="line">alter table users change num mm int;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>注意：一般情况下，无特殊要求，不要轻易修改表结构</strong></p></blockquote><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 原表名 rename as 新表名;</span><br></pre></td></tr></table></figure><h4 id="更改表中自增的值"><a href="#更改表中自增的值" class="headerlink" title="更改表中自增的值"></a>更改表中自增的值</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 在常规情况下，auto_increment 默认从1开始继续递增</span><br><span class="line"># 更改自增值让其从1000开始</span><br><span class="line">alter table users auto_increment &#x3D; 1000;</span><br></pre></td></tr></table></figure><blockquote><p>  <font color = red> 注意：</font></p><p>  更改之后，只对后面再增加的数据有影响，对已存在的数据没有影响。</p></blockquote><h4 id="修改表引擎"><a href="#修改表引擎" class="headerlink" title="修改表引擎"></a>修改表引擎</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 推荐在定义表时，表引擎定义为 innodb。</span><br><span class="line"># 通过查看建表语句获取当前的表引擎</span><br><span class="line">mysql&gt; show create table users\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Table: users</span><br><span class="line">Create Table: CREATE TABLE &#96;users&#96; (</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">    ....</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1001 DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 直接查看当前表状态信息</span><br><span class="line">mysql&gt; show table status from test where name &#x3D; &#39;users&#39;\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">Name: users</span><br><span class="line">   Engine: InnoDB</span><br><span class="line">   ....</span><br><span class="line"></span><br><span class="line"># 修改表引擎语句</span><br><span class="line">alter table users engine &#x3D; &#39;myisam&#39;;</span><br></pre></td></tr></table></figure><h4 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名</span><br></pre></td></tr></table></figure><h2 id="MySQL-数据操作——DML"><a href="#MySQL-数据操作——DML" class="headerlink" title="MySQL 数据操作——DML"></a>MySQL 数据操作——DML</h2><blockquote><p>  <strong>数据的DML操作：添加数据，修改数据，删除数据</strong></p></blockquote><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名[(字段列表)] values(值列表...);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 标准添加（指定所有字段，给定所有的值）</span><br><span class="line">insert into stu(id,name,age,sex,classid) values(1,&#39;zhangsan&#39;,20,&#39;m&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 指定部分字段添加值</span><br><span class="line">insert into stu(name,classid) value(&#39;lisi&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 不指定字段添加值</span><br><span class="line">insert into stu value(null,&#39;wangwu&#39;,21,&#39;w&#39;,&#39;lamp138&#39;);</span><br><span class="line"></span><br><span class="line">-- 批量添加值</span><br><span class="line">insert into stu values</span><br><span class="line">(null,&#39;zhaoliu&#39;,25,&#39;w&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;uu01&#39;,26,&#39;m&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;uu02&#39;,28,&#39;w&#39;,&#39;lamp92&#39;),</span><br><span class="line">(null,&#39;qq02&#39;,24,&#39;m&#39;,&#39;lamp92&#39;),</span><br><span class="line">(null,&#39;uu03&#39;,32,&#39;m&#39;,&#39;lamp138&#39;),</span><br><span class="line">(null,&#39;qq03&#39;,23,&#39;w&#39;,&#39;lamp94&#39;),</span><br><span class="line">(null,&#39;aa&#39;,19,&#39;m&#39;,&#39;lamp138&#39;);</span><br></pre></td></tr></table></figure><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表名 set 字段1&#x3D;值1,字段2&#x3D;值2,字段n&#x3D;值n... where 条件;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 将id为11的age改为35，sex改为m值</span><br><span class="line">update stu set age&#x3D;35,sex&#x3D;&#39;m&#39; where id&#x3D;11;</span><br><span class="line"></span><br><span class="line">-- 将id值为12和14的数据值sex改为m，classid改为lamp92</span><br><span class="line">update stu set sex&#x3D;&#39;m&#39;,classid&#x3D;&#39;lamp92&#39; where id&#x3D;12 or id&#x3D;14 </span><br><span class="line">update stu set sex&#x3D;&#39;m&#39;,classid&#x3D;&#39;lamp92&#39; where id in(12,14);  -- 等价于上面</span><br></pre></td></tr></table></figure><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名 [where 条件];</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 删除stu表中id值为100的数据</span><br><span class="line">delete from stu where id&#x3D;100;</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值为20到30的数据</span><br><span class="line">delete from stu where id&gt;&#x3D;20 and id&lt;&#x3D;30;</span><br><span class="line">delete from stu where id between 20 and 30;-- 等价于上面</span><br><span class="line"></span><br><span class="line">-- 删除stu表中id值大于200的数据</span><br><span class="line">delete from stu where id&gt;200;</span><br></pre></td></tr></table></figure><h2 id="MySQL数据查询——DQL基本语法"><a href="#MySQL数据查询——DQL基本语法" class="headerlink" title="MySQL数据查询——DQL基本语法"></a>MySQL数据查询——DQL基本语法</h2><p>语法格式：<font color = red> sql查询语句 一定要严格按照这样的顺序，否则会产生错误</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 字段列表|* from 表名</span><br><span class="line">[where 搜索条件]</span><br><span class="line">[group by 分组字段 [having 分组条件]]</span><br><span class="line">[order by 排序字段 排序规则]</span><br><span class="line">[limit 分页参数]</span><br></pre></td></tr></table></figure><p>下面以一个数据表stu为例进行讲解</p><p>SQL示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">CREATE TABLE &#96;stu&#96;(</span><br><span class="line">&#96;id&#96;  int unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">&#96;name&#96; varchar(10) NOT NULL,</span><br><span class="line">&#96;email&#96; char(50) NOT NULL,</span><br><span class="line">&#96;phone&#96; char(11) NOT NULL,</span><br><span class="line">&#96;age&#96; tinyint(4)NOT NULL,</span><br><span class="line">&#96;sex&#96; char(1) DEFAULT NULL,</span><br><span class="line">&#96;class_id&#96; int DEFAULT NULL, </span><br><span class="line">    PRIMARY KEY(id)</span><br><span class="line">)ENGINE&#x3D;MyISAM AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8mb4;</span><br><span class="line"></span><br><span class="line">-- 添加数据</span><br><span class="line">insert into stu values</span><br><span class="line">(null,&#39;张三&#39;,&#39;zhangsane@qq.com&#39;,&#39;13701184321&#39;,21,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;李四&#39;,&#39;lisi@qq.com&#39;,&#39;13701104322&#39;,22,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;王五&#39;,&#39;wangwu@qq.com&#39;,&#39;13701104323&#39;,20,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;赵六&#39;,&#39;zhaoliu@qq.com&#39;,&#39;13701104324&#39;,19,&#39;男&#39;,1),</span><br><span class="line">(null,&#39;田七&#39;,&#39;tianqi@qq.com&#39;,&#39;13701104325&#39;,23,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;王五六&#39;,&#39;wangwuliu@qq.com&#39;,&#39;13701104326&#39;,23,&#39;女&#39;,1),</span><br><span class="line">(null,&#39;熊大&#39;,&#39;xiongda@qq.com&#39;,&#39;13701184327&#39;,25,&#39;男&#39;,2),</span><br><span class="line">(null,&#39;熊二&#39;,&#39;xionger@qq.com&#39;,&#39;13701104328&#39;,22,&#39;男&#39;,2),</span><br><span class="line">(null,&#39;一一&#39;,&#39;yiyi@qq.com&#39;,&#39;13701184329&#39;,19,&#39;女&#39;,2),</span><br><span class="line">(null,&#39;呀呀&#39;,&#39;yaya@qq.com&#39;,&#39;13701104320&#39;,22,&#39;男&#39;,2);</span><br><span class="line"> </span><br><span class="line"> -- 查看表数据</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><h3 id="检索数据SELECT"><a href="#检索数据SELECT" class="headerlink" title="检索数据SELECT"></a>检索数据<code>SELECT</code></h3><p><strong>检索列</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 检索单个列</span><br><span class="line">select name from stu; -- 查询 stu 表中 name （字段）列的所有数据</span><br><span class="line"></span><br><span class="line"># 检索多个列</span><br><span class="line">select id, name, age, sex from stu; </span><br><span class="line"></span><br><span class="line"># 检索所有列</span><br><span class="line">select * from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/C1EtjLHgFfQ76SX.png" alt=""></p><blockquote><p>  如果没有明确排序查询结果，则返回的数据的顺序没有特殊意义。</p><p>  返回数据的顺序可能是数据被添加到表中的顺序，也可能不是。只要返回相同数目的行，就是正常的</p><p>  <strong>使用通配符 <code>*</code> 的说明：</strong></p><p>  一般除非你确实需要表中的每个列，否则最好别使用 <code>*</code> 通配符。</p><p>  虽然使用通配符，不用明确列出所需列，会使你自己省事，但检索不需要的列通常会降低检索和应用程序的性能。使用通配符有一个优点： 由于不明确指定列名（因为 <code>*</code> 检索每个列），所以能检索出名字未知的列。</p></blockquote><p><strong>检索不同的行（去重） DISTNCT</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 检索不同的行（去重） DISTNCT</span><br><span class="line">select distinct class_id from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/No9qvOmStG1z6be.png" alt=""></p><blockquote><p>  DISTINCT关键字指示MySQL只返回不同的值。</p><p>  DISTINCT关键字应用于所有列，而不仅是前置它的列。</p><p>  如果给出<code>SELECT DISTINCT 字段1,字段2,.... FROM xxx;</code>除非指定的列都不同，否则所有行都将被检索出来</p></blockquote><p><strong>使用完全限定的表名</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select name from stu; -- 无限制</span><br><span class="line">select stu.name from stu; -- 限制字段名 stu.name stu表的name字段</span><br><span class="line">select stu.name from test.stu;  -- 限制表名 test.stu test库的stu表</span><br></pre></td></tr></table></figure><h3 id="WHERE-数据检索条件过滤"><a href="#WHERE-数据检索条件过滤" class="headerlink" title="WHERE 数据检索条件过滤"></a>WHERE 数据检索条件过滤</h3><blockquote><p>  数据库表一般包含大量的数据，很少需要检索表中所有行。</p><p>  通常只会根据特定操作或报告的需要提取表数据的子集。</p><p>  只检索所需数据需要指定搜索条件（search criteria)，搜索条件也称为过滤条件（filtercondition)。</p><p>  在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。</p></blockquote><ul><li>可以在where子句中指定任何条件</li><li>可以使用 and 或者 or 指定一个或多个条件</li><li>where条件也可以运用在update和delete语句的后面</li></ul><p><strong>WHERE 子句操作符</strong></p><table><thead><tr><th>操作符</th><th>说明</th></tr></thead><tbody><tr><td><code>=</code></td><td>等于</td></tr><tr><td><code>&lt;&gt;</code>   <code>!=</code></td><td>不等于</td></tr><tr><td><code>&lt;</code></td><td>小于</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td></tr><tr><td><code>&gt;</code></td><td>大于</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td></tr><tr><td><code>BETWEEN…AND…</code></td><td>指定两值之间</td></tr><tr><td><code>IS NULL</code></td><td>空值</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 age &gt; 22的数据</span><br><span class="line">select * from stu where age &gt; 22;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 name&#x3D;某个条件值 的数据</span><br><span class="line">select * from stu where name &#x3D; &#39;王五&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 sex 为 null 的数据</span><br><span class="line">select * from stu where sex is null;</span><br></pre></td></tr></table></figure><p><strong>组合WHERE子句</strong></p><blockquote><p>   MySQL允许给出多个WHERE子句。</p><p>   这些子句可以两种方式使用：以<code>AND</code>子句的方式或<code>OR</code>子句的方式使用。也称为逻辑操作符</p><ul><li><code>AND</code> 检索满足<strong>所有</strong>给定条件的行</li><li><code>OR</code>   检索满足<strong>任一</strong>给定条件的行</li></ul></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 年龄在22到25之间的数据</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age &lt;&#x3D; 25;</span><br><span class="line">select * from stu where age between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄不在22到25之间的数据</span><br><span class="line">select * from stu where age &lt; 22 or age &gt; 25;</span><br><span class="line">select * from stu where age not between 22 and 25;</span><br><span class="line"></span><br><span class="line">-- 查询 stu 表中 年龄在22到25之间的女生信息</span><br><span class="line">select * from stu where age &gt;&#x3D; 22 and age &lt;&#x3D; 25 and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong><font color=red>注意</font></strong></p><p>  <code>and</code> 和 <code>or</code> 在使用时要注意 sql语句优先级的问题，sql会优先处理<code>and</code>条件</p><p>  比如下面语句：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where age&#x3D;22 or age &#x3D; 25 and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure><p>  假如要求查询 users 表中 年龄为22或者25 的女生信息，上面语句查询的结果就不能符合我们的要求。</p><p>  上面语句查询的是 （年龄为22的所有人） 或者 （年龄为25的女生）信息：</p><p>  要达到我们要求的查询，可以用小括号来提升优先级</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from stu where (age&#x3D;22 or age &#x3D; 25) and sex &#x3D; &#39;女&#39;;</span><br></pre></td></tr></table></figure></blockquote><p><strong><code>IN</code>与<code>NOT</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 stu 表中 id 是1或2或3的数据</span><br><span class="line">select * from stu where id in (1,2,3);</span><br><span class="line">-- 查询 stu 表中 id 不是1 也不是2 也不是3的数据</span><br><span class="line">select * from stu where id not in (1,2,3);</span><br></pre></td></tr></table></figure><blockquote><p>  <code>IN</code> 操作符用来指定条件范围，范围中的每个条件都可以进行匹配。功能与<code>OR</code>相当</p><p>  <code>NOT</code> 用于否定后跟进的条件</p><p>  与<code>OR</code>，相比，使用<code>IN</code>的优点</p><ul><li>在使用长的合法选项清单时，IN操作符的语法更清楚且更直观。</li><li>在使用IN时，计算的次序更容易管理（因为使用的操作符更少）。</li><li>IN操作符一般比OR操作符清单执行更快。</li><li>IN的最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li></ul></blockquote><p><strong>通配符的使用 <code>LIKE</code></strong></p><p>我们可以在where条件中使用 <code>=</code>，<code>&lt;</code>，<code>&gt;</code> 等符号进行条件的过滤，但是当想查询某个字段是否包含某个字符时如何过滤呢？例如： 查询 name字段中包含五的数据</p><p>可以使用<code>LIKE</code>语句进行某个字段的模糊搜索。</p><p><strong>常用通配符：</strong></p><ul><li>百分号(<code>%</code>) ：表示任意字符出现任意次数</li><li>下划线(<code>_</code>)：用途与<code>%</code>类似，但下划线只匹配单个字符</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">-- like 语句 like某个确定的值 和。where name &#x3D; &#39;王五&#39; 是一样</span><br><span class="line">select * from stu where name like &#39;王五&#39;;</span><br><span class="line"></span><br><span class="line">-- 使用 % 模糊搜索。%代表任意个任意字符</span><br><span class="line">-- 查询name字段中包含五的</span><br><span class="line">select * from stu where name like &#39;%五%&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询name字段中最后一个字符 为 五的</span><br><span class="line">select * from stu where name like &#39;%五&#39;;</span><br><span class="line">   </span><br><span class="line">    -- 查询name字段中第一个字符 为 王 的</span><br><span class="line">select * from stu where name like &#39;王%&#39;;</span><br><span class="line"></span><br><span class="line">-- 使用 _ 单个的下划线。表示一个任意字符，使用和%类似</span><br><span class="line">-- 查询表中 name 字段为两个字符的数据</span><br><span class="line">select * from stu where name like &#39;__&#39;;</span><br><span class="line"></span><br><span class="line">-- 查询 name 字段最后为 五 的两个字符的数据</span><br><span class="line">select * from stu where name like &#39;_五&#39;;</span><br></pre></td></tr></table></figure><blockquote><p>  <strong>where子句中的like在使用<code>%</code>或者<code>_</code>进行模糊搜索时，所花时间更长，效率不高，使用时注意：</strong></p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，尽量使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数据</li></ul></blockquote><blockquote><p>  MySql中也支持正则表达式，使用 <code>REGEXP</code> 关键字来匹配。</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询 id 为 3到8 的所有数据</span><br><span class="line">select * from stu where id regexp &#39;[3-8]&#39;;</span><br></pre></td></tr></table></figure></blockquote><h3 id="字段的计算"><a href="#字段的计算" class="headerlink" title="字段的计算"></a>字段的计算</h3><p>存储在数据库表中的数据一般不是应用程序所需要的格式。下面举几个例子:</p><ul><li>如果想在一个字段中既显示用户名，又显示班级号，但这两个信息一般包含在不同的表列中。</li><li>同时姓名、手机号和地址存储在不同的列中（应该这样）,但快递单打印程序却需要把它们作为一个恰当格式的字段检索出来。</li><li>列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。</li><li>物品订单表存储物品的价格和数量，但不需要存储每个物品的总价格（用价格乘以数量即可）。为打印发票需要物品的总价格。</li><li>需要根据表数据进行总数、平均数计算或其他计算</li></ul><p><strong>计算字段并不实际存在于数据库表中。计算字段是运行时在SELECT语句内创建的</strong></p><p><strong>拼接Concat</strong></p><p>stu表包含用户名和手机号码信息。假如要生成一个学生报表，需要在学生的名字中按照name(phone)这样的<br>格式列出</p><p>解决办法是把两个列拼接起来。在MySQL的SELECT语句中，可使用<code>concat()</code>函数来拼接两个列</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(name ,&#39;(&#39;, phone,&#39;)&#39;) from stu;</span><br></pre></td></tr></table></figure><p><strong>使用别名AS</strong></p><p>SELECT语句拼接字段可以完成。但此新计算列的名字是什么呢？实际上它没有名字，它只是一个值。<br>如果仅在SQL查询工具中查看一下结果，这样没有什么不好。</p><p>但是，一个未命名的列不能用于客户机应用中，因为客户机没有办法引用它。</p><p>为了解决这个问题，SQL支持列别名。别名（alias)是一个字段或值的替换名。别名用<code>AS</code>关键字赋予</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select concat(name ,&#39;(&#39;,phone,&#39;)&#39;) as name_phone from stu;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/i8v9tsl1JkrISmE.png" alt=""></p><h3 id="MySql查询常用函数"><a href="#MySql查询常用函数" class="headerlink" title="MySql查询常用函数"></a>MySql查询常用函数</h3><blockquote><p>  与其他大多数计算机语言一样，SQL支持利用函数来处理数据。</p><p>  函数一般是在数据上执行的，它给数据的转换和处理提供了方便。</p></blockquote><p><strong>文本处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/string-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/string-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/kfDA5FUwxgGN6jz.png" alt="image-20201108204526003"></p><p><strong>日期和时间处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/date-and-time-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/a8mH6gLkY5zOpbS.png" alt=""></p><blockquote>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 根据出生日期计算年龄</span></span><br><span class="line">TIMESTAMPDIFF(YEAR, @birthday, CURDATE()) </span><br></pre></td></tr></table></figure></blockquote><p><strong>数值处理函数</strong></p><p><a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-functions.html" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/numeric-functions.html</a></p><p><img src="https://i.loli.net/2020/11/08/fkPm93ciztJb7uA.png" alt=""></p><h3 id="Mysql中的统计函数（聚合函数）"><a href="#Mysql中的统计函数（聚合函数）" class="headerlink" title="Mysql中的统计函数（聚合函数）"></a>Mysql中的统计函数（聚合函数）</h3><blockquote><p>  我们经常需要汇总数据而不用把它们实际检索出来，为此MySQL提供了专门的函数。</p><p>  使用这些函数，MySQL查询可用于检索数据，以便分析和报表生成</p></blockquote><ul><li><code>max()</code>  返回某列最大值</li><li><code>min()</code> 返回某列最小值</li><li><code>count()</code> 返回某列的行数</li><li><code>sum()</code>  返回某列值和</li><li><code>avg()</code>    返回某列的平均值</li></ul><blockquote><p>  在使用count时，如果指定列名，则指定列的值为空的行被忽略，但如果COUNT函数中用的是星号（*）,则不忽略。</p></blockquote><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># 计算 users 表中 最大年龄，最小年龄，年龄和及平均年龄</span><br><span class="line">select max(age),min(age),sum(age),avg(age) from stu;</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">| max(age) | min(age) | sum(age) | avg(age) |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">|       25 |       19 |      216 |  21.6000 |</span><br><span class="line">+----------+----------+----------+----------+</span><br><span class="line">-- 上面数据中的列都是在查询时使用的函数名，不方便阅读和后期的调用，可以通过别名方式 美化</span><br><span class="line">select max(age) as max_age,</span><br><span class="line">min(age) as min_age,</span><br><span class="line">sum(age) as sum_age,</span><br><span class="line">avg(age) as avg_age from stu;</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">| max_age | min_age | sum_age | avg_age |</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">|      25 |      19 |     216 | 21.6000 |</span><br><span class="line">+---------+---------+---------+---------+</span><br><span class="line">-- 统计 users 表中的数据量</span><br><span class="line">select count(*) from stu;</span><br><span class="line">+----------+</span><br><span class="line">| count(*) |</span><br><span class="line">+----------+</span><br><span class="line">|       10 |</span><br><span class="line">+----------+</span><br><span class="line">select count(id) from stu;</span><br><span class="line">+----------+</span><br><span class="line">| count(id)|</span><br><span class="line">+----------+</span><br><span class="line">|       10 |</span><br><span class="line">+----------+</span><br><span class="line"></span><br><span class="line">-- 上面的两个统计，分别使用了 count(*) 和 count(id),结果目前都一样，有什么区别？</span><br><span class="line">-- count(*) 是按照 users表中所有的列进行数据的统计，只要其中一列上有数据，就可以计算</span><br><span class="line">-- count(id) 是按照指定的 id 字段进行统计，也可以使用别的字段进行统计，</span><br><span class="line">-- 但是注意，如果指定的列上出现了NULL值，那么为NULL的这个数据不会被统计</span><br><span class="line">-- 假设有下面这样的一张表需要统计</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">| id   | name      |  age |  phone |     email |  sex | mm   |</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">| 1000 | aa        | 20   | 123    | NULL      | 男   | NULL |</span><br><span class="line">| 1001 | bb        | 20   | 123456 | NULL      | 男   | NULL |</span><br><span class="line">| 1002 | cc        | 25   | 123    | NULL      | 女   | NULL |</span><br><span class="line">| 1003 | dd        | 20   | 456    | NULL      | 女   | NULL |</span><br><span class="line">| 1004 | ff        | 28   | 789    | NULL      | NULL | NULL |</span><br><span class="line">+------+-----------+------+--------+-----------+------+------+</span><br><span class="line">5 rows in set (0.00 sec)</span><br><span class="line">-- 如果按照sex这一列进行统计，结果就是4个而不是5个，因为sex这一列中有NULL值存在</span><br><span class="line">mysql&gt; select count(sex) from stu;</span><br><span class="line">+------------+</span><br><span class="line">| count(sex) |</span><br><span class="line">+------------+</span><br><span class="line">| 4          |</span><br><span class="line">+------------+</span><br></pre></td></tr></table></figure><p>聚合函数除了以上简单的使用以外，通常情况下都是配合着分组进行数据的统计和计算</p><h3 id="GROUP-BY-分组"><a href="#GROUP-BY-分组" class="headerlink" title="GROUP BY 分组"></a>GROUP BY 分组</h3><p><code>group by</code> 语句根据一个或多个列对结果集进行分组</p><p>一般情况下，是用于数据的统计或计算，配合聚合函数使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-- 统计 users 表中 男女生人数,</span><br><span class="line">-- 很明显按照上面的需要，可以写出两个语句进行分别统计</span><br><span class="line">select count(*) from stu where sex &#x3D; &#39;女&#39;;</span><br><span class="line">select count(*) from stu where sex &#x3D; &#39;男&#39;;</span><br><span class="line">-- 可以使用分组进行统计，更方便</span><br><span class="line">select sex,count(*) from stu group by sex;</span><br><span class="line"></span><br><span class="line">-- 统计1班和2班的人数</span><br><span class="line">select class_id,count(*) from stu group by class_id;</span><br><span class="line"></span><br><span class="line">-- 分别统计每个班级的男女生人数</span><br><span class="line">select class_id,sex,count(*) as num from stu group by class_id,sex;</span><br></pre></td></tr></table></figure><p>注意：在使用<code>group by</code>分组时，一般除了聚合函数，其它在<code>select</code>后面出现的字段列都需要出现在<code>grouop by</code> 后面。</p><p><strong><code>HAVING</code>子句</strong></p><p><code>having</code> 在分组聚合计算后，对结果再一次进行过滤，类似于where，where过滤的是行数据，having过滤的是分组数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 要统计班级人数</span><br><span class="line">select class_id,count(*) from stu group by classid;</span><br><span class="line">-- 统计班级人数，并且要人数达到5人及以上</span><br><span class="line">select class_id,count(*) as num from stu group by class_id having num &gt;&#x3D;5;</span><br></pre></td></tr></table></figure><h3 id="ORDER-BY-对检索数据进行排序"><a href="#ORDER-BY-对检索数据进行排序" class="headerlink" title="ORDER BY 对检索数据进行排序"></a>ORDER BY 对检索数据进行排序</h3><blockquote><p>  默认查询出的数据，并不是随机排序的，如果没有指定排序，数据一般将以它在底层表中出现的顺序显示，关系数据库设计理论认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</p></blockquote><p>我们在mysql中使用<code>select</code>的语句查询的数据结果是根据数据在底层文件的结构来排序的，在需要排序时可以使用<code>order by</code>对返回的结果进行排序</p><p><code>order by</code>asc 升序，默认</p><ul><li>desc 降序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-- 按照年龄对结果进行排序，</span><br><span class="line">-- 从大到小</span><br><span class="line">select * from users order by age desc;</span><br><span class="line">-- 从小到大排序 asc 默认可以不写</span><br><span class="line">select * from users order by age;</span><br><span class="line">-- 也可以按照多个字段进行排序</span><br><span class="line">select * from users order by age,id; # 先按照age进行排序，age相同情况下，按照id进行排序 升序</span><br><span class="line">select * from users order by age,id desc; -- 降序</span><br></pre></td></tr></table></figure><h3 id="限制结果-LIMIT"><a href="#限制结果-LIMIT" class="headerlink" title="限制结果 LIMIT"></a>限制结果 LIMIT</h3><ul><li><code>limit n</code> 提取n条数据，</li><li><code>limit m,n</code> 跳过m条数据，提取后面的n条数据</li><li><code>limit n offset m</code>  跳过m条数据，提取后面的n条数据 ，等同于<code>limit m,n</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-- 查询stu 表中的数据，只要3条</span><br><span class="line">select * from stu limit 3;</span><br><span class="line"></span><br><span class="line">-- 跳过前3条数据，再取4条数据</span><br><span class="line">select * from stu limit 3,4;</span><br><span class="line">select * from stu limit 4 offset 3;</span><br><span class="line">-- limit一般应用在数据分页上面</span><br><span class="line">-- 例如每页显示10条数据</span><br><span class="line">第一页 limit 0,10</span><br><span class="line">第二页 limit 10,10</span><br><span class="line">第三页 limit 20,10</span><br><span class="line">第四页 limit 30,10</span><br><span class="line">...</span><br><span class="line">-- 查询stu 表中年龄最大的两个人的信息</span><br><span class="line">select * from stu order by age desc limit 2;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/11/08/WmOsZi8a5KjRMSN.png" alt="image-20201108191010335"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>mysql中的查询语句比较灵活多样，并且在使用查询语句时，一定要注意sql的正确性和顺序。</p><p><img src="https://i.loli.net/2020/11/08/qoVjDgp12uvzaYw.png" alt="image-20201108162518097"></p><h2 id="Mysql数据库导入导出和授权"><a href="#Mysql数据库导入导出和授权" class="headerlink" title="Mysql数据库导入导出和授权"></a>Mysql数据库导入导出和授权</h2><h3 id="数据导出"><a href="#数据导出" class="headerlink" title="数据导出"></a>数据导出</h3><ul><li><strong>数据库数据导出</strong>：在命令行中然后输入以下命令 导出某个库中的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p 库名 &gt; 要保存的文件路径/xxx.sql</span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">mysqldump -u root -p <span class="built_in">test</span> &gt; D://test.sql</span><br></pre></td></tr></table></figure><p>导出一个库中所有数据，会形成一个建表和添加语句组成的sql文件</p><p><img src="https://i.loli.net/2020/11/08/DY6nwXKyW9lefOI.png" alt=""></p><ul><li><strong>将数据库中的表导出</strong> :在命令行中然后输入以下命令 导出某个库中指定表的数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p 库名 表名 &gt; 要保存的文件路径/xxx.sql</span><br><span class="line"><span class="comment"># 比如：</span></span><br><span class="line">mysqldump -u root -p <span class="built_in">test</span> users &gt; D://<span class="built_in">test</span>-users.sql</span><br></pre></td></tr></table></figure><h3 id="数据导入"><a href="#数据导入" class="headerlink" title="数据导入"></a>数据导入</h3><p>把导出的sql文件数据导入到mysql数据库中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 在新的数据库中 导入备份的数据，导入导出的sql文件</span><br><span class="line">mysql -u root -p 新建的库名 &lt; 路径&#x2F;xxx.sql</span><br><span class="line"># 把导出的表sql 导入数据库</span><br><span class="line">mysql -u root -p 新建的库名 &lt; 路径&#x2F;xxx.sql</span><br></pre></td></tr></table></figure><h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><blockquote><p>  mysql中的root用户是数据库中权限最高的用户，千万不要用在项目中。</p><p>  可以给不同的用户，或者项目，创建不同的mysql用户，并适当的授权，完成数据库的相关操作，这样就在一定程度上保证了数据库的安全。</p></blockquote><p>创建用户的语法格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant 授权的操作 on 授权的库.授权的表 to 账户@登录地址 identified by &#39;密码&#39;;</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 在mysql中 创建一个 zhangsan 用户，授权可以对test这个库中的所有表 进行 添加和查询 的权限</span><br><span class="line">grant select,insert on test.* to zhangsan@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line"># 用户 lisi，密码 123456 可以对test库中的所有表有所有操作权限</span><br><span class="line">grant all on test.* to lisi@&#39;%&#39; identified by &#39;123456&#39;;</span><br><span class="line"></span><br><span class="line"># 删除用户 lisi</span><br><span class="line">drop user &#39;lisi&#39;@&#39;%&#39;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;数据库介绍&quot;&gt;&lt;a href=&quot;#数据库介绍&quot; class=&quot;headerlink&quot; title=&quot;数据库介绍&quot;&gt;&lt;/a&gt;数据库介绍&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;什么是数据库&lt;/p&gt;
&lt;p&gt;数据库(Database)就是按照数据结构来组织，存储和管理数据的仓库。&lt;br&gt;专业的数据库是专门对数据进行创建，访问，管理，搜索等操作的软件，比起我们自己用文件读写的方式，用它对数据进行管理更加的方便，快速，安全。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://www.pengspace.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://www.pengspace.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>移动端布局</title>
    <link href="https://www.pengspace.top/2020/11/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/"/>
    <id>https://www.pengspace.top/2020/11/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%83%E5%B1%80/</id>
    <published>2020-11-16T11:31:49.000Z</published>
    <updated>2020-11-16T11:48:42.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="移动端现状"><a href="#移动端现状" class="headerlink" title="移动端现状"></a>移动端现状</h2><ul><li>内核<ul><li>当前国产主流手机浏览器，内核都是Webkit</li></ul></li><li>分辨率：手机分辨率，碎片化太多<ul><li>Android：480x800, 480x854, 540x960, 720x1280，1080x1920 等</li><li>iPhone：640x960, 640x1136, 750x1334, 1242x2208 等</li><li>2K、4K等高分辨率</li></ul></li></ul><a id="more"></a><p>在开发过程中，Google chrome是主要模拟手机的手段之一，步骤：</p><ol><li><p>鼠标右键 检查 或 F12 控制器界面方向；</p></li><li><p>选择 手机模式</p></li><li><p>选择 手机类型及尺寸；调节适当的显示比例；</p></li><li><p>点右键 查看 页面元素；</p></li></ol><p><img src="https://i.loli.net/2020/11/05/Gkg6KFxR7IHm3ZJ.png" alt=""></p><h2 id="viewport-视口"><a href="#viewport-视口" class="headerlink" title="viewport(视口)"></a>viewport(视口)</h2><p><strong>定义：</strong></p><p>视口：浏览器（PC、移动端）显示页面内容的屏幕区域；不同的屏幕的大小，我们看到的区域也是不同的；</p><p>PC端的页面直接放入手机屏显示，不友好，可以用viewport来解决</p><p><img src="https://i.loli.net/2020/11/05/s1gtWMJ95GX42j3.png" alt="image-20201105130620315"></p><p><img src="https://i.loli.net/2020/11/05/Y7wazID9g2hUQGO.png" alt=""></p><p>HTML宽度默认为980px，不是很合适；</p><blockquote><p>  各手机型号尺寸：</p><table><thead><tr><th>设备</th><th>尺寸（英寸）</th><th>开发尺寸（px）</th><th>物理像素比（dpr）</th></tr></thead><tbody><tr><td>iphone3G</td><td>3.5</td><td>320*480</td><td>1.0</td></tr><tr><td>iphone4/4s</td><td>3.5</td><td>320*480</td><td>2.0</td></tr><tr><td>iphone5/5s/5c</td><td>4.0</td><td>320*568</td><td>2.0</td></tr><tr><td>HTC One M8</td><td>4.5</td><td>360*640</td><td>3.0</td></tr><tr><td>iphone6</td><td>4.7</td><td>375*667</td><td>2.0</td></tr><tr><td>Nexus4</td><td>4.7</td><td>384*640</td><td>2.0</td></tr><tr><td>Nexus5x</td><td>5.2</td><td>411*731</td><td>2.6</td></tr><tr><td>iphone6 Plus</td><td>5.5</td><td>414*736</td><td>3.0</td></tr><tr><td>Samsung Galaxy Note4</td><td>5.7</td><td>480*853</td><td>3.0</td></tr><tr><td>Sony Xperia Z Ultra</td><td>6.4</td><td>540*960</td><td>2.0</td></tr><tr><td>Nexus 7(‘12)</td><td>7.0</td><td>600*960</td><td>1.3</td></tr><tr><td>iPad Mini</td><td>7.9</td><td>768*1024</td><td>1.0</td></tr></tbody></table></blockquote><p>那么设置HTML宽度多少为合适呢？设置为屏幕的窗口大小应该正好合适</p><p><strong>设置viewport</strong></p><p>meta标签设置：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0,maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>width=device-width</code>：改变HTML默认的980px 为 屏幕的宽度；</p><p><code>user-scalable</code>: 是否允许用户缩放屏幕 值：no(0不允许) yes(1允许)；</p><p><code>initial-scale</code>：初始化缩放比例；1.0：不缩放；</p><p><code>maximum-scale</code>：用户对页面的最大缩放比例；值：比例</p><p><code>minimum-scale</code>：用户对页面的最小缩放比例；值：比例</p><h2 id="二倍图"><a href="#二倍图" class="headerlink" title="二倍图"></a>二倍图</h2><p><strong>物理像素点</strong></p><ul><li>指计算机显示设备中的最小单位，即一个像素点的大小。每一个像素点可以理解为就是屏幕上的一个发光<br>点。每个点可以发一个颜色，就是我们看到的画面。</li><li>早期的屏幕，物理像素点都比较大，随着技术的进步，物理像素点会被做的越来越小。</li></ul><p><strong>屏幕分辨率</strong></p><ul><li>由物理像素点的个数来衡量，表示屏幕水平和垂直方向的物理像素点的个数。</li></ul><blockquote><p>  例如：iPhone3和iPhone4是同一个屏幕尺寸下，比较分辨率：</p><p>  <img src="https://i.loli.net/2020/11/05/tmYVi7JlQxLUeup.png" alt=""></p><p>  Retina（视网膜屏幕）是一种显示技术，可以将把更多的物理像素点压缩至一块屏幕里；从而达到更高的分辨率，并提高屏幕显示的细腻程度。</p><p>  <img src="https://i.loli.net/2020/11/05/NfyYevr6w3DQa1q.png" alt="image-20201105133553373"></p></blockquote><p><strong>图片分辨率</strong></p><p>假设：有200*200分辨率的图片，展示在宽度分别是320（iphone3）、640(iphone4)分辨率的手机上，展示<br>的效果如下：</p><p><img src="https://i.loli.net/2020/11/05/AKrpNHldgYZSI6F.png" alt="image-20201105133722991"></p><p>可以看出，不同的屏幕下，显示的图片大小是不一样的；物理像素点的宽度大小为1：0.5，物理像素点的数量：320（1 x 200=200长度）、640(0.5 x 400=200长度；都设为是200长度，才能保证显示的大小一样，这时320的屏幕是200像素点，而640的屏幕是400个像素点。</p><p>在移动端，我们可以通过设置CSS样式宽高200px后，会自动保证每个屏幕显示元素大小一样，它会自动算出不同屏幕下，背后需要提供物理像素点需要多少个。</p><p><strong>二倍图</strong></p><p>像针对640分辨率手机屏（iPhone4），要求设计给400*400图，对应我们CSS设置200px,有二倍的关系：</p><p>命名：</p><ul><li><a href="mailto:xxxxx@2x.png">xxxxx@2x.png</a>：二倍图</li><li><a href="mailto:xxxxx@3x.png">xxxxx@3x.png</a>：三倍图</li></ul><h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><p>了解常见布局不同，针对业务需求选择不同的方案；实际开发过程中，都是混合使用，没有哪一种是绝对的<br>单独使用。</p><p>常见布局包括以下几种方式</p><ul><li>单独制作移动端页面<ul><li>流式布局 (百分比布局)</li><li>flex弹性布局 (强列推荐)</li><li>less+rem+媒体查询布局</li><li>混合布局</li></ul></li><li>响应式页面兼容移动端<ul><li>媒体查询</li><li>bootstrap</li></ul></li></ul><p>比较：</p><ul><li>单独制作：流式、flex、rem布局、专门针对各种手机屏幕进行开发。例如：淘宝、京东、苏宁手机端都是单独制作的</li><li>响应式：可兼容PC 移动端，一个页面多个端适配显示；制作起来要考虑到兼容性的样式。例如：三星电子官网<a href="http://www.samsung.com/cn/" target="_blank" rel="noopener">www.samsung.com/cn/</a> 就是响应式布局</li></ul><h3 id="流式布局"><a href="#流式布局" class="headerlink" title="流式布局"></a>流式布局</h3><p>看下面代码，左右两部分以百分比来定义宽度，这样无论屏幕如何变化都可以保证效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        *&#123;<span class="attribute">margin</span>: <span class="number">0</span>;<span class="attribute">padding</span>: <span class="number">0</span>;&#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.op</span>&#123;</span></span><br><span class="line">            width: 100%;</span><br><span class="line">            border: 1px solid red;</span><br><span class="line">            overflow: hidden;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.op</span>&gt;<span class="selector-tag">div</span>&#123;</span></span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.left</span>&#123;</span></span><br><span class="line">            width: 40%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: blue;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">            width: 60%;</span><br><span class="line">            height: 200px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"op"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>参考<a href="https://ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></p><h4 id="flex介绍"><a href="#flex介绍" class="headerlink" title="flex介绍"></a>flex介绍</h4><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒状模型</a>，依赖 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener"><code>display</code></a> 属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/position" target="_blank" rel="noopener"><code>position</code></a>属性 + <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/float" target="_blank" rel="noopener"><code>float</code></a>属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。</p><p>2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。</p><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p><p><strong>传统布局与flex布局比较：</strong></p><ul><li><p>传统布局：</p><ul><li>兼容性好、布局繁琐、浮动（清除浮动）</li><li>有局限性不能在移动端很好的布局</li></ul></li><li><p>flex布局：</p><ul><li>操作方便，布局极其简单，移动端使用比较广泛</li><li>PC端浏览器支持情况比较差</li></ul><blockquote><p>  如果是PC端页面布局，采用传统方式；如果是移动端或者是不考虑兼容的PC端则采用flex布局</p></blockquote></li></ul><p><strong>flex布局特点：</strong></p><ul><li>任何一个容器标签都可以指定使用 flex 布局。</li><li><font color = red>当为父标签设为 flex 布局以后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</font></li><li>使用思想上和传统盒子完全不同，不要再想子元素是块级元素、行内元素，</li><li>flex通过行和列的思路来控制布局；</li></ul><p><strong>基本概念：</strong></p><p>采用 flex 布局的元素，称为 flex 容器（flex container），父级简称”<strong>容器</strong>“。它的所有子元素自动成为容器成员，称为 flex 项目（flex item），简称”<strong>项目</strong>“。</p><p><img src="https://i.loli.net/2020/11/05/Oznr9KpjHYfoLe8.png" alt=""></p><p><strong>语法使用：</strong></p><p>任何一个容器都可以指定为 Flex 布局。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>行内元素也可以使用 Flex 布局。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>Webkit 内核的浏览器，必须加上<code>-webkit</code>前缀。</p><blockquote>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"> <span class="attribute">display</span>: -webkit-flex; <span class="comment">/* Safari */</span></span><br><span class="line"> <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h4><p>容器属性有以下6个</p><ul><li><code>flex-direction</code></li><li><code>flex-wrap</code></li><li><code>flex-flow</code></li><li><code>justify-content</code></li><li><code>align-items</code></li><li><code>align-content</code></li></ul><h5 id="flex-direction属性"><a href="#flex-direction属性" class="headerlink" title="flex-direction属性"></a>flex-direction属性</h5><p> <code>flex-direction</code>属性决定主轴的方向（即项目的排列方向）。元素默认按照确认的主轴方向进行排布。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-direction:row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><p>它有4个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>row</code> (默认值)</td><td align="left">水平方向 ，从左到右</td></tr><tr><td align="left"><code>row-reverse</code></td><td align="left">水平方向，从右到左</td></tr><tr><td align="left"><code>column</code></td><td align="left">垂直方向，从上到下</td></tr><tr><td align="left"><code>column-reverse</code></td><td align="left">垂直方向，从下到上</td></tr></tbody></table><h5 id="flex-wrap属性"><a href="#flex-wrap属性" class="headerlink" title="flex-wrap属性"></a>flex-wrap属性</h5><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-wrap:nowrap | warp | wrap-reverse;</span><br></pre></td></tr></table></figure><p>它有3个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>nowarp</code>(默认值)</td><td align="left">不换行；子项目加起来的宽度超过父级的宽度时，子项宽度会被缩小，宽度只是不生效，必须设置</td></tr><tr><td align="left"><code>warp</code></td><td align="left">换行，子项的总宽加起来超过父级宽度，就会换行，第一行在上方</td></tr><tr><td align="left"><code>warp-reverse</code></td><td align="left">换行，子项的总宽加起来超过父级宽度，就会换行，第一行在下方</td></tr></tbody></table><h5 id="flex-flow属性"><a href="#flex-flow属性" class="headerlink" title="flex-flow属性"></a>flex-flow属性</h5><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><h5 id="justify-content属性"><a href="#justify-content属性" class="headerlink" title="justify-content属性"></a>justify-content属性</h5><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式，类似word里的左对齐，右对齐，居中对齐，分散对齐；</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">justify-content: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><p>它有5个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code>(默认值)</td><td align="left">从头部开始 排列，如果主轴是x轴，则从左到右（左对齐）</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">从尾部开始排列</td></tr><tr><td align="left"><code>center</code></td><td align="left">在主轴居中对齐（如果主轴是x轴 水平居中）</td></tr><tr><td align="left"><code>space-around</code></td><td align="left">每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</td></tr><tr><td align="left"><code>space-between</code></td><td align="left">两端对齐，项目之间的间隔都相等。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/TVsbDKdaExAP8f4.png" alt="image-20201105165428118"></p><h5 id="align-items属性"><a href="#align-items属性" class="headerlink" title="align-items属性"></a>align-items属性</h5><p><code>align-items</code>属性是控制子项单行在侧轴（交叉轴，默认是y轴）上的对齐方式，在子项为单项（单行）的时候使用；整体一行元素看成整体，设置在侧轴上的对齐方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-items: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>它有5个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code></td><td align="left">交叉轴的起点对齐(如果是y轴 ，从上到下）</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">交叉轴的终点对齐</td></tr><tr><td align="left"><code>center</code></td><td align="left">交叉轴的中点对齐。</td></tr><tr><td align="left"><code>stretch</code>(默认值)</td><td align="left">如果项目未设置高度或设为auto，将占满整个容器的高度。</td></tr><tr><td align="left"><code>baseline</code></td><td align="left">项目的第一行文字的基线对齐。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/Pb8shxufpnevYMS.png" alt=""></p><h5 id="align-content属性"><a href="#align-content属性" class="headerlink" title="align-content属性"></a>align-content属性</h5><p><code>align-content</code>属性设置项目在侧轴的排列方式 ，只能用于子项出现换行或者多行的情况,如果项目只有一根轴线(一行)，该属性不起作用。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">align-content: flex-start | flex-end | center | space-between | space-around | stretch;</span><br></pre></td></tr></table></figure><p>它有6个值：</p><table><thead><tr><th align="left">属性值</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left"><code>flex-start</code></td><td align="left">从侧轴头部开始排列</td></tr><tr><td align="left"><code>flex-end</code></td><td align="left">从侧轴尾部开始排列</td></tr><tr><td align="left"><code>center</code></td><td align="left">在侧轴中间显示</td></tr><tr><td align="left"><code>stretch</code>(默认值)</td><td align="left">项目高度平分容器高度</td></tr><tr><td align="left"><code>space-between</code></td><td align="left">与侧轴两端对齐，轴线之间的间隔平均分布。</td></tr><tr><td align="left"><code>space-arond</code></td><td align="left">每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</td></tr></tbody></table><p><img src="https://i.loli.net/2020/11/05/NvrsDGHJ3mp6WM9.png" alt="image-20201105171729060"></p><h4 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h4><p>项目属性有以下6个：</p><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h5 id="order属性"><a href="#order属性" class="headerlink" title="order属性"></a>order属性</h5><p><img src="https://i.loli.net/2020/11/05/EZfINrvdcjOiazR.png" alt=""></p><h5 id="flex-grow属性"><a href="#flex-grow属性" class="headerlink" title="flex-grow属性"></a>flex-grow属性</h5><p><img src="https://i.loli.net/2020/11/05/dmEyo3HPGRc9WJK.png" alt="image-20201105172534642"></p><h5 id="flex-shrink属性"><a href="#flex-shrink属性" class="headerlink" title="flex-shrink属性"></a>flex-shrink属性</h5><p><img src="https://i.loli.net/2020/11/05/QTybV43Cfz62JLo.png" alt=""></p><h5 id="flex-basis属性"><a href="#flex-basis属性" class="headerlink" title="flex-basis属性"></a>flex-basis属性</h5><p><img src="https://i.loli.net/2020/11/05/PIBMRicrzHqlyn2.png" alt=""></p><h5 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h5><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 <code>none</code> (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h5 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h5><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了auto，其他5个属性值的含义与<code>align-items</code>属性完全一样。</p><h3 id="移动端适配"><a href="#移动端适配" class="headerlink" title="移动端适配"></a>移动端适配</h3><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><blockquote><p>  媒体查询可以感受到屏幕的变化；可以根据屏幕不同的宽，从而获得不同的样式，然后实现不同的样式显示。</p><ol><li><p>CSS3 新语法，是一个查询屏幕的过程，通过查询当前屏幕尺寸属于哪个范围，从而有哪个范围的样式生效；</p></li><li><p>感受屏幕变化，屏幕变化就是宽度的变化，通过预设置，当屏幕到了我已经预设置的变化的范围，就会把我提前设置好的样式进行生效；</p></li></ol></blockquote><p><strong>语法</strong>：CSS样式如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">mediatype 查询类型:</span></span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line"><span class="comment">all 所有设备</span></span><br><span class="line"><span class="comment">print 用于打印机和打印预览</span></span><br><span class="line"><span class="comment">screen 用于电脑屏幕，平板电脑，智能手机等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">条件:</span></span><br><span class="line"><span class="comment">----</span></span><br><span class="line"><span class="comment">and 并且 not 不满足 only 仅仅满足</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">media feature 查询条件:</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line"><span class="comment">width,min-with,max-width</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">@media</span> mediatype <span class="keyword">and</span>|<span class="keyword">not</span>|<span class="keyword">only</span> (media feature) &#123;</span><br><span class="line"><span class="selector-tag">CSS-Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>例子：</strong>如果文档宽度小于 500 像素则修改背景颜色(background-color)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* min-width/max-width：最小界值，最大界值；查询条件包含等于号；*/</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span><span class="number">499px</span>) &#123;</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><blockquote><p>  rem是一个相对单位，类似于em，</p><p>  不同的是rem的基准是相对于html元素的字体大小，em是父元素字体大小。</p></blockquote><p>rem让一些不能等比自适应的元素，达到当设备尺寸发生改变的时候，等比例适配当前设备。</p><p>rem单位，可以控制整个页面所有元素有关PX类（宽、高、padding、margin、top…）只要是你设置数值的地方都可以实现控制；</p><p>根(root): 1 rem代表HTML的font-size大小；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1.根html 为 10px */</span></span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2.此时 div 的宽就是 150px */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">15rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>rem应用：</strong></p><p>使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的适配。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">320px</span>) &#123;</span><br><span class="line"><span class="selector-tag">html</span> &#123;</span><br><span class="line"><span class="attribute">font-size</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">640px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*在屏幕宽度为320px-639px的设备上，div的宽高就都是20px;</span></span><br><span class="line"><span class="comment">在屏幕宽度大与等于640px的设备上，div的宽高就都是40px;*/</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="number">1rem</span>;</span><br><span class="line">    <span class="attribute">height</span>:<span class="number">1rem</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="less"><a href="#less" class="headerlink" title="less"></a>less</h4><ul><li>less : 让你写更少的代码，实现相同的效果；</li><li>less :是一门 CSS 扩展语言，它扩展了CSS的动态特性。 CSS 预处理语言。</li><li>常见的CSS预处理器：Sass、Less、Stylus 。</li><li>Less中文网址：<a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></li></ul><p><strong>less安装：</strong></p><p>sublime安装less和less2Css插件：</p><p><a href="https://blog.csdn.net/redase/article/details/83998172" target="_blank" rel="noopener">https://blog.csdn.net/redase/article/details/83998172</a></p><p>vscode安装less插件：</p><ul><li>在扩展：商店中搜 Easy Less安装即可</li></ul><p>测试：写一个.less文件，保存，就会在当前目录生成一个对应的.css文件</p><p><img src="https://i.loli.net/2020/11/05/SCPpKOIl3Qy4soZ.png" alt="image-20201105205211449"></p><p><strong>less变量</strong></p><p>变量是指没有固定的值，可以改变的。我们CSS中的一些颜色和数值等经常使用，可以设置为变量；语法：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@变量名:值;</span></span><br><span class="line"><span class="variable">@bg:</span><span class="number">#333</span>;</span><br><span class="line"><span class="selector-class">.box_1</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@bg</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box_2</span> &#123;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@bg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量命名规则：</p><ul><li>必须有@为前缀</li><li>不能包含特殊字符~=+、不能以数字开头</li><li>大小写敏感区分；</li></ul><p><strong>less嵌套</strong></p><p>类似HTML一样写less结构；语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> <span class="selector-class">.logo</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* less 写法 */</span></span><br><span class="line"><span class="selector-id">#header</span> &#123;</span><br><span class="line">.logo &#123;</span><br><span class="line"><span class="selector-tag">width</span>: 300<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交集|伪类|伪元素选择器，语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* css写法 */</span></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* less写法 */</span></span><br><span class="line"><span class="selector-tag">a</span>&#123;</span><br><span class="line">&amp;:hover&#123;</span><br><span class="line"><span class="selector-tag">color</span><span class="selector-pseudo">:red</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>less运算</strong></p><p>任何数字、颜色或者变量都可以参与运算，Less提供了加（+）、减（-）、乘（*）、除（/）算术运算。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字</span></span><br><span class="line"><span class="attribute">width</span>: <span class="number">200px</span> - <span class="number">50</span>;</span><br><span class="line"><span class="comment">// 颜色</span></span><br><span class="line"><span class="attribute">background-color</span>: <span class="number">#666</span> - <span class="number">#222</span>;</span><br><span class="line"><span class="comment">// 注意：运算符中间左右有个空格隔开</span></span><br></pre></td></tr></table></figure><p>运算后的单位选择：</p><ul><li>如果两个值之间只有一个值有单位，则运算结果就取该单位</li><li>对于两个不同的单位的值之间的运算，运算结果的值取第一个值的单位</li></ul><blockquote><p>  更多less的用法可以访问less的文档</p><ol><li><p><a href="http://lesscss.cn/" target="_blank" rel="noopener">http://lesscss.cn/</a></p></li><li><p><a href="https://less.bootcss.com/" target="_blank" rel="noopener">https://less.bootcss.com/</a></p></li></ol></blockquote><h4 id="两种移动端适配方案"><a href="#两种移动端适配方案" class="headerlink" title="两种移动端适配方案"></a>两种移动端适配方案</h4><h5 id="方案一-：rem-媒体查询-less"><a href="#方案一-：rem-媒体查询-less" class="headerlink" title="方案一 ：rem+媒体查询+less"></a>方案一 ：rem+媒体查询+less</h5><p>上面已经说明过了</p><p>使用媒体查询根据不同设备按比例设置html的字体大小，然后页面元素使用rem做尺寸单位，当html字体大小变化，元素尺寸也会发生变化，从而达到等比缩放的适配。</p><p>大概步骤就是：</p><ol><li>准备各个档位下的rem ：提前准备好各个档位下的HTML 的font-size大小；</li><li>拿到当前尺寸的1rem代表多少px；</li><li>计算比例：把页面刚才所有的元素的PX值替换为rem,可通过less来计算。</li><li>达到目标：那么，屏尺寸变化时，1rem(基础块)也会变化，自然就是等比缩放。</li></ol><h5 id="方案二：rem-flexible-js-less"><a href="#方案二：rem-flexible-js-less" class="headerlink" title="方案二：rem+ flexible.js+less"></a>方案二：rem+ flexible.js+less</h5><p>和上个方案实现原理一样，都是通过改变1rem(基础块)大小实现页面整体元素改变；</p><p><strong>filexible.js</strong></p><ul><li><p>手机淘宝团队出的 简洁高效 移动端适配库；<font color = red>和flex布局没有任何关系</font></p></li><li><p>github地址：<a href="https://github.com/amfe/lib-flexible" target="_blank" rel="noopener">https://github.com/amfe/lib-flexible</a></p></li><li><p>不是通过设置CSS媒体查询设置font-size，通过 JS 设置font-size，效果是屏幕变化一点，就有一个rem重新计算；</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setRem</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="comment">// docEl.clientWidth JS获取当前屏幕的宽度</span></span><br><span class="line"><span class="comment">// 除以10,得到基础块,(将屏幕划分为10块)</span></span><br><span class="line"><span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span>;</span><br><span class="line">docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个例子：</p><ul><li><p>假如拿到屏幕宽度按430px设计的设计稿，</p></li><li><p>拿到UI设计稿，原稿实现：页面上所有的元素，在设计稿上进行测量，代码实现；（流式、flex）只要是UI给图上有标注，就是写出来；先全部实现出来，一会儿统一替换；</p><ul><li>在哪里写？less文件</li><li>需要把生成的css文件进行引入index.html；</li></ul></li><li><p>设计稿宽度/10 ：1rem = 43px；</p></li><li><p>统一替换：100px=100/43 rem;</p></li></ul><blockquote><p>  <strong>两种方案的对比</strong></p><ul><li>相同：<ul><li>都是对font-size实现控制，1rem（基础块）变化，实现等比效果；</li></ul></li><li>不同：<ul><li>rem+媒体查询+less：通过设置不同的档位下，设置不同的1rem值；效果为阶梯式变化；</li><li>flexible.js+rem：通过js设置不同的1rem值，效果为连续变化；这个看起来更为连贯，适配任何屏幕。</li></ul></li></ul></blockquote><h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>响应式布局可以通过同一份代码快速、有效适配手机、平板、PC设备等所有的屏幕。</p><p>响应式布局涉及屏幕宽度变化(媒体查询)和布局知识[传统布局方案(百分比、浮动、清除浮动、定位)]</p><h4 id="档位划分"><a href="#档位划分" class="headerlink" title="档位划分"></a>档位划分</h4><p>媒体查询：档位划分；市场上默认的划分，三个节点、四个档位</p><ul><li>w&lt;768 超小屏幕（xs）（手机）</li><li>768&lt;= w &lt;992 小屏设备（sm）（平板）</li><li>992&lt;= w &lt;1200 中等屏幕（md）（小显示屏的PC显示器）</li><li>1200&lt;=w 大宽屏设备（lg）（大桌面显示器）</li></ul><p><img src="https://i.loli.net/2020/11/05/tS6KdNzboRBkLiw.png" alt=""></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*把市场上所有屏幕包括在内:*/</span></span><br><span class="line"><span class="comment">/* 1. 超小屏幕下 xs 小于 768 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">0px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 小屏幕下 sm 大于等于768 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 3. 中等屏幕下 md 大于等于 992px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 4. 大屏幕下 lg 大于等于1200 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版心"><a href="#版心" class="headerlink" title="版心"></a>版心</h4><p>不同的档位下，版心不同；所有的子元素都是归于版心下，不同的版心宽度，意味着子元素要以不同的布局排版满足用户浏览友好的需求；</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. 超小屏幕下 xs 小于 768 布局容器的宽度为 100% */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width:</span> <span class="number">767px</span>) &#123;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 2. 小屏幕下 sm 大于等于768 布局容器改为 750px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">768px</span>) &#123;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line"><span class="attribute">width</span>: <span class="number">750px</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 3. 中等屏幕下 md 大于等于 992px 布局容器修改为 970px */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">992px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">970px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 4. 大屏幕下 lg 大于等于1200 布局容器修改为 1170 */</span></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width:</span> <span class="number">1200px</span>) &#123;</span><br><span class="line">    <span class="selector-class">.container</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1170px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意：</p><ul><li>媒体查询使用符号的相关：min-，max-包含等号，后面是数值单位为px；</li><li>除超小屏以外：版心的宽度设置都是小于当前档位最小界值，比如 min-width: 768px，版心是750px；两边留空白，用户体验好。</li><li>以上是市场默认划分，可根据自己需求添加档位；</li></ul></blockquote><h4 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a><a href="https://www.bootcss.com/" target="_blank" rel="noopener">BootStrap</a></h4><p>BootStrap框架可快速搭建出响应式页面；</p><ul><li><p>BootStrap 出自 Twitter（推特），是目前最受欢迎的前端响应式框架。</p></li><li><p>网址：</p><ul><li>中文网：<a href="http://www.bootcss.com/" target="_blank" rel="noopener">http://www.bootcss.com/</a></li></ul></li><li><p>版本：</p><ul><li>2.x.x：停止维护，代码不够简洁，功能不够完善。</li><li>3.x.x：目前使用最多，稳定，不支持IE6-IE7。对 IE8 支持，界面效果不好，偏向用于开发响应式布局、移动设备优先的WEB 项目。</li><li>4.x.x：最新版，目前还不是很流行</li></ul></li></ul><p><strong>使用</strong></p><p>使用前需要先去官网下载<a href="https://v3.bootcss.com/getting-started/，如无特殊需求，建议下载用于生产环境的。" target="_blank" rel="noopener">https://v3.bootcss.com/getting-started/，如无特殊需求，建议下载用于生产环境的。</a></p><p><img src="https://i.loli.net/2020/11/05/I8aFMTEqcypOxXZ.png" alt=""></p><p>下载完成后，将其整个文件夹放入你的项目中。</p><p> 初始化html文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 要求 当前网页 使用 IE浏览器 最高版本的内核 来渲染 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 视口的设置：视口的宽度和设备一致，默认的缩放比例和PC端一致，用户不能自行缩放 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>BootStrap Template<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- Bootstrap 的文件引入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--解决ie9以下浏览器对html5新增标签的不识别，并导致CSS不起作用的问题--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--解决ie9以下浏览器对 css3 Media Query 的不识别 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 条件注释:解决小于IE9的版本一些问题 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--[if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">        &lt;script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">        &lt;![endif]--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>你好，世界！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>  条件注释：满足条件，下面代码链接就会发出请求；</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-attr">[if lt IE 9]</span></span><br><span class="line">&lt;script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;</span><br><span class="line"><span class="selector-attr">[endif]</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="布局容器"><a href="#布局容器" class="headerlink" title="布局容器"></a>布局容器</h5><ul><li>版心设置：BootStrap 需要为页面内容包裹一个 .container 或者.container-fluid 容器，它提供了两个作此用处的类。</li><li><code>.container</code>：设置不同档位下的版心的宽度；<ul><li>超小屏（xs : extra small）：手机； 0px &lt;=w ；版心宽度为100%</li><li>小屏（sm : small） ：平板； 768px&lt;=w ；版心宽度定为 750px</li><li>中屏（md: medium）：桌面；992px&lt;=w ；版心宽度定为 970px</li><li>大屏（lg: large）：大桌面；1200px&lt;=w ；版心宽度定为 1170px</li></ul></li><li>.container-fluid：百分百宽度；</li><li>特点：<ul><li>所有元素为CSS3盒子模型；</li><li>布局盒子有左右15px padding值；</li></ul></li></ul><h5 id="Bootstrap预制类名"><a href="#Bootstrap预制类名" class="headerlink" title="Bootstrap预制类名"></a>Bootstrap预制类名</h5><ul><li><p>排版</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>h1. Bootstrap heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>h2. Bootstrap heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>h6. Bootstrap heading<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#type" target="_blank" rel="noopener">https://v3.bootcss.com/css/#type</a></p></li><li><p>按钮</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">role</span>=<span class="string">"button"</span>&gt;</span>Link<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"Input"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"btn btn-default"</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#buttons" target="_blank" rel="noopener">https://v3.bootcss.com/css/#buttons</a></p></li><li><p>辅助类样式</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上下文颜色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"text-muted"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下拉三角 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"caret"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/css/#helper-classes" target="_blank" rel="noopener">https://v3.bootcss.com/css/#helper-classes</a></p></li><li><p>字体图标</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 搜索🔍 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"glyphicon glyphicon-search"</span> <span class="attr">aria-hidden</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更多内容可以参考：<a href="https://v3.bootcss.com/components/#glyphicons" target="_blank" rel="noopener">https://v3.bootcss.com/components/#glyphicons</a></p></li></ul><h5 id="Bootstrap栅格系统"><a href="#Bootstrap栅格系统" class="headerlink" title="Bootstrap栅格系统"></a>Bootstrap栅格系统</h5><p>栅格系统可以设置子元素在不同档位下的布局；</p><p>栅格系统，在各个档位下，控制子元素布局不同；将版心宽度均分为12份；</p><p>各个档位下都有预制好的类前缀：</p><p><img src="https://i.loli.net/2020/11/05/v5pARWne17VXTZ9.png" alt=""></p><p>栅格系统用于通过一系列的<strong>行（row）与列（column）的组合</strong>来创建页面布局，你的内容就可以放入这些创建好的布局中，控制不同的档位下，<strong>列的子元素占有几份</strong></p><p><strong>基本使用：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 中屏和以上占有6份 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span>.col-md-6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6"</span>&gt;</span>.col-md-6<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 各个档位下，按照各个档位下布局 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-4"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-6 col-lg-8"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>单一类前缀：各个档位下的类前缀，为包括当前且向上生效；例如：.col-md-6为中屏和以上占有6份；</li><li>多个类前缀：分别按照各个档位列划分生效；</li><li>每个子项：默认左右15px的padding；</li><li>行（.row） 可以去除父容器左右15px的padding值：.row的左右margin为-15px；</li></ul><p><strong>列嵌套</strong></p><p>可以在已经分好的子元素中内部，继续进行列的划分（共12份），继续在分好的布局内继续划分；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 直接嵌套 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 使用row嵌套 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-4"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 加1个行 row 这样可以表现出抵消父元素的左右15padding值 而且高度自动和父级一样高; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-sm-6"</span>&gt;</span>小列<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>列偏移：</strong></p><p>划分好的子项进行列的份数偏移，场景：左右布局，居中布局；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 左右对齐--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果只有一个盒子 那么就偏移 = 12-4-4 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-lg-4 col-lg-offset-4"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 居中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果只有一个盒子 那么就偏移 = 2 8 2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"col-md-8 col-md-offset-2"</span>&gt;</span>中间盒子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>栅格系统相关内容可以参考：<a href="https://v3.bootcss.com/css/#grid" target="_blank" rel="noopener">https://v3.bootcss.com/css/#grid</a></p><h5 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h5><p><img src="https://i.loli.net/2020/11/05/HPAdJC73MOzXIbo.png" alt=""></p><ul><li>注意：和列类前缀的参数形成对比记忆，<ul><li>col-sm-* 是超小屏（包含）以上的屏幕都是这个份数的划分；</li><li>响应式工具 只是对当前档位下的类前缀类名生效；</li></ul></li></ul><p>响应式工具相关内容可以参考：<a href="https://v3.bootcss.com/css/#responsive-utilities" target="_blank" rel="noopener">https://v3.bootcss.com/css/#responsive-utilities</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;移动端现状&quot;&gt;&lt;a href=&quot;#移动端现状&quot; class=&quot;headerlink&quot; title=&quot;移动端现状&quot;&gt;&lt;/a&gt;移动端现状&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;内核&lt;ul&gt;
&lt;li&gt;当前国产主流手机浏览器，内核都是Webkit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分辨率：手机分辨率，碎片化太多&lt;ul&gt;
&lt;li&gt;Android：480x800, 480x854, 540x960, 720x1280，1080x1920 等&lt;/li&gt;
&lt;li&gt;iPhone：640x960, 640x1136, 750x1334, 1242x2208 等&lt;/li&gt;
&lt;li&gt;2K、4K等高分辨率&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://www.pengspace.top/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://www.pengspace.top/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="flex布局" scheme="https://www.pengspace.top/tags/flex%E5%B8%83%E5%B1%80/"/>
    
      <category term="响应式布局" scheme="https://www.pengspace.top/tags/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>枚举、注解和反射</title>
    <link href="https://www.pengspace.top/2020/11/16/%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/"/>
    <id>https://www.pengspace.top/2020/11/16/%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3%E5%92%8C%E5%8F%8D%E5%B0%84/</id>
    <published>2020-11-16T11:24:54.000Z</published>
    <updated>2020-11-16T11:48:07.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>JDK1.5引入了新的类型——枚举。</p><p>在JDK1.5 之前，我们定义常量都是： public static fianl…. 。很难管理。</p><p>枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。用于定义有限数量的一组同类常量，例如：</p><a id="more"></a><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">错误级别：</span><br><span class="line">低、中、高、急</span><br><span class="line">一年的四季：</span><br><span class="line">春、夏、秋、冬</span><br><span class="line">商品的类型：</span><br><span class="line">美妆、手机、电脑、男装、女装...</span><br></pre></td></tr></table></figure><p>在枚举类型中定义的常量是该枚举类型的<strong>实例</strong>。</p><h3 id="定义格式"><a href="#定义格式" class="headerlink" title="定义格式"></a>定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 <span class="keyword">enum</span> 枚举名称 &#123;</span><br><span class="line">实例<span class="number">1</span>,实例<span class="number">2</span>，实例<span class="number">3</span>,...实例n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;</span><br><span class="line">LOW(<span class="number">1</span>), MEDIUM(<span class="number">2</span>), HIGH(<span class="number">3</span>), URGENT(<span class="number">4</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> levelValue;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Level</span><span class="params">(<span class="keyword">int</span> levelValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.levelValue = levelValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLevelValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> levelValue;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level &#123;<span class="comment">//这样的方式更常用，通过字面意思就能理解枚举中常量的含义</span></span><br><span class="line">LOW, MEDIUM, HIGH, URGENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举类的主要方法"><a href="#枚举类的主要方法" class="headerlink" title="枚举类的主要方法"></a>枚举类的主要方法</h3><p>Enum<font color =red>抽象类</font>常见方法</p><p>Enum是所有Java语言枚举类型的公共基本类，以下是它的常见方法：</p><table><thead><tr><th align="center">变量和类型</th><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>protected Object</code></td><td align="center"><code>clone()</code></td><td align="center">抛出CloneNotSupportedException。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>compareTo(E o)</code></td><td align="center">将此枚举与指定的对象进行比较。</td></tr><tr><td align="center"><code>boolean</code></td><td align="center"><code>equals(Object other)</code></td><td align="center">如果指定的对象等于此枚举常量，则返回true。</td></tr><tr><td align="center"><code>Class&lt;?&gt;</code></td><td align="center"><code>getDeclaringClass()</code></td><td align="center">返回与此枚举常量的枚举类型对应的Class对象。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>hashCode()</code></td><td align="center">返回此枚举常量的哈希码。</td></tr><tr><td align="center"><code>String</code></td><td align="center"><code>name()</code></td><td align="center">返回此枚举常量的名称，与其枚举声明中声明的完全相同。</td></tr><tr><td align="center"><code>int</code></td><td align="center"><code>ordinal()</code></td><td align="center">返回此枚举常量的序数（它在枚举声明中的位置，其中初始常量的序数为零）。</td></tr><tr><td align="center"><code>String</code></td><td align="center"><code>toString()</code></td><td align="center">返回声明中包含的此枚举常量的名称。</td></tr><tr><td align="center"><code>static&lt;T extends Enum&lt;T&gt;&gt; T</code></td><td align="center"><code>valueOf(Class&lt;T&gt; enumType, String name)</code></td><td align="center">返回具有指定名称的指定枚举类型的枚举常量。</td></tr></tbody></table><blockquote><p>  以上方法中，只有toString()方法可以被重写</p></blockquote><h3 id="实现接口的枚举类"><a href="#实现接口的枚举类" class="headerlink" title="实现接口的枚举类"></a>实现接口的枚举类</h3><p>所有的枚举都继承自java.lang.Enum类。由于Java 不支持多继承，所以枚举对象不能再继承其他类。<br>每个枚举对象，都可以实现自己的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LShow</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Level implements LShow&#123;</span><br><span class="line">LOW&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,MEDIUM&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,HIGH&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>一旦定义了枚举，最好不要妄图修改里面的值，除非修改是必要的。</li><li>枚举类默认继承的是java.lang.Enum类而不是Object类</li><li>枚举类不能有子类，因为其枚举类默认被final修饰</li><li>只能有private构造方法</li><li>switch中使用枚举时，直接使用常量名，不用携带类名</li><li>不能定义name属性，因为自带name属性</li><li>不要为枚举类中的属性提供set方法，不符合枚举最初设计初衷。</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。</p><p>Java 语言中的类、方法、变量、参数和包等都可以被标注。和注释不同，Java 标注可以通过反射获取标<br>注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行<br>时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>主要用于：编译格式检查、反射中解析、生成帮助文档、跟踪代码依赖等</p><h3 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h3><ul><li><p><code>@Override</code>： 重写 </p><ul><li>定义在java.lang.Override</li></ul></li><li><p><code>@Deprecated</code>：废弃 </p><ul><li>定义在java.lang.Deprecated</li></ul></li><li><p><code>@SafeVarargs</code></p><ul><li>Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li></ul></li><li><p><code>@FunctionalInterface</code>： 函数式接口 </p><ul><li>Java 8 开始支持，标识一个匿名函数或函数式接口。</li></ul></li><li><p><code>@Repeatable</code>：标识某注解可以在同一个声明上使用多次</p></li><li><p>Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</p></li><li><p><code>SuppressWarnings()</code>  抑制编译时的警告信息。 </p><ul><li><p>定义在java.lang.SuppressWarnings</p></li><li><p>三种使用方式</p><ul><li><code>@SuppressWarnings(&quot;unchecked&quot;)</code> ： 抑制单类型的警告</li><li><code>@SuppressWarnings(&quot;unchecked&quot;,&quot;rawtypes&quot;)</code>：抑制多类型的警告</li><li><code>@SuppressWarnings(&quot;all&quot;)</code>：抑制所有类型的警告</li></ul></li><li><p>参数列表：</p><ul><li><table><thead><tr><th>关键字</th><th>用途</th></tr></thead><tbody><tr><td>all</td><td>抑制所有警告</td></tr><tr><td>boxing</td><td>抑制装箱、拆箱操作时候的警告</td></tr><tr><td>cast</td><td>抑制映射相关的警告</td></tr><tr><td>dep-ann</td><td>抑制启用注释的警告</td></tr><tr><td>deprecation</td><td>抑制过期方法警告</td></tr><tr><td>fallthrough</td><td>抑制确在switch中缺失breaks的警告</td></tr><tr><td>finally</td><td>抑制finally模块没有返回的警告</td></tr><tr><td>hiding</td><td>抑制相对于隐藏变量的局部变量的警告</td></tr><tr><td>incomplete-switch</td><td>忽略没有完整的switch语句</td></tr><tr><td>nls</td><td>忽略非nls格式的字符</td></tr><tr><td>null</td><td>忽略对null的操作</td></tr><tr><td>rawtypes</td><td>使用generics时忽略没有指定相应的类型</td></tr><tr><td>restriction</td><td>抑制禁止使用劝阻或禁止引用的警告</td></tr><tr><td>serial</td><td>忽略在serializable类中没有声明serialVersionUID变量</td></tr><tr><td>static-access</td><td>抑制不正确的静态访问方式警告</td></tr><tr><td>synthetic-access</td><td>抑制子类没有按最优方法访问内部类的警告</td></tr><tr><td>unchecked</td><td>抑制没有进行类型检查操作的警告</td></tr><tr><td>unqualified-field-access</td><td>抑制没有权限访问的域的警告</td></tr><tr><td>unused</td><td>抑制没被使用过的代码的警告</td></tr></tbody></table></li></ul></li></ul></li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>元注解就是<strong>作用在其他注解</strong>的注解。有下面几种：</p><ul><li><p><code>@Retention</code>- 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p></li><li><p><code>@Documented</code> - 标记这些注解是否包含在用户文档中。</p></li><li><p><code>@Target</code> - 标记这个注解应该是哪种 Java 成员。</p></li><li><p><code>@Inherited</code> - 标记这个注解是自动继承的</p><ul><li>子类会继承父类使用的注解中被<code>@Inherited</code>修饰的注解</li></ul><ol start="2"><li>接口继承关系中，子接口不会继承父接口中的任何注解，不管父接口中使用的注解有没有<br> 被<code>@Inherited</code>修饰</li><li>类实现接口时不会继承任何接口中定义的注解</li></ol></li></ul><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h4 id="注解架构"><a href="#注解架构" class="headerlink" title="注解架构"></a>注解架构</h4><p><img src="https://i.loli.net/2020/10/26/e5pqFSIxH2NdlUn.png" alt=""></p><ul><li><p><strong><code>Annotation</code>与<code>RetentionPolicy</code> 、<code>ElementType</code> 。</strong></p><p>每 1 个 <code>Annotation</code> 对象，都会有<strong>唯一的 <code>RetentionPolicy</code> 属性，有 1~n个<code>ElementType</code>属性</strong>。</p></li><li><p><strong><code>ElementType</code>(注解的用途类型)</strong></p><p>“每 1 个 <code>Annotation</code>“ 都与 “1～n 个 <code>ElementType</code>“ 关联。当 <code>Annotation</code> 与某个 <code>ElementType</code> 关联时，就意味着：<code>Annotation</code>有了某种用途。例如，若一个 <code>Annotation</code> 对象是 <code>METHOD</code> 类型，则该<code>Annotation</code> 只能用来修饰方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">TYPE, <span class="comment">// 类、接口（包括注释类型）或枚举声明 </span></span><br><span class="line">FIELD,  <span class="comment">// 字段声明（包括枚举常量）</span></span><br><span class="line">METHOD, <span class="comment">// 方法声明 </span></span><br><span class="line">PARAMETER,  <span class="comment">// 参数声明 </span></span><br><span class="line">CONSTRUCTOR,  <span class="comment">// 构造方法声明 </span></span><br><span class="line">LOCAL_VARIABLE, <span class="comment">// 局部变量声明 </span></span><br><span class="line">ANNOTATION_TYPE,<span class="comment">// 注释类型声明 </span></span><br><span class="line">PACKAGE <span class="comment">// 包声明 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong><code>RetentionPolicy</code>（注解作用域策略）</strong>。</p><p>“每 1 个 <code>Annotation</code>“ 都与 “1 个 <code>RetentionPolicy</code>“ 关联。</p><ul><li>若 <code>Annotation</code> 的类型为 <code>SOURCE</code>，则意味着：<code>Annotation</code> 仅存在于编译器处理期间，编译器处理完之后，该<code>Annotation</code> 就没用了。 例如，”<code>@Override</code>“ 标志就是一个 <code>Annotation</code>。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”<code>@Override</code>“ 就没有任何作用了。</li><li>若 <code>Annotation</code> 的类型为 <code>CLASS</code>，则意味着：编译器将 <code>Annotation</code> 存储于类对应的 <code>.class</code>文件中，它是 <code>Annotation</code> 的默认行为。</li><li>若 <code>Annotation</code> 的类型为 <code>RUNTIME</code>，则意味着：编译器将 <code>Annotation</code> 存储于 <code>.class</code> 文件中，并且可由JVM读入。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">SOURCE, <span class="comment">//Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了</span></span><br><span class="line">CLASS, <span class="comment">//编译器将Annotation存储于类对应的.class文件中。默认行为</span></span><br><span class="line">RUNTIME <span class="comment">//编译器将Annotation存储于class文件中，并且可由JVM读入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="定义格式-1"><a href="#定义格式-1" class="headerlink" title="定义格式"></a>定义格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> 自定义注解名&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  注意事项</p><ol><li>定义的注解，自动继承了java.lang.annotation.Annotation接口</li><li><strong>注解中的每一个方法，实际是声明的注解配置参数</strong><ul><li>方法的名称就是配置参数的名称</li><li>方法的返回值类型，就是配置参数的类型。只能是：基本类型/Class/String/enum</li></ul></li><li>可以通过default来声明参数的默认值</li><li>如果只有一个参数成员，一般参数名为value</li><li>注解元素必须要有值，我们定义注解元素时，经常使用空字符串、 0 作为默认值。</li></ol></blockquote><p><strong>案例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">参数类型 参数名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码的作用是定义一个 <code>Annotation</code>，我们可以在代码中通过 “<code>@MyAnnotation1</code>“ 来使用它。<br><code>@Documented</code>， <code>@Target</code>，<code>@Retention</code>，<code>@interface</code> 都是来修饰 <code>MyAnnotation1</code> 的。含义：</p><ul><li><p><code>@interface</code></p><p>使用 <code>@interface</code> 定义注解时，意味着它实现了 <code>java.lang.annotation.Annotation</code> 接口，即该注解就是<code>一个Annotation</code>。</p><blockquote><p>  <font color = red>定义<code>Annotation</code> 时，<code>@interface</code> 是必须的。</font></p><p>  注意：它和我们通常的 <code>implemented</code> 实现接口的方法不同。<code>Annotation</code> 接口的实现细节都由编译器完成。通过 <code>@interface</code> 定义注解后，该注解不能继承其他的注解或接口。</p></blockquote></li><li><p><code>@Documented</code></p><p>类和方法的 <code>Annotation</code> 在缺省情况下是不出现在 <code>javadoc</code> 中的。如果使用 <code>@Documented</code> 修饰该<br><code>Annotation</code>，则表示它可以出现在 <code>javadoc</code> 中。</p><blockquote><p>  定义 <code>Annotation</code> 时，<strong><code>@Documented</code>可有可无</strong>；若没有定义，则 <code>Annotation</code> 不会出现在 <code>javadoc</code>中。</p></blockquote></li><li><p><code>@Target(ElementType.TYPE)</code></p><p><code>ElementType</code> 是 <code>Annotation</code> 的类型属性。而 <code>@Target</code> 的作用，就是来指定<code>Annotation</code> 的类型属性的。</p><p><code>@Target(ElementType.TYPE)</code> 的意思就是指定该 <code>Annotation</code> 的类型是 <code>ElementType.TYPE</code>。这就意味着，<code>MyAnnotation1</code> 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。</p><blockquote><p>  定义 <code>Annotation</code> 时，<strong><code>@Target</code> 可有可无</strong>。若有 <code>@Target</code>，则该 <code>Annotation</code> 只能用于它所指定的地方；若没有 <code>@Target</code>，则该 <code>Annotation</code> 可以用于任何地方。</p></blockquote></li><li><p><code>@Retention(RetentionPolicy.RUNTIME)</code></p><p><code>RetentionPolicy</code> 是 <code>Annotation</code> 的策略属性，而 <code>@Retention</code> 的作用，就是指定<code>Annotation</code> 的策略属性。</p><p><code>@Retention(RetentionPolicy.RUNTIME)</code> 的意思就是指定该 <code>Annotation</code> 的策略是<br><code>RetentionPolicy.RUNTIME</code>。这就意味着，编译器会将该 <code>Annotation</code> 信息保留在 <code>.class</code>文件中，并且能被JVM虚拟机读取。</p><blockquote><p>  定义 <code>Annotation</code> 时，<code>@Retention</code>可有可无。若没有 <code>@Retention</code>，则默认是<br>  <code>RetentionPolicy.CLASS</code>。</p></blockquote></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/JAVA%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/6015990?fr=aladdin" target="_blank" rel="noopener">JAVA反射机制</a>是在运行状态中，获取任意一个类的结构 、 创建对象 、得到方法、执行方法 、属性，这种在运行状态动态获取信息以及动态调用对象方法的功能被称为java语言的反射机制。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>Java类加载器（Java Classloader）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。</p><p>java默认有三种类加载器:<code>BootstrapClassLoader</code>、<code>ExtensionClassLoader</code>、<code>App ClassLoader</code>。</p><ul><li><p><strong>BootstrapClassLoader（引导启动类加载器）：</strong><br>嵌在JVM内核中的加载器，该加载器是用C++语言（原生语言）写的，主要负载加载JAVA_HOME/lib下的类库，引导启动类加载器无法被应用程序直接使用。</p></li><li><p><strong>ExtensionClassLoader（扩展类加载器）</strong>：<br>ExtensionClassLoader是用JAVA编写，且它的父类加载器是Bootstrap。</p><p>是由sun.misc.Launcher$ExtClassLoader实现的，主要加载JAVA_HOME/lib/ext目录中的类库。</p></li><li><p><strong>App ClassLoader（应用类加载器）</strong>：<br>App ClassLoader是应用程序类加载器，负责加载应用程序classpath目录下的所有jar和class文<br>件。它的父加载器为Ext ClassLoader</p></li></ul><p><img src="https://i.loli.net/2020/10/26/TGtjSkCnMwp8qUO.png" alt=""></p><blockquote><p>  类通常是按需加载，即第一次使用该类时才加载。由于有了类加载器，Java运行时系统不需要知道文件与文件系统。</p><p>  <strong>委派</strong></p><p>  双亲委派模型：<font color = red>如果一个类加载器收到了一个类加载请求，它不会自己去尝试加载这个类，而是把这个请求转交给父类加载器去完成</font>。每一个层次的类加载器都是如此。因此所有的类加载请求都应该传递到最顶层的启动类加载器中，只有到父类加载器反馈自己无法完成这个加载请求（在它的搜索范围没有找到这个类）时，子类加载器才会尝试自己去加载。委派的好处就是避免有些类被重复加载。</p></blockquote><blockquote><p>  <strong>加载配置文件</strong></p><p>  如果我们的项目下有source文件夹，类.class.getClassLoader().getResourceAsStream(文件名)加载的是source文件夹下的文件，前提是将文件夹定义为Resources Root</p><p>  <img src="https://i.loli.net/2020/10/26/4THGmUu6PEno3qk.png" alt="image-20201026212548653"></p><p>  <img src="https://i.loli.net/2020/10/26/JqeIEhX34APUScv.png" alt=""></p></blockquote><h3 id="获取类对象"><a href="#获取类对象" class="headerlink" title="获取类对象"></a>获取类对象</h3><p>要想了解一个类，必须先要获取到该类的字节码文件对象。在Java中，每一个字节码文件，被加载到内存后，都存在一个对应的Class类型的对象</p><p><strong>得到Class的几种方式</strong></p><ol><li><p>如果在编写代码时, 知道类的名称, 且类已经存在, 可以通过下面代码得到一个类的 类对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">包名.类名<span class="class">.<span class="keyword">class</span></span></span><br></pre></td></tr></table></figure></li><li><p>如果拥有类的对象, 可以通过下面代码得到一个类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class 对象.getClass()</span><br></pre></td></tr></table></figure></li><li><p>如果在编写代码时, 知道类的名称 , 可以通过下面代码得到一个类的类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"包名.类名"</span>);</span><br></pre></td></tr></table></figure></li></ol><p>上述的三种方式, 在调用时, 如果类在内存中不存在, 则会加载到内存! 如果类已经在内存中存在, 不会重复加载, 而是重复利用!</p><p><img src="https://i.loli.net/2020/10/26/2X4A53NFvROnwGx.png" alt=""></p><blockquote><p>  (一个class文件 在内存中不会存在两个类对象 )</p><p>  特殊的类对象</p><ul><li>基本数据类型的类对象:<ul><li>基本数据类型.class</li><li>包装类.type</li></ul></li><li>基本数据类型包装类对象:<ul><li>包装类.class</li></ul></li></ul></blockquote><h3 id="获取Constructor"><a href="#获取Constructor" class="headerlink" title="获取Constructor"></a>获取Constructor</h3><p><strong>通过class对象 获取一个类的构造方法</strong></p><ol><li><p>通过指定的参数类型, 获取指定的单个构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getConstructor(参数类型的<span class="class"><span class="keyword">class</span>对象数组)</span></span><br></pre></td></tr></table></figure><p> 例如，构造方法如下: </p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person(String name,<span class="keyword">int</span> age)</span><br></pre></td></tr></table></figure><p> 得到这个构造方法的代码如下:</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Constructor c = p.getClass().getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">int</span>.<span class="title">class</span>)</span>;</span><br></pre></td></tr></table></figure></li><li><p>获取构造方法数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getConstructors();</span><br></pre></td></tr></table></figure></li><li><p>获取所有权限的单个构造方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructor(参数类型的<span class="class"><span class="keyword">class</span>对象数组)</span></span><br></pre></td></tr></table></figure></li><li><p>获取所有权限的构造方法数组</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredConstructors();</span><br></pre></td></tr></table></figure></li></ol><p><strong>Constructor 创建对象</strong></p><p>常用方法:</p><ul><li><p><code>newInstance(Object... para)</code></p><p>调用这个构造方法, 把对应的对象创建出来<br>参数: 是一个Object类型可变参数, 传递的参数顺序 必须匹配构造方法中形式参数列表的顺序!</p></li><li><p><code>setAccessible(boolean flag)</code><br>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的方法)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/OUb4plBsyCr7gX2.png" alt=""></p><h3 id="获取Method"><a href="#获取Method" class="headerlink" title="获取Method"></a>获取Method</h3><p><strong>通过class对象获取一个类的方法</strong></p><ol><li><p>根据参数列表的类型和方法名, 得到一个方法(public修饰的)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMethod(String methodName , <span class="class"><span class="keyword">class</span>... <span class="title">clss</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>得到一个类的所有方法 (public修饰的)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getMethods()</span><br></pre></td></tr></table></figure></li><li><p>根据参数列表的类型和方法名, 得到一个方法(除继承以外所有的:包含私有，公有， 保护， 默认)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethod(String methodName , <span class="class"><span class="keyword">class</span>... <span class="title">clss</span>)</span></span><br></pre></td></tr></table></figure></li><li><p>得到一个类的所有方法 (除继承以外所有的:包含私有，公有， 保护， 默认)</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredMethods()</span><br></pre></td></tr></table></figure></li></ol><p><strong>Method 执行方法</strong></p><ul><li><p><code>invoke(Object o,Object... para)</code></p><p>参数1. 要调用方法的对象<br>参数2. 要传递的参数列表</p></li><li><p><code>getName()</code><br>获取方法的方法名称</p></li><li><p><code>setAccessible(boolean flag)</code><br>如果flag为true 则{表示忽略访问权限检查 !(可以访问任何权限的方法)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/u3T6tlMyavn59Kf.png" alt=""></p><h3 id="获取Field"><a href="#获取Field" class="headerlink" title="获取Field"></a>获取Field</h3><p><strong>通过class对象 获取一个类的属性</strong></p><ol><li><p>根据属性的名称, 获取一个属性对象 (所有属性)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredField(String filedName)</span><br></pre></td></tr></table></figure></li><li><p>获取所有属性(所有权限)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getDeclaredFields()</span><br></pre></td></tr></table></figure></li><li><p>根据属性的名称, 获取一个属性对象 (public属性)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getField(String filedName)</span><br></pre></td></tr></table></figure></li><li><p>获取所有属性 (public)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getFields()</span><br></pre></td></tr></table></figure></li></ol><p><strong>Field 属性的对象类型</strong></p><p>常用方法:</p><ul><li><p><code>get(Object o)</code></p><p>参数: 要获取属性的对象，获取指定对象的此属性值</p></li><li><p><code>set(Object o , Object value)</code></p><p>参数1.要设置属性值的对象，参数2. 要设置的值。设置指定对象的属性的值</p></li><li><p><code>getName()</code><br>获取属性的名称</p></li><li><p><code>setAccessible(boolean flag)</code></p><p>如果flag为true 则表示忽略访问权限检查 !(可以访问任何权限的属性)</p></li></ul><p><img src="https://i.loli.net/2020/10/26/JzatTMCxEkdjfZw.png" alt=""></p><h3 id="获取注解信息"><a href="#获取注解信息" class="headerlink" title="获取注解信息"></a>获取注解信息</h3><p><strong>获取类/属性/方法的全部注解对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Annotation[] annotations = Class/Field/Method.getAnnotations();</span><br><span class="line"><span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">    System.out.println(annotation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>根据类型获取类/属性/方法的注解对象</strong></p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注解类型 对象名 = (注解类型) c.getAnnotation(注解类型<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/26/ZuIB4gvK5yWfUxD.png" alt=""></p><h2 id="内省"><a href="#内省" class="headerlink" title="内省"></a>内省</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>内省即基于反射 ，java所提供的一套应用到JavaBean的API。</p><blockquote><p>  一个定义在包中的类 ，拥有无参构造器，所有属性私有，所有属性提供get/set方法，实现了序列化接口。这种类, 我们称其为 bean类。</p><p>  Java提供了一套java.beans包的api ，对反射的操作，进行了封装!</p></blockquote><h3 id="Introspector"><a href="#Introspector" class="headerlink" title="Introspector"></a>Introspector</h3><p>获取Bean类信息，方法:</p><p><code>BeanInfo getBeanInfo(Class cls)</code> :通过传入的类信息, 得到这个Bean类的封装对象.</p><h3 id="BeanInfo"><a href="#BeanInfo" class="headerlink" title="BeanInfo"></a>BeanInfo</h3><p>常用的方法:</p><p><code>MethodDescriptor[] getPropertyDescriptors()</code>:获取bean类的 get/set方法 数组</p><h3 id="MethodDescriptor"><a href="#MethodDescriptor" class="headerlink" title="MethodDescriptor"></a>MethodDescriptor</h3><p>常用方法:</p><p><code>Method getReadMethod()</code>：获取一个get方法</p><p><code>Method getWriteMethod()</code>：获取一个set方法</p><p><font color = red>有可能返回null 注意加判断!</font></p><p><img src="https://i.loli.net/2020/10/26/8UqRoVuAdaIewJ6.png" alt="image-20201026234226051"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;枚举&quot;&gt;&lt;a href=&quot;#枚举&quot; class=&quot;headerlink&quot; title=&quot;枚举&quot;&gt;&lt;/a&gt;枚举&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;JDK1.5引入了新的类型——枚举。&lt;/p&gt;
&lt;p&gt;在JDK1.5 之前，我们定义常量都是： public static fianl…. 。很难管理。&lt;/p&gt;
&lt;p&gt;枚举，可以把相关的常量分组到一个枚举类型里，而且枚举提供了比常量更多的方法。用于定义有限数量的一组同类常量，例如：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>XML和JSON的使用（java）</title>
    <link href="https://www.pengspace.top/2020/10/24/XML%E5%92%8CJSON%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88java%EF%BC%89/"/>
    <id>https://www.pengspace.top/2020/10/24/XML%E5%92%8CJSON%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88java%EF%BC%89/</id>
    <published>2020-10-24T08:24:49.000Z</published>
    <updated>2020-11-16T11:26:06.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fromtitle=xml&fromid=86251&fr=aladdin" target="_blank" rel="noopener">XML</a>全称可扩展标记语言（eXtensible Markup Language）。是一种用于标记电子文件使其具有结构性的标记语言。</p><a id="more"></a><blockquote><p>  在电子计算机中，标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种的信息比如文章等。它可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。 它非常适合万维网传输，提供统一的方法来描述和交换独立于应用程序或供应商的结构化数据。是Internet环境中跨平台的、依赖于内容的技术，也是当今处理分布式结构信息的有效工具。早在1998年，W3C就发布了XML1.0规范，使用它来简化Internet的文档信息传输。</p></blockquote><p><strong>特性:</strong></p><ol><li>xml具有平台无关性, 是一门独立的标记语言.</li><li>xml具有自我描述性</li></ol><p><strong>用途</strong></p><ol><li>网络数据传输</li><li>数据存储</li><li>配置文件</li></ol><blockquote><p>  .XML文件是保存XML数据的一种方式，XML数据也可以以其他的方式存在（如在内存中构建XML数据）。不要将XML语言狭隘的理解成XML文件。</p></blockquote><p>###XML语法</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>在XML文档开头，要先写XML文档声明，格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br></pre></td></tr></table></figure><p>XML文档正文都是由一个个的<strong>标记</strong>组成的，包含：</p><ul><li>开始标记(开放标记): &lt;标记名称&gt;</li><li>结束标记(闭合标记): &lt;/标记名称&gt;</li><li>标记内容: 开始标记与结束标记之间 ，是标记的内容。</li></ul><blockquote><p>  标记名称: 自定义名称，必须遵循以下命名规则：</p><ol><li>名称可以含字母、数字以及其他的字符</li><li>名称不能以数字或者标点符号开始</li><li>名称不能以字符 “xml”（或者 XML、Xml）开始</li><li>名称不能包含空格，不能包含冒号（:）</li><li>名称区分大小写</li></ol></blockquote><p>例如 ,我们通过标记, 描述一个名字:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>答案<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>一个XML文档中，必须有且且仅允许有一个根标记。</p></li><li><p>标记可以嵌套, 但是不允许交。</p></li><li><p>标记名称 允许重复</p></li><li><p>标记的层级称呼 (子标记，父标记 ，兄弟标记，后代标记 ，祖先标记)，例如下面代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">length</span>&gt;</span>180cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">length</span>&gt;</span>200cm<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><p>name是person的子标记，是person的后代标记，是persons的后代标记，是length的兄弟标记。person是name的父标记。persons是name的祖先标记。</p></li><li><p>标记除了开始和结束 , 还可以包含属性。标记中的属性，在标记开始时描述，由属性名和属性值组成。<br>在开始标记中, 描述属性，可以包含0-n个属性，每一个属性是一个键值对!<br>属性名不允许重复 ，键与值之间使用等号连接, 多个属性之间使用空格分割，属性值 必须被引号引住。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"10001"</span> <span class="attr">groupid</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>可以在XML文档中写注释，但是不能写在文档声明前，不能嵌套注释。<br>格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释 --&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="语法进阶CDATA"><a href="#语法进阶CDATA" class="headerlink" title="语法进阶CDATA"></a>语法进阶CDATA</h4><p>CDATA 是不会被 XML 解析器解析的文本数据。像 “&lt;” 和 “&amp;” 字符在 XML 元素中都是非法的。</p><blockquote><p>  “&lt;” 会产生错误，因为解析器会把该字符解释为新元素的开始。</p><p>  “&amp;” 会产生错误，因为解析器会把该字符解释为字符实体的开始。</p></blockquote><p>某些文本，比如 JavaScript 代码，包含大量 “&lt;” 或 “&amp;” 字符。为了避免错误，可以将脚本代码定义为 CDATA。CDATA 部分中的所有内容都会被解析器忽略。定义格式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[脚本代码]]&gt;</span><br></pre></td></tr></table></figure><h3 id="Java解析XML"><a href="#Java解析XML" class="headerlink" title="Java解析XML"></a>Java解析XML</h3><p>在java中，XML可以通过下面四种方式解析</p><ol><li>SAX解析</li><li>DOM解析</li><li>JDOM解析</li><li>DOM4J解析</li></ol><p>其实也可以说成SAX和DOM两种解析方式，因为后面两种也属于DOM解析，是由DOM解析的基础上扩展来的，只是用与Java。</p><h4 id="SAX解析"><a href="#SAX解析" class="headerlink" title="SAX解析"></a>SAX解析</h4><p>解析方式是事件驱动机制 !</p><p>SAX解析器，<strong>逐行读取</strong>XML文件进行解析 ，每当解析到一个标签的<strong>开始/结束/内容/属性</strong>时，触发事件。我们可以编写程序在这些事件发生时，进行相应的处理。</p><blockquote><p>  <strong>优点：</strong></p><ol><li>分析能够立即开始，而不是等待所有的数据被处理</li><li>逐行加载，节省内存。有助于解析大于系统内存的文档</li><li>有时不必解析整个文档，它可以在某个条件得到满足时停止解析。</li></ol><p>  <strong>缺点：</strong></p><ol><li>单向解析，无法定位文档层次，无法同时访问同一文档的不同部分数据(因为逐行解析，当解析第n行时，第n-1行已经被释放了，无法再进行操作了)。</li><li>无法得知事件发生时元素的层次，只能自己维护节点的父/子关系.</li><li>只读解析方式，无法修改XML文档的内容。</li></ol></blockquote><h4 id="DOM解析"><a href="#DOM解析" class="headerlink" title="DOM解析"></a>DOM解析</h4><p>是用与平台和语言无关的方式表示XML文档的官方W3C标准，分析该结构通常需要<strong>加载整个文档</strong>和内存中建立文档树模型。程序员可以通过操作文档树，来完成数据的获取、修改、删除等.</p><blockquote><p>  <strong>优点:</strong></p><ol><li>文档在内存中加载，允许对数据和结构做出更改.</li><li>访问是双向的，可以在任何时候在树中双向解析数据。</li></ol><p>  <strong>缺点:</strong></p><ol><li>文档全部加载在内存中，消耗资源大.</li></ol></blockquote><h4 id="JDOM解析"><a href="#JDOM解析" class="headerlink" title="JDOM解析"></a>JDOM解析</h4><p>目的是解析为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。由于是第一个Java特定模型，JDOM一直得到大力推广和促进。</p><blockquote><p>  优点:</p><ol><li><p>使用具体类而不使用接口，简化了DOM的API。</p></li><li><p>大量使用了Java集合类，方便了Java开发人员。</p><p>缺点：</p></li><li><p>没有较好的灵活性。</p></li><li><p>性能不是那么优异。</p></li></ol></blockquote><h4 id="DOM4J解析"><a href="#DOM4J解析" class="headerlink" title="DOM4J解析"></a>DOM4J解析</h4><p>它是JDOM的一种智能分支。它合并了许多超出基本XML文档表示的功能，包括集成的XPath支持、XML Schema支持以及用于大文档或流化文档的基于事件的处理。它还提供了构建文档表示的选项。</p><p>DOM4J是一个非常优秀的Java XML API，具有性能优异、灵活性好、功能强大和极端易用使用的特点，同时它也是一个开放源代码的软件。如今你可以看到越来越多的Java软件都在使用DOM4J来读写XML。</p><h5 id="DOM4J解析XML"><a href="#DOM4J解析XML" class="headerlink" title="DOM4J解析XML"></a>DOM4J解析XML</h5><p><strong>步骤:</strong></p><ol><li><p>引入DOM4j的jar包 dom4j.jar</p></li><li><p>创建一个指向XML文件的输入流</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"xml文件的地址"</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建一个XML读取工具对象<code>SAXReader</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXReader sr = <span class="keyword">new</span> SAXReader();</span><br></pre></td></tr></table></figure></li><li><p>使用读取工具对象，读取XML文档的输入流， 并得到文档对象<code>Document</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document doc = sr.read(fis);</span><br></pre></td></tr></table></figure></li><li><p>通过文档对象, 获取XML文档中的根元素对象 <code>Element root</code></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.getRootElement();</span><br></pre></td></tr></table></figure></li></ol><p><strong>文档对象 <code>Document</code></strong></p><p>指的是加载到内存的 整个XML文档。常用方法:</p><ol><li><p>通过文档对象, 获取XML文档中的根元素对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.getRootElement();</span><br></pre></td></tr></table></figure></li><li><p>添加根节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.addElement(<span class="string">"根节点名称"</span>);</span><br></pre></td></tr></table></figure></li></ol><p><strong>元素对象 <code>Element</code></strong></p><p>指的是XML文档中的单个节点。常用方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getName()</code></td><td>获取当前节点的标记名称</td></tr><tr><td><code>String getText()</code></td><td>获取节点内容</td></tr><tr><td><code>void setText(String s)</code></td><td>设置节点内容</td></tr><tr><td><code>String attributeValue(String s)</code></td><td>获取节点的属性值，s表示属性名称</td></tr><tr><td><code>void addAttribute(String key,String value)</code></td><td>添加属性 （key属性名，value属性值）</td></tr><tr><td><code>Element element(String name)</code></td><td>根据子节点名称获取匹配名称的第一个子节点对象</td></tr><tr><td><code>List&lt;Element&gt; elements()</code></td><td>获取所有的子节点对象</td></tr><tr><td><code>String elementText(String s)</code></td><td>返回子节点内容，s表示子标签名称</td></tr><tr><td><code>Element addElement(String name)</code></td><td>添加子节点  （name子节点名称）</td></tr></tbody></table><p><strong>解析本地文件案例</strong></p><p><img src="https://i.loli.net/2020/10/24/DWNRyanEpfSKIt9.png" alt=""></p><p><strong>解析网络文件案例</strong></p><p><img src="https://i.loli.net/2020/10/24/yR6wnKSqAjibEgI.png" alt=""></p><h5 id="DOM4J-XPATH解析XML"><a href="#DOM4J-XPATH解析XML" class="headerlink" title="DOM4J - XPATH解析XML"></a>DOM4J - XPATH解析XML</h5><p>XPATH就是通过路径快速的查找一个或一组元素</p><table><thead><tr><th>标记</th><th>解释</th></tr></thead><tbody><tr><td>/</td><td>从根节点开找</td></tr><tr><td>//</td><td>查找后代节点</td></tr><tr><td>.</td><td>查找当前节点</td></tr><tr><td>…</td><td>查找父节点</td></tr><tr><td>@</td><td>选择属性，属性使用方式:<br>[@属性名=‘值’] <br>[@属性名&gt;‘值’]<br>[@属性名&lt;‘值’] <br>[@属性名!=‘值’]</td></tr></tbody></table><p>例如：在我们解析本地文件案例中有一个books.xml文件，如果我们想找到 “三国演义”这个元素，XPATH 路径k可以这样写：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//book[@id='1001']//name</span><br></pre></td></tr></table></figure><p>通过Node类的两个方法, 来完成查找(Node是 Document 与 Element 的父接口)</p><p>方法1，根据路径表达式， 查找匹配的单个节点，如果结果有多个，只取第一个</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node e = selectSingleNode(<span class="string">"路径表达式"</span>);</span><br></pre></td></tr></table></figure><p>方法2，根据路径表达式， 查找匹配的所有节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Node&gt; es = selectNodes(<span class="string">"路径表达式"</span>);</span><br></pre></td></tr></table></figure><p>例子：</p><p><img src="https://i.loli.net/2020/10/24/dptXgi5PVfseMKL.png" alt=""></p><p><img src="https://i.loli.net/2020/10/24/IXvg15HAyc8KQ4J.png" alt="image-20201024011319670"></p><h3 id="Java生成XML"><a href="#Java生成XML" class="headerlink" title="Java生成XML"></a>Java生成XML</h3><p><strong>步骤:</strong></p><ol><li><p>通过文档帮助器 (<code>DocumentHelper</code>) ，创建空的文档对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Document doc = DocumentHelper.createDocument();</span><br></pre></td></tr></table></figure></li><li><p>通过文档对象，向其中添加根节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element root = doc.addElement(<span class="string">"根节点名称"</span>);</span><br></pre></td></tr></table></figure></li><li><p>通过根节点对象root , 丰富我们的子节点</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element e = root.addElement(<span class="string">"元素名称"</span>);</span><br></pre></td></tr></table></figure></li><li><p>创建一个文件输出流 ,用于存储XML文件</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"要存储的位置"</span>);</span><br></pre></td></tr></table></figure></li><li><p>将文件输出流, 转换为XML文档输出流</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XMLWriter xw = <span class="keyword">new</span> XMLWriter(fos);</span><br></pre></td></tr></table></figure></li><li><p>写出文档</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xw.write(doc);</span><br></pre></td></tr></table></figure></li><li><p>释放资源</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xw.close();</span><br></pre></td></tr></table></figure></li></ol><p><strong>例子</strong></p><p><img src="https://i.loli.net/2020/10/24/wJnlYCycOIZ2jVk.png" alt="image-20201024014247166"></p><p>####XStream的使用</p><p>快速的将Java中的对象, 转换为 XML字符串.</p><p>使用步骤:</p><ol><li><p>创建XStream 对象</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">XStream x</span> = new XStream();</span><br></pre></td></tr></table></figure></li><li><p>修改类生成的节点名称 (默认节点名称为 包名.类名)</p> <figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.<span class="keyword">alias</span>(<span class="string">"节点名称"</span>,类名<span class="class">.<span class="keyword">class</span>);</span></span><br></pre></td></tr></table></figure></li><li><p>传入对象 , 生成XML字符串</p> <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">xml</span>字符串 = x.toXML(对象);</span><br></pre></td></tr></table></figure></li></ol><p>例子：</p><p><img src="https://i.loli.net/2020/10/24/BMce4ZkQX85qbNi.png" alt="image-20201024013927345"></p><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><a href="https://baike.baidu.com/item/JSON/2462549?fr=aladdin" target="_blank" rel="noopener">JSON</a>全称JavaScript Object Notation ，JS对象简谱 ，是一种轻量级的数据交换格式。</p><blockquote><p>  它基于 <a href="https://baike.baidu.com/item/ECMAScript" target="_blank" rel="noopener">ECMAScript</a> (欧洲计算机协会制定的js规范)的一个子集，采用完全独立于编程语言的文本格式来存储和表示数据。简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。</p><p>  JSON是[Douglas Crockford](<a href="https://baike.baidu.com/item/Douglas" target="_blank" rel="noopener">https://baike.baidu.com/item/Douglas</a> Crockford/5960317)在2001年开始推广使用的数据格式，在2005年-2006年正式成为主流的数据格式，雅虎和谷歌就在那时候开始广泛地使用JSON格式。</p></blockquote><h3 id="json语法"><a href="#json语法" class="headerlink" title="json语法"></a>json语法</h3><blockquote><p>  该部分内容参考自<a href="https://www.sojson.com/json/json_syntax.html" target="_blank" rel="noopener">https://www.sojson.com/json/json_syntax.html</a></p><p>  版权所属：SOJSON（原创文章）</p><p>  原文地址：<a href="https://www.sojson.com/json/json_syntax.html" target="_blank" rel="noopener">https://www.sojson.com/json/json_syntax.html</a></p></blockquote><p><strong>json 语法规则</strong></p><ul><li><strong>数据在名称/值对中</strong>，也就是我们常说的键值对，用逗号分隔</li><li><strong>花括号{}保存对象</strong></li><li><strong>方括号[]保存数组</strong></li></ul><p><strong>JSON 数据</strong>的书写格式是：<code>{Key:Value}</code>、<code>{Key:Array}</code>。前面是键，中间是英文的“:”（冒号），然后是值。但是注意的是如果是字符串，严格来说都是要用英文双引号引起来的。例如：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"answer"</span>&#125;</span><br></pre></td></tr></table></figure><p>JSON数据的值可以是 <strong>数字（整数或浮点数）、字符串（在双引号中）、逻辑值（<code>true</code> 或 <code>false</code>）、数组（在方括号中）、对象（在花括号中）、<code>null</code></strong>。</p><p><strong>JSON对象</strong>在花括号中，对象可以包含多个名称/值对，如下代码所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"answer"</span>,</span><br><span class="line">    <span class="attr">"age"</span>: <span class="number">21</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>JSON数组</strong>在方括号（”[]”）中书写，数组可包含多个对象，如下“student”描述</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"student"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"answer"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"21"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"brian"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"20"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"joe"</span>,</span><br><span class="line">            <span class="attr">"age"</span>: <span class="string">"25"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，对象 “student” 是包含三个对象的数组。每个对象代表一条关于一个学生（姓名和年龄）的记录。</p><h3 id="Java解析转换JSON"><a href="#Java解析转换JSON" class="headerlink" title="Java解析转换JSON"></a>Java解析转换JSON</h3><blockquote><p>  将Java中的对象快速的转换为JSON格式的字符串。</p><p>  将JSON格式的字符串, 转换为Java的对象。</p></blockquote><p>Java官方未提供官方的json解析工具，json的解析借助第三方工具完成。常见的第三方工具有谷歌的<strong>Gson</strong>和阿里巴巴的<strong>fastjson</strong>。在使用前都要先导入jar包，可以从某hub上下载。</p><p><img src="https://i.loli.net/2020/10/24/OxXGZVTL7avnmEk.png" alt=""></p><h4 id="Gson"><a href="#Gson" class="headerlink" title="Gson"></a>Gson</h4><p><strong>将对象转换为JSON字符串</strong>，在需要转换JSON字符串的位置编写如下代码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="keyword">new</span> Gson().toJSON(要转换的对象);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/axH4XYOTv9MK8Nq.png" alt=""></p><p><strong>将JSON字符串转换为对象</strong>，在需要转换Java对象的位置，编写如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象 = <span class="keyword">new</span> Gson().fromJson(JSON字符串,对象类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/CXxaiUnwAqPYEOD.png" alt=""></p><h4 id="FastJson"><a href="#FastJson" class="headerlink" title="FastJson"></a>FastJson</h4><p><strong>将对象转换为JSON字符串</strong>，在需要转换JSON字符串的位置编写如下代码即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String json=JSON.toJSONString(要转换的对象);</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/lRdcx8KVgMz69yp.png" alt=""></p><p><strong>将JSON字符串转换为对象</strong>，在需要转换Java对象的位置, 编写如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类型 对象名=JSON.parseObject(JSON字符串, 类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">List&lt;类型&gt; list=JSON.parseArray(JSON字符串,类型<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/24/VE1laqAPfMgYvcG.png" alt=""></p><p><img src="https://i.loli.net/2020/10/24/eDRPWEik5fpCO2s.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;XML&quot;&gt;&lt;a href=&quot;#XML&quot; class=&quot;headerlink&quot; title=&quot;XML&quot;&gt;&lt;/a&gt;XML&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80/2885849?fromtitle=xml&amp;fromid=86251&amp;fr=aladdin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;XML&lt;/a&gt;全称可扩展标记语言（eXtensible Markup Language）。是一种用于标记电子文件使其具有结构性的标记语言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="XML" scheme="https://www.pengspace.top/tags/XML/"/>
    
      <category term="JSON" scheme="https://www.pengspace.top/tags/JSON/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程</title>
    <link href="https://www.pengspace.top/2020/10/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://www.pengspace.top/2020/10/24/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-10-24T08:23:00.000Z</published>
    <updated>2020-11-16T11:26:27.356Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><p>==多线程：栈空间独立，堆内存共享==</p><p>多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，一个进程可能包含了多个同时执行的线程。</p><a id="more"></a><h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ul><li><strong>进程</strong>：<ul><li>正在运行的应用程序：是指一个内存中运行的应用程序，<strong>每个进程都有一个独立的内存空间</strong>，即每个进程都有着自己的堆、栈等且是互不共享的。</li></ul></li><li><strong>线程</strong>：<ul><li>进程中的一个<strong>执行路径</strong>（一段程序从执行到结束的整个过程），共享一个内存空间，线程之间可以自由切换，并发执行，<font color=red>一个进程最少有一个线程</font></li><li>线程实际上是在进程的基础上进一步划分的，一个进程执行后，里面的若干执行路径又可以划分为若干个线程</li></ul></li></ul><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><ol><li><strong>分时调度</strong></li></ol><ul><li>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li></ul><ol start="2"><li><strong>抢占式调度</strong></li></ol><ul><li>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，<strong>Java使用的为抢占式调度</strong>。</li><li>CPU使用抢占式调度模式在多个线程间进行着高速的切换。对于CPU的一个核心而言，某个时刻，只能执行一个线程，而 CPU的在多个线程间切换速度相对我们的感觉很快，看上去就是在同一时刻运行。 其实，多线程程序并不能提高程序的运行速度，但能够提高程序运行效率，让CPU的使用率更高。</li></ul><h3 id="同步与异步-amp-并发与并行"><a href="#同步与异步-amp-并发与并行" class="headerlink" title="同步与异步&amp;并发与并行"></a>同步与异步&amp;并发与并行</h3><blockquote><p>  <strong>同步</strong>：排队执行，效率低但安全</p><p>  <strong>异步</strong>：同时执行，效率高但数据不安全</p></blockquote><blockquote><p>  <strong>并发</strong>：指两个或多个事件在<font color=red>同一个时间段内</font>发生。</p><p>  <strong>并行</strong>：指两个或多个事件在<font color=red>同一时刻</font>发生（同时发生）。</p></blockquote><h2 id="多线程的实现方式"><a href="#多线程的实现方式" class="headerlink" title="多线程的实现方式"></a>多线程的实现方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>步骤：</p><ol><li><p>创建一个自定义类并继承Thread类；</p></li><li><p>重写run()方法，创建新的执行任务（通过thread对象的start()方法启动任务，一般不直接调用run()方法）</p></li><li><p>创建自定义类对象实例，调用start()，让线程执行</p></li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//run()方法就是线程要执行的任务的方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyThread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ThreadTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();<span class="comment">//启动线程任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MainThread"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>可以看到顺序并不统一，两个线程在交替执行而且各自所占的时间不完全相同，这是线程在抢时间片，谁先抢到谁就执行。</p><p><img src="https://i.loli.net/2020/10/20/t4hNj7XJWOHBuvr.png" alt="image-20201020195837780"></p><blockquote><p>  <strong>时序图：</strong></p><p>  <img src="https://i.loli.net/2020/10/20/ZeTkrMvRzSK8t3F.png" alt="image-20201020202118525"></p><p>  运行过程中子线程任务中调用的方法都在子线程中运行</p></blockquote><blockquote><p>  在上述代码中。如果Thread对象只需要调用1次，也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"MainThread"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>Runnable接口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li>创建一个自定义类实现Runnable接口，并实现其抽象方法run()，编写线程要执行的任务</li><li>创建自定义类对象实例</li><li>用Thread类创建一个对象实例，并将第二步中的自定义类对象实例作为参数传给其构造函数</li><li>调用Thread类实例的start()方法执行线程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RunnableTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MainRunnable"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//运行效果应该跟上面继承Thread类实现多线程效果差不多。</span></span><br></pre></td></tr></table></figure><blockquote><p>  上述代码也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyRunnable"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"MainRunnable"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>==上面两种方式的比较==</strong></p><p>  <strong>继承Thread类</strong>：</p><ul><li><p>优点：直接使用Thread类中的方法，代码简单</p></li><li><p>弊端：如果已有父类，不可用（Java不可多继承)</p></li><li><p><em>实现Runnable接口（更常用）*</em>:</p><p>与继承Threadl类相比具有以下优势：</p></li><li><p>通过创建任务，给线程分配任务实现多线程，更适合多个线程同时执行相同任务的情况</p></li><li><p>可以避免单继承带来的局限性（Java允许实现多个接口，但不能继承多个父类）</p></li><li><p>任务和线程分离，提高程序健壮性</p></li><li><p>后续学到的线程池技术，它只接收Runnable类型任务，不接收Thread类型线程</p></li></ul></blockquote><blockquote><p>  <strong>==Thread类API==</strong></p><ol><li><p>常用构造方法</p><table><thead><tr><th>构造器</th><th>描述</th></tr></thead><tbody><tr><td><code>Thread()</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(Runnable target, String name)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr><tr><td><code>Thread(String name)</code></td><td>分配新的 <code>Thread</code>对象。</td></tr></tbody></table></li><li><p>常用其他方法</p><table><thead><tr><th align="left">变量和类型</th><th align="left">方法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>long</code></td><td align="left"><code>getId()</code></td><td align="left">返回此Thread的标识符。</td></tr><tr><td align="left"><code>String</code></td><td align="left"><code>getName()</code></td><td align="left">返回此线程的名称。</td></tr><tr><td align="left"><code>int</code></td><td align="left"><code>getPriority()</code></td><td align="left">返回此线程的优先级。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>setPriority(int newPriority)</code></td><td align="left">更改此线程的优先级。</td></tr><tr><td align="left"><code>Thread.State</code></td><td align="left"><code>getState()</code></td><td align="left">返回此线程的状态。</td></tr><tr><td align="left"><code>static Thread</code></td><td align="left"><code>currentThread()</code></td><td align="left">返回对当前正在执行的线程对象的引用。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>start()</code></td><td align="left">导致此线程开始执行; Java虚拟机调用此线程的<code>run</code>方法。</td></tr><tr><td align="left"><code>static void</code></td><td align="left"><code>sleep(long millis)</code></td><td align="left">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数，具体取决于系统计时器和调度程序的精度和准确性。</td></tr><tr><td align="left"><code>static void</code></td><td align="left"><code>sleep(long millis, int nanos)</code></td><td align="left">导致当前正在执行的线程休眠（暂时停止执行）指定的毫秒数加上指定的纳秒数，具体取决于系统定时器和调度程序的精度和准确性。</td></tr><tr><td align="left"><code>void</code></td><td align="left"><code>setDaemon(boolean on)</code></td><td align="left">将此线程标记为 daemon线程或用户线程。</td></tr></tbody></table></li><li><p>特殊字段：控制线程抢到时间片的几率</p><table><thead><tr><th>变量和类型</th><th>字段</th><th>描述</th></tr></thead><tbody><tr><td><code>static int</code></td><td><code>MAX_PRIORITY</code></td><td>线程可以拥有的最大优先级。</td></tr><tr><td><code>static int</code></td><td><code>MIN_PRIORITY</code></td><td>线程可以拥有的最低优先级。</td></tr><tr><td><code>static int</code></td><td><code>NORM_PRIORITY</code></td><td>分配给线程的默认优先级。</td></tr></tbody></table><p>其他的可以参考Java的API手册</p></li></ol></blockquote><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>Callable接口代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>步骤：</p><ol><li><p>创建一个自定义类实现Callable接口，并实现其抽象方法call()，编写线程要执行的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XXX</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; call() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建FutureTask对象 , 并传入第一步编写的Callable类对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FutureTask&lt;Integer&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br></pre></td></tr></table></figure></li><li><p>通过Thread，启动线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(future).start();</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyCallable.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyCallable:"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//CallableTest.java</span></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCallable&lt;String&gt; mc = <span class="keyword">new</span> MyCallable&lt;&gt; ();</span><br><span class="line">        FutureTask&lt;String&gt; future = <span class="keyword">new</span> FutureTask&lt;&gt; (mc);</span><br><span class="line">        <span class="keyword">new</span> Thread(future).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>  上述代码也可以通过使用匿名内部类的方式进行简化：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableTest</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"MyCallable:"</span> + i);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)).start();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           System.out.println(<span class="string">"main"</span> + i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>  <strong>Runnable 与 Callable比较</strong></p><ul><li><p>相同点：</p><ul><li>都是接口</li><li>都可以编写多线程程序</li><li>都采用Thread.start()启动线程</li></ul></li><li><p>不同点</p><ul><li>Runnable没有返回值；Callable可以返回执行结果</li><li>Callable接口的call()允许抛出异常；Runnable的run()不能抛出</li></ul><p>Callalble接口支持返回执行结果，需要调用FutureTask.get()得到，此方法会阻塞主进程的继续往下执<br>行，如果不调用不会阻塞。</p></li></ul></blockquote><h2 id="多线程的应用实例"><a href="#多线程的应用实例" class="headerlink" title="多线程的应用实例"></a>多线程的应用实例</h2><h3 id="设置和获取线程名称"><a href="#设置和获取线程名称" class="headerlink" title="设置和获取线程名称"></a>设置和获取线程名称</h3><p><code>currentThread()</code> 可以获取当前正在执行的线程对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//获取当前线程对象的名称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//GetThread.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName());<span class="comment">//获取当前线程对象的名称</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable(),<span class="string">"answer"</span>).start();<span class="comment">//给线程指定一个名称 (方法一)</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t.setName(<span class="string">"anotherWay"</span>);<span class="comment">//给线程指定一个名称 (方法二)</span></span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://i.loli.net/2020/10/20/DFz1sN5h2wUqyBG.png" alt="image-20201020213805266"></p><h3 id="线程休眠sleep"><a href="#线程休眠sleep" class="headerlink" title="线程休眠sleep"></a>线程休眠sleep</h3><p><code>sleep(long millis)</code>是Thread类的静态方法，类名直接调用即可，单位ms。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：每隔1秒打印一个数字。</p><p><img src="https://i.loli.net/2020/10/20/pIqfd5TD2waWtXo.gif" alt=""></p><blockquote><p>  <strong>线程阻塞</strong>：所有较耗时的操作都能称为阻塞。也叫耗时操作。</p></blockquote><h3 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h3><p>一个线程是一个独立的执行路径，它是否应该结束，<strong>由其自身决定</strong>。</p><p>因为线程执行过程会有很多资源需要使用或释放，如果干涉它的结束，很可能导致资源没能来得及释放，一直占用，从而产生无法回收的内存垃圾。</p><p>Java以前提供stop()方法可以结束线程，现在已经过时(不再使用)。现在出了新的方法，<strong>给线程打中断标记</strong>（<code>interrupt</code>）来控制它的结束。</p><p>具体方法就是 调用<code>interrupt()</code>方法，子线程执行时捕获中断异常，并在catch块中，添加处理释放资源的代码。</p><p>如下代码所示：main线程执行完后不管子线程是否执行完都中断掉它</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务：打印1-10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;<span class="comment">//发现中断标记，进入catch块中，进行释放资源处理</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"：发现中断标记，我自杀了"</span>);</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//为了演示，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InterruptTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t1.setName(<span class="string">"myThread"</span>);</span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//main线程 打印1-5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">        t1.interrupt(); <span class="comment">//给线程t1添加中断标记</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2020/10/20/7vUXIGJWRbj4tTH.png" alt=""></p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>线程分为<strong>守护线程</strong>和<strong>用户线程</strong></p><ul><li><strong>用户线程</strong>：当一个进程不包含任何存活的用户线程时，进行结束。</li><li><strong>守护线程</strong>：守护用户线程，当最后一个用户线程结束时，所有守护线程自动死亡。</li></ul><p>直接创建的都是用户线程，</p><p>设置线程为守护线程：在启动之前设置 ，语法为：<code>线程对象.setDaemon(true);</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyRunnable.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务：打印1-10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                <span class="keyword">return</span>;<span class="comment">//为了演示，直接结束</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//InterruptTest.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        t1.setName(<span class="string">"myThread"</span>);</span><br><span class="line">        t1.setDaemon(<span class="keyword">true</span>);<span class="comment">//设置t1为守护线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//main线程 打印1-5</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"："</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/20/YDGyOnPhEL3eXNz.png" alt=""></p><h3 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h3><h4 id="问题引入"><a href="#问题引入" class="headerlink" title="问题引入"></a>问题引入</h4><p>我们先来看个例子：三个窗口（线程）同时卖5张票。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Runnable run = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(run).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">5</span>;  <span class="comment">//票数</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//卖票</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"正在卖票"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"出票成功,余票："</span>+count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果部分截图：</p><p><img src="https://i.loli.net/2020/10/21/g31kZ6c4FnywoqQ.png" alt=""></p><p>我们看到余票出现了负数，显然这是不合理的，这就是线程不安全导致的。出现这种情况的原因：线程争抢，导致线程不安全。 多线程在进行同一卖票任务时，没人干涉，各个窗口疯狂买票，最终导致卖的票超出总票数，余票出现负数。</p><p><font color=red><strong>线程不安全的原因：</strong></font></p><p>当多线程并发访问<strong>临界资源</strong>时，如果破坏<strong>原子操作</strong>，可能会造成数据不一致。</p><ul><li>临界资源：共享资源（同一对象），一次仅允许一个线程使用，才可保证其正确性。</li><li>原子操作：不可分割的多步操作，被视作一个整体，其顺序和步骤不可打乱或缺省。</li></ul><p>多个线程争抢同一个数据，使得数据在判断和使用时出现不一致的情况。那如何解决呢？</p><p>解决方法：保证一段数据同时只能被一个线程使用（排队使用），也就是线程同步，给线程加锁（synchronized）</p><p>我们有以下三种方法解决线程不安全的问题：同步代码块、同步方法、显示锁</p><h4 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h4><p>使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块</p><p>多个同步代码块如果使用<strong>相同的锁对象</strong>, 那么他们就是同步的</p><p>语法格式：<code>synchronized(锁对象) {}</code></p><p>任何对象都可以作为<strong>锁对象</strong>存在。</p><p>还以上面卖票的代码为例，给卖票的线程加锁</p><p><img src="https://i.loli.net/2020/10/21/fcxmMsCzRarQS8P.png" alt="image-20201021174518339"></p><h4 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h4><p>以方法为单位进行加锁。把synchronized关键字修饰在方法中。</p><p>还以上面卖票的代码为例，写一个synchronized修饰的方法sale()执行卖票任务，</p><p><img src="https://i.loli.net/2020/10/21/SoCgaNvHtdc6GwX.png" alt=""></p><h4 id="显式锁"><a href="#显式锁" class="headerlink" title="显式锁"></a>显式锁</h4><blockquote><p>  上面三种方法中，同步代码块和同步代码都是隐式锁</p></blockquote><p><code>Lock l = new ReentrantLock()</code>：自己创建一把锁</p><p><code>lock()</code>：加锁             <code>unlock()</code>：解锁</p><p>还以上面卖票的代码为例</p><p><img src="https://i.loli.net/2020/10/21/MdGWmJql95V1uEX.png" alt=""></p><blockquote><p>  <strong>显式锁和隐式锁的区别：</strong></p><table><thead><tr><th>区别</th><th>synchronized</th><th>lock</th></tr></thead><tbody><tr><td>原始构成</td><td>Java关键字，由JVM维护，是JVM层面的锁</td><td>JDK1.5之后的类，使用lock是在调用API，是API层面的锁</td></tr><tr><td>使用方式</td><td>隐式锁，不需要手动获取和释放锁，只需要写synchronized，不用进行其他操作</td><td>显式锁，需要手动获取和释放锁，如果没有释放锁，可能会出现死锁</td></tr><tr><td>等待中断</td><td>不会中断，除非抛出异常或正常运行完成</td><td>可以中断，1：调用设置超时方法tryLock(long timeout ,timeUnit unit)；2：调用lockInterruptibly()放到代码块中，然后调用interrupt()方法可以中断</td></tr><tr><td>加锁公平</td><td><strong>非公平锁</strong></td><td>可以是<strong>公平锁</strong>也可以是<strong>非公平锁</strong>，默认是非公平锁。可以在其构造方法传入Boolean值，true公平锁，false非公平锁</td></tr><tr><td>绑定多个条件</td><td>没有。不能精确唤醒线程，要么随机唤醒一个线程，要么唤醒所有等待线程</td><td>用来实现分组唤醒需要唤醒的线程，可以精确唤醒线程</td></tr><tr><td>性能</td><td>JDK1.5时性能较低，JDK1.6时性能优化，与lock相较无异</td><td>JDK1.5时性能更高，JDK1.6时synchronized优化赶上lock</td></tr><tr><td>加锁方式</td><td>线程获取独占锁（CPU悲观锁机制），只能依靠阻塞等待线程释放锁。在CPU转换线程阻塞时会引起线程上下文切换，当竞争锁的线程过多时，会引起CPU频繁上下文切换导致效率低下</td><td>使用乐观锁机制（CAS操作 Computer and Swap），假设不会发生冲突，一旦发生冲突失败就重试，直到成功为止。</td></tr></tbody></table><p>  <strong>公平锁</strong>：先来先得，排队执行</p><p>  <strong>非公平锁</strong>：抢占式的，谁抢到是谁的</p></blockquote><blockquote><p>  更多关于线程安全的问题可以看下面这篇文章</p><p>  <a href="https://mp.weixin.qq.com/s/WDeewsvWUEBIuabvVVhweA" target="_blank" rel="noopener">如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏)</a></p></blockquote><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a><font color=red>线程死锁</font></h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>当两个或两个以上的线程在执行过程中，因为争夺资源而造成的一种相互等待的状态，由于存在一种环路的锁依赖关系而永远地等待下去，如果没有外部干涉，他们将永远等待下去，此时的这个状态称之为死锁。</p><p>多个线程相互占用对方的资源的锁，而又相互等对方释放锁，此时若无外力干预，这些线程则一直处于阻塞的假死状态，形成死锁。</p><p>举个例子，如下图所示，在线程A持有锁L并想获得锁M的同时，线程B持有锁M并尝试获得锁L，那么这两个线程将永远地等待下去，这种情况就是死锁形式。</p><p><img src="https://i.loli.net/2020/10/21/oC9p8qRF7h1d4DS.png" alt=""></p><p><strong>死锁产生的条件：</strong></p><ul><li><strong>互斥条件</strong>：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用完释放。</li><li><strong>请求和保持条件</strong>：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li><strong>不剥夺条件</strong>：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li><li><strong>环路等待条件</strong>：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{A，B，C，···，Z} 中的A正在等待一个B占用的资源；B正在等待C占用的资源，……，Z正在等待已被A占用的资源。</li></ul><h4 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h4><ol><li><p>按顺序加锁：如果每个线程都按同一个的加锁顺序这样就不会出现死锁。</p></li><li><p>给锁加时限：每个线程获取锁的时候加上个时限，如果超过某个时间就放弃锁。</p></li><li><p>死锁检测：按线程间获取锁的关系检测线程间是否发生死锁，如果发生死锁就执行一定的策略，如终断线程或回滚操作等。</p></li></ol><blockquote><p>  更多关于线程死锁的问题可以看下面这篇文章，以上内容也是来自这篇文章：</p><p>  <a href="https://mp.weixin.qq.com/s/kvvJ9_xKaOMobaX7PZ5VCQ" target="_blank" rel="noopener">多线程 死锁详解</a></p></blockquote><h3 id="多线程通信"><a href="#多线程通信" class="headerlink" title="多线程通信"></a>多线程通信</h3><p>Object方法中提供了一些线程间相互通信的方法</p><table><thead><tr><th>变量和类型</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void</code></td><td><code>notify()</code></td><td>唤醒正在此对象监视器上等待的单个线程。</td></tr><tr><td><code>void</code></td><td><code>notifyAll()</code></td><td>唤醒等待此对象监视器的所有线程。</td></tr><tr><td><code>void</code></td><td><code>wait()</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 。</td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis)</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 ，或者直到经过一定量的实时。</td></tr><tr><td><code>void</code></td><td><code>wait(long timeoutMillis,  int nanos)</code></td><td>导致当前线程等待它被唤醒，通常是 通知或 中断 ，或者直到经过一定量的实时。</td></tr></tbody></table><p><strong>什么时候需要通信</strong></p><p>多个线程并发执行时, 在默认情况下CPU是随机切换线程的，如果我们希望他们有规律的执行, 就可以使用通信。</p><h4 id="生产者与消费者"><a href="#生产者与消费者" class="headerlink" title="生产者与消费者"></a>生产者与消费者</h4><blockquote><p>  看下面代码，有Cooker类，Waiter类，Food类</p><p>  厨师cooker为生产者线程，服务员waiter为消费者线程，食物food为生产与消费的物品；</p><p>  假设目前只有一个厨师，一个服务员，一个盘子。理想状态是：厨师生产一份饭菜，服务员端走一份，且饭菜的属性未发生错乱；</p><p>  厨师可以制作两种口味的饭菜，制作100次；</p><p>  服务员可以端走饭菜100次；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Food();</span><br><span class="line">        <span class="keyword">new</span> Cooker(f).start();</span><br><span class="line">        <span class="keyword">new</span> Waiter(f).start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Cooker</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;<span class="comment">//生产者线程</span></span><br><span class="line">        <span class="keyword">private</span> Food f;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Cooker</span><span class="params">(Food f)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.f = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//生产100个菜</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                    f.setNameAndTaste(<span class="string">"菜1"</span>,<span class="string">"味道1"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f.setNameAndTaste(<span class="string">"菜2"</span>,<span class="string">"味道2"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Waiter</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;  <span class="comment">//消费者线程</span></span><br><span class="line">        <span class="keyword">private</span> Food f;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Waiter</span><span class="params">(Food f)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">this</span>.f = f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                f.get();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String taste;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNameAndTaste</span><span class="params">(String name,String taste)</span></span>&#123;<span class="comment">//生产</span></span><br><span class="line">            <span class="keyword">this</span>.name = name;<span class="comment">//先设定名称</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);<span class="comment">//为使线效果明显，中间休眠一段时间</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.taste = taste;<span class="comment">//休眠后设定味道</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123; <span class="comment">//消费</span></span><br><span class="line">            System.out.println(<span class="string">"服务员端走的菜名称是："</span> + name + <span class="string">"，味道："</span> + taste);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/21/CAYzM4DNI36Pg7V.png" alt=""></p><p>原因：我们在设定菜名和味道的<code>setNameAndTaste</code>方法中,先设定名称，然后休眠一段时间，再设定的味道，中间休眠的那段时间很可能发生时间片丢失，使得菜属性产生混乱。</p><p><strong>解决方式一</strong>：</p><p>为了防止在生产过程中setNameAndTaste出现时间片切换，可以用synchronized修饰此方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setNameAndTaste</span><span class="params">(String name,String taste)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;  <span class="comment">// 消费</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="https://i.loli.net/2020/10/21/HhAMOSIL9Ymn3lE.png" alt=""></p><p>可以看出，依然不符合实际情况，这是因为synchronized只是确保了方法内部不会发生线程切换，但并不能保证生产一个消费一个的逻辑关系</p><p><strong>解决方式二</strong>：</p><p>在解决方案一的基础上，进行线程之间的通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;<span class="comment">//默认为true，表示可以做饭</span></span><br></pre></td></tr></table></figure><p>厨师做完饭后喊醒服务员，自己睡着。服务员送完饭后喊醒厨师，自己睡着；将Food类左如下修改</p><p><img src="https://i.loli.net/2020/10/21/flHwKZ9nbGrg8mT.png" alt=""></p><p>运行结果，做一道菜，端走一道。</p><p><img src="https://i.loli.net/2020/10/21/m7pIQqgSCZz59HG.png" alt="image-20201021210352200"></p><h2 id="线程的六种状态"><a href="#线程的六种状态" class="headerlink" title="线程的六种状态"></a>线程的六种状态</h2><p>Enum Thread.State描述了六种线程的状态，如下表所示</p><table><thead><tr><th>Enum Constant</th><th>描述</th></tr></thead><tbody><tr><td><code>BLOCKED</code></td><td>线程的线程状态被阻塞等待监视器锁定。(阻塞)</td></tr><tr><td><code>NEW</code></td><td>尚未启动的线程的线程状态。(创建)</td></tr><tr><td><code>RUNNABLE</code></td><td>可运行线程的线程状态。（就绪和运行）</td></tr><tr><td><code>TERMINATED</code></td><td>终止线程的线程状态。（消亡）</td></tr><tr><td><code>TIMED_WAITING</code></td><td>具有指定等待时间的等待线程的线程状态。(有限期等待)</td></tr><tr><td><code>WAITING</code></td><td>等待线程的线程状态。(无限期等待)</td></tr></tbody></table><h2 id="线程池Executors"><a href="#线程池Executors" class="headerlink" title="线程池Executors"></a>线程池Executors</h2><blockquote><p>  普通线程的执行流程:</p><p>  创建线程 → 创建任务 → 执行任务 → 关闭线程</p><p>  如果并发的线程数量很多，并且每个线程都是执行一个时间很短的任务就结束了，这样频繁创建线程就会大大降低 系统的效率，因为频繁创建线程和销毁线程需要时间。 线程池就是一个容纳多个线程的容器，池中的线程可以反复使用，省去了频繁创建和销毁线程对象的操作，节省了大量的时间和资源。</p></blockquote><p>线程池的好处</p><ul><li>降低资源消耗。</li><li>提高响应速度。</li><li>提高线程的可管理性。</li></ul><p>Java中有四种线程池(ExecutorService)：缓存线程池、定长线程池、单线程线程池、周期性任务定长线程池</p><h3 id="缓存线程池"><a href="#缓存线程池" class="headerlink" title="缓存线程池"></a>缓存线程池</h3><p>长度无限制</p><p>执行流程:</p><ol><li><p>判断线程池是否存在空闲线程</p></li><li><p>存在则使用</p></li><li><p>不存在,则创建线程 并放入线程池, 然后使用</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newCachedThreadPool(); <span class="comment">//获取缓存线程池对象</span></span><br><span class="line"><span class="comment">//向线程池中 加入 新的任务</span></span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="定长线程池"><a href="#定长线程池" class="headerlink" title="定长线程池"></a>定长线程池</h3><p>长度是指定的数值</p><p>步骤：</p><ol><li>判断线程池是否存在空闲线程</li><li>存在则使用</li><li>不存在空闲线程，线程池未满的情况下,则创建线程 并放入线程池, 然后使用</li><li>不存在空闲线程，且线程池已满的情况下,则等待线程池存在空闲线程</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="单线程线程池"><a href="#单线程线程池" class="headerlink" title="单线程线程池"></a>单线程线程池</h3><p>步骤：</p><ol><li>判断线程池的那个线程是否空闲</li><li>空闲则使用</li><li>不空闲则等待池中的单个线程空闲后使用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">service.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//线程任务代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="周期性任务定长线程池"><a href="#周期性任务定长线程池" class="headerlink" title="周期性任务定长线程池"></a>周期性任务定长线程池</h3><p>步骤：</p><ol><li>判断线程池是否存在空闲线程</li><li>存在则使用</li><li>不存在空闲线程，且线程池未满的情况下，则创建线程，并放入线程池后使用</li><li>不存在空闲线程，且线程池已满的情况下，则等待线程池存在空闲线程</li></ol><p>周期性任务执行时：定时执行, 当某个时机触发时, 自动执行某任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService service = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定时执行</span></span><br><span class="line"><span class="comment">* 参数1. runnable类型的任务</span></span><br><span class="line"><span class="comment">* 参数2. 时长数字   5 </span></span><br><span class="line"><span class="comment">* 参数3. 时长数字的单位 TimeUnit.SECONDS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">service.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">5</span>,TimeUnit.SECONDS);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 周期执行</span></span><br><span class="line"><span class="comment">* 参数1. runnable类型的任务</span></span><br><span class="line"><span class="comment">* 参数2. 时长数字(延迟执行的时长)5</span></span><br><span class="line"><span class="comment">* 参数3. 周期时长(每次执行的间隔时间) 2</span></span><br><span class="line"><span class="comment">* 参数4. 时长数字的单位  TimeUnit.SECONDS</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">service.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程任务代码</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;,<span class="number">5</span>,<span class="number">2</span>,TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多线程概述&quot;&gt;&lt;a href=&quot;#多线程概述&quot; class=&quot;headerlink&quot; title=&quot;多线程概述&quot;&gt;&lt;/a&gt;多线程概述&lt;/h2&gt;&lt;p&gt;==多线程：栈空间独立，堆内存共享==&lt;/p&gt;
&lt;p&gt;多线程是实现并发机制的一种有效手段。进程和线程一样，都是实现并发的一个基本单位。线程是比进程更小的执行单位，线程是在进程的基础上进行的进一步划分。所谓多线程是指一个进程在执行过程中可以产生多个线程，这些线程可以同时存在、同时运行，一个进程可能包含了多个同时执行的线程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="多线程" scheme="https://www.pengspace.top/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="https://www.pengspace.top/2020/10/24/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>https://www.pengspace.top/2020/10/24/Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-10-24T08:21:15.000Z</published>
    <updated>2020-11-16T11:27:08.566Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><a id="more"></a><blockquote><p>  <strong>注意：</strong></p><p>  在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><p>  <strong>作用：</strong></p><ol><li>提高代码复用率</li><li>泛型中的类型在使用时指定，不需要强制类型转换（类型安全，编译器会检查类型）</li></ol></blockquote><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(T data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassName&lt;String&gt; val1 = <span class="keyword">new</span> ClassName&lt;&gt; ();     <span class="comment">//在使用时指定为具体的类型</span></span><br><span class="line">        val1.setData(<span class="string">""</span>);</span><br><span class="line">        ClassName&lt;Integer&gt; val2 = <span class="keyword">new</span> ClassName&lt;&gt; ();</span><br><span class="line">        val2.setData(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line"><span class="function">T <span class="title">getData</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现接口时，可以选择指定泛型类型，也可以选择不指定， 如下：</span></span><br><span class="line"><span class="comment">//指定类型：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span> <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String text;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不指定类型：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interface1</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">IntercaceName</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T 方法名(T a, T b) &#123;&#125;<span class="comment">//T只在方法内有效</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print(<span class="string">"haha"</span>);</span><br><span class="line">        print(<span class="number">11212</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(T a)</span></span>&#123;<span class="comment">//方法内的泛型只在方法内有效</span></span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="限制泛型类型"><a href="#限制泛型类型" class="headerlink" title="限制泛型类型"></a>限制泛型类型</h3><p>在使用泛型时， 可以指定泛型的限定区域 ，</p><ul><li>例如： 必须是某某类的子类或 某某接口的实现类，格式：<br>  <code>&lt;T extends 类或接口1 &amp; 接口2&gt;</code></li></ul><p><img src="https://i.loli.net/2020/10/13/CjxYoEDT42qc8KR.png" alt="image-20201013115930582"></p><h3 id="泛型中的通配符"><a href="#泛型中的通配符" class="headerlink" title="泛型中的通配符"></a>泛型中的通配符</h3><p>类型通配符是使用<code>?</code>代替方法具体的类型实参。</p><ol><li><code>&lt;? extends Parent&gt;</code> 指定了泛型类型的上届</li><li><code>&lt;? super Child&gt;</code>  指定了泛型类型的下届</li><li><code>&lt;?&gt;</code> 指定了没有限制的泛型类型</li></ol><p><img src="https://i.loli.net/2020/10/13/J2DuWzcF4KIa5tl.png" alt=""></p><blockquote><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>  如果需要 ，我们可以指定多个泛型，中间用 <code>,</code>隔开即可</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>&lt;<span class="title">T</span>,<span class="title">E</span>,<span class="title">A</span>,<span class="title">B</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> T data1;</span><br><span class="line">   <span class="keyword">private</span> E data2;</span><br><span class="line"><span class="keyword">private</span> A data3;</span><br><span class="line">   <span class="keyword">private</span> B data4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java异常处理</title>
    <link href="https://www.pengspace.top/2020/10/11/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://www.pengspace.top/2020/10/11/Java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2020-10-11T06:24:00.000Z</published>
    <updated>2020-10-11T06:26:34.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是异常"><a href="#什么是异常" class="headerlink" title="什么是异常"></a>什么是异常</h2><p>异常是在程序中导致程序中断运行的一种指令流。</p><p>先来看如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算开始 ============="</span>) ;</span><br><span class="line">        System.out.println(i + <span class="string">"/"</span> + j + <span class="string">"="</span> + i / j);</span><br><span class="line">        System.out.println(<span class="string">"============= 计算结束 ============="</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">============= 计算开始 =============</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ArithmeticException: / by zero</span><br><span class="line">at ExceptionDemo01.main(ExceptionDemo01.java:<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>以上的代码在<code>System.out.println(i + &quot;/&quot; + j + &quot;=&quot; + i / j);</code>位置处产生了异常<code>ArithmeticException(算术异常)</code>，一旦产生异常之后，异常之后的语句将不再执行了，所以现在的程序并没有正确的执行完毕之后就退出了。</p><p>那么，为了保证程序出现异常之后仍然可以正确的执行完毕，所以要采用异常的处理机制。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>如果要想对异常进行处理，则必须采用标准的处理格式，处理格式语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 有可能发生异常的代码段</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 对象名<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 对象名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">// 异常的处理操作</span></span><br><span class="line">&#125; ...</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">// 异常的统一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将开头的代码用try-catch处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span> ;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算开始 ============="</span>) ;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(i+ <span class="string">"/"</span> + j + <span class="string">"="</span> + i /j);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(ArithmeticException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"除数不能为0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"============= 计算结束 ============="</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">============= 计算开始 =============</span><br><span class="line">除数不能为0</span><br><span class="line">============= 计算结束 =============</span><br></pre></td></tr></table></figure><h3 id="try-catch的处理流程"><a href="#try-catch的处理流程" class="headerlink" title="try+catch的处理流程"></a>try+catch的处理流程</h3><p>1、 一旦产生异常，则系统会自动产生一个异常类的实例化对象。</p><p>2、 那么，此时如果异常发生在try语句，则会自动找到匹配的catch语句执行，如果没有在try语句中，则会将异常抛出，抛给调用方法者</p><p>3、 所有的catch根据方法的参数匹配异常类的实例化对象，如果匹配成功，则表示由此catch进行处理。</p><p><img src="https://i.loli.net/2020/10/10/bVzw1mud4eif7ot.png" alt=""></p><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>在进行异常的处理之后，在异常的处理格式中还有一个finally语句，那么此语句将作为异常的统一出口，<span style="color:red">不管是否产生了异常，最终<strong>必然都要</strong>执行此段代码</span>。</p><blockquote><p>  finally例子1：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123; </span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.println(<span class="number">1</span>);</span><br><span class="line">           System.out.println(<span class="number">2</span>);</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.println(<span class="string">"finally代码块中的内容"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  运行测试结果：说明即使在try和catch中return，在准备返回值与跳出函数之间，仍然会执行finally中的语句</p><p>  <img src="https://i.loli.net/2020/10/10/x5eOw9uGgMRCEdZ.png" alt="image-20201010164546702"></p><p>  finally例子2：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       Person p = testFinally();</span><br><span class="line">       System.out.println(p.age);<span class="comment">//28</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title">testFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Person p = <span class="keyword">new</span> Person();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           p.age = <span class="number">18</span>;</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           p.age = <span class="number">28</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  finally例子3：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = testFinally();</span><br><span class="line">       System.out.println(a);<span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">testFinally</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> a;</span><br><span class="line">       &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">           a = <span class="number">20</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  注意例子2和例子3，我们 testFinally() 方法一个返回的是引用数据类型，一个返回的是基本数据类型。例子3中返回非引用数据类型时return 备份的就是数据10，所以运行结果是10，不过此时栈中a的数据还是被改成20了。而在例子2中，我们return备份的是引用类型对象 p 在堆中的地址，存放在堆中那个地址的age被改为了28，当我们return 通过地址去找age时，就是会返回28。</p></blockquote><h3 id="异常处理真实场景举例"><a href="#异常处理真实场景举例" class="headerlink" title="异常处理真实场景举例"></a>异常处理真实场景举例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.InputMismatchException;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = menu();</span><br><span class="line">        System.out.println(<span class="string">"您选择的序号是"</span> + num);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请根据提示，选择功能序号："</span>);</span><br><span class="line">        System.out.println(<span class="string">"0.退出\n1.增\n2.删\n3.改"</span>);</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            num = input.nextInt();</span><br><span class="line">            <span class="keyword">if</span> (num&lt;<span class="number">0</span> || num&gt;<span class="number">3</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"输入的序号必须是：0/1/2/3"</span>);</span><br><span class="line">                <span class="keyword">return</span> menu();<span class="comment">//如果数字范围超过预期，递归重新调用此函数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException e)&#123;</span><br><span class="line">            System.out.println(<span class="string">"输入必须是数字"</span>);</span><br><span class="line">            <span class="keyword">return</span> menu();  <span class="comment">//如果输入非数字，递归重新调用此函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果测试：</p><p><img src="https://i.loli.net/2020/10/10/lKxIRXjcQ4SzuGh.png" alt="image-20201010161246734"></p><h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p>异常指的是Exception ， Exception类， 在Java中存在一个父类Throwable（可能的抛出）</p><p>Throwable存在两个子类：</p><ol><li>Error：表示的是错误，是JVM发出的错误操作,只能尽量避免，无法用代码处理。</li><li>Exception：一般表示所有程序中的错误，所以一般在程序中将进行try…catch的处理。</li></ol><p><img src="https://i.loli.net/2020/10/10/5WiUkG6aMdAOwYo.png" alt=""></p><blockquote><p>  多异常捕获的注意点：</p><ol><li><p>捕获更粗的异常不能放在捕获更细的异常之前。</p></li><li><p>如果为了方便，则可以将所有的异常都使用Exception进行捕获。</p><p>特殊的多异常捕获写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(异常类型<span class="number">1</span> |异常类型<span class="number">2</span> 对象名)&#123;</span><br><span class="line"><span class="comment">//表示此块用于处理异常类型1 和 异常类型2 的异常信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">            System.out.println(<span class="string">"请输入一个数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> x = input.nextInt();</span><br><span class="line">            System.out.println(<span class="string">"请再输入一个数字："</span>);</span><br><span class="line">            <span class="keyword">int</span> y = input.nextInt();</span><br><span class="line">            System.out.println(x/y);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InputMismatchException | ArithmeticException e) &#123;<span class="comment">//格式一</span></span><br><span class="line">            System.out.println(<span class="string">"输入错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         catch(RuntimeException e（或Exception e）)&#123;//扩大异常的形态范围来捕获 ，格式二</span></span><br><span class="line"><span class="comment">         System.out.println("输入错误");</span></span><br><span class="line"><span class="comment">         &#125; </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"程序执行完毕，正常结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></blockquote><h2 id="throws和throw关键字"><a href="#throws和throw关键字" class="headerlink" title="throws和throw关键字"></a>throws和throw关键字</h2><p>###throws</p><p>在程序中异常的基本处理已经掌握了，但是随异常一起的还有一个称为throws关键字，此关键字主要在方法的声明上使用，表示方法中不处理异常，而交给调用处处理。格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值 方法名称()<span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是因为传入的参数导致异常的发生，则可以通过throws抛出异常。通常是谁调用谁处理；</p><p>如下代码，只有传入参数出错，程序才会出错。</p><p><img src="https://i.loli.net/2020/10/10/XwxopzQTY85asmi.png" alt="image-20201010184935241"></p><p>我们可以用谁调用谁处理的策略，使用throws关键字来处理异常</p><p><img src="https://i.loli.net/2020/10/10/t2qHGzpw1Lgfr7s.png" alt="image-20201010191247867"></p><p>###throw</p><p>throw关键字表示在程序中人为的抛出一个异常，因为从异常处理机制来看，所有的异常一旦产生之后，实际上抛出的就是一个异常类的实例化对象，那么此对象也可以由throw直接抛出。（真正应用时，自己造异常还是比较麻烦的，之前加判断也可以出现相同的效果，所以用的较少）</p><p>代码： <code>throw new Exception(&quot;抛着玩的。&quot;);</code></p><p>看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.setAge(-<span class="number">1</span>);<span class="comment">//传入非法参数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="comment">//处理异常时机：谁调用谁处理</span></span><br><span class="line">        <span class="comment">//之前在设计此函数时，当用户输入了不合理时，自动设为1，</span></span><br><span class="line">        <span class="comment">//但用户在没有任何提示的情况下，输入和实际展示不一致，者本身就是异常</span></span><br><span class="line">        <span class="keyword">if</span> (age &lt; <span class="number">0</span> || age &gt; <span class="number">150</span>)&#123;</span><br><span class="line">            <span class="comment">//this.age = 1;</span></span><br><span class="line">            <span class="comment">//所以在发生异常时，需要告诉调用函数，发生了什么问题，而不是自己默默处理</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"年龄不合理"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://i.loli.net/2020/10/10/7ciUMJSWOrK5aE9.png" alt="image-20201010173420321"></p><h2 id="RuntimeExcepion与Exception的区别"><a href="#RuntimeExcepion与Exception的区别" class="headerlink" title="RuntimeExcepion与Exception的区别"></a>RuntimeExcepion与Exception的区别</h2><p>注意观察如下方法的源码：</p><p>Integer类：<code>public static int parseInt(String text)throws NumberFormatException</code></p><p>此方法抛出了异常， 但是使用时却不需要进行try…catch捕获处理，原因：</p><p>因为<code>NumberFormatException</code>并不是<code>Exception</code>的直接子类，而是<code>RuntimeException</code>的子类，<span style="color:red">只要是<code>RuntimeException</code>的子类，则表示程序在操作的时候可以不必使用try…catch进行处理，如果有异常发生，则由JVM进行处理。</span>当然，也可以通过try…catch处理。</p><h2 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h2><blockquote><p>  编写一个类， 继承Exception，并重写一参构造方法 即可完成自定义<strong>受检异常</strong>类型。受检异常必须明确的处理或者抛出，否则编译不通过</p><p>  编写一个类， 继承RuntimeExcepion，并重写一参构造方法 即可完成自定义<strong>运行时异常（非受检异常）</strong>类型。</p><p>  例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123; <span class="comment">// 继承Exception，表示一个自定义异常类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg) ; <span class="comment">// 调用Exception中有一个参数的构造</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>  自定义异常可以做很多事情， 例如：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyException</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line"><span class="keyword">super</span>(msg) ;</span><br><span class="line"><span class="comment">//在这里给维护人员发短信或邮件， 告知程序出现了BUG。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><h2 id="异常处理常见题目"><a href="#异常处理常见题目" class="headerlink" title="异常处理常见题目"></a>异常处理常见题目</h2><ol><li><p><strong>try-catch-finally 中哪个部分可以省略？</strong></p><p>答： catch和finally可以省略其中一个 ， catch和finally不能同时省略<br>注意:格式上允许省略catch块, 但是发生异常时就不会捕获异常了,我们在开发中也不会这样去写代码.</p></li><li><p><strong>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？</strong></p><p>答：finally中的代码会执行</p><blockquote><p>  详解：</p><p>  ​        执行流程：</p><ol><li><p>先计算返回值， 并将返回值存储起来， 等待返回</p></li><li><p>执行finally代码块</p></li><li><p>将之前存储的返回值， 返回出去；</p><p>​       注意：</p></li><li><p>返回值是在finally运算之前就确定了，并且缓存了，不管finally对该值做任何的改变，返回的值都不会改变</p></li><li><p>finally代码中不建议包含return，因为程序会在上述的流程中提前退出，也就是说返回的值不是try或catch中的值</p></li><li><p>如果在try或catch中停止了JVM，则finally不会执行。例如停电，或通过如下代码退出<br>JVM：<code>System.exit(0);</code> </p></li></ol></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是异常&quot;&gt;&lt;a href=&quot;#什么是异常&quot; class=&quot;headerlink&quot; title=&quot;什么是异常&quot;&gt;&lt;/a&gt;什么是异常&lt;/h2&gt;&lt;p&gt;异常是在程序中导致程序中断运行的一种指令流。&lt;/p&gt;
&lt;p&gt;先来看如下代码&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ExceptionDemo&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;============= 计算开始 =============&quot;&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(i + &lt;span class=&quot;string&quot;&gt;&quot;/&quot;&lt;/span&gt; + j + &lt;span class=&quot;string&quot;&gt;&quot;=&quot;&lt;/span&gt; + i / j);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;============= 计算结束 =============&quot;&lt;/span&gt;) ;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象高级</title>
    <link href="https://www.pengspace.top/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/"/>
    <id>https://www.pengspace.top/2020/10/06/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7/</id>
    <published>2020-10-06T06:51:51.000Z</published>
    <updated>2020-10-06T07:02:49.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>有时候我们需要这样一个类，它不需要被实例化，也不需要实现完整的方法，它只是用来被继承的，用来限制子类的一个“规范”。这样的类我们就可以将它定义为<strong>抽象类</strong>，抽象类内的方法可以定义为<strong>抽象方法</strong>。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">抽象类必须使用<span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span>声明</span></span><br><span class="line"><span class="class">一个抽象类中可以没有抽象方法。抽象方法必须写在抽象类或者接口中</span></span><br><span class="line"><span class="class">只声明而未实现的方法称为抽象方法（未实现是指：没有“</span>&#123;&#125;“方法体），抽象方法必须使用<span class="keyword">abstract</span>关键字声明。</span><br><span class="line">    </span><br><span class="line">格式：</span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> 类名</span>&#123;<span class="comment">//抽象类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">abstract</span> 返回值类型 方法名();<span class="comment">//抽象方法，只声明而未实现</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>在抽象类的使用中有几个原则： </p><ul><li>抽象类本身是不能直接进行实例化操作的，即：不能直接使用关键字new完成。</li><li>一个抽象类必须被子类所继承，被继承的子类（如果不是抽象类）则<strong>必须覆写(重写)</strong>抽象类中的全部抽象方法。</li></ul><p>常见的问题：</p><ul><li>抽象类不能使用final声明，因为final修饰的类是不能有子类的 ，而抽象类必须有子类才有意义。</li><li>抽象类能有构造方法，而且子类对象实例化的时候的流程与普通类的继承是一样的，都是要先调用父类中的构造方法（默 认是无参的），之后再调用子类自己的构造方法。</li></ul></blockquote><h3 id="抽象类与普通类的区别"><a href="#抽象类与普通类的区别" class="headerlink" title="抽象类与普通类的区别"></a>抽象类与普通类的区别</h3><ol><li>抽象类必须用public或protected修饰(如果为private修饰，那么子类则无法继承，也就无法实现其抽象方法）。默认缺省为 public </li><li>抽象类不可以使用new关键字创建对象，但是在子类创建对象时，抽象父类也会被JVM实例化。 </li><li>如果一个子类继承抽象类，那么必须实现其所有的抽象方法。如果有未实现的抽象方法，那么子类也必须定义为abstract类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;<span class="comment">//抽象类可以有构造方法</span></span><br><span class="line">        System.out.println(<span class="string">"抽象类的构造方法执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student.run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//可以定义Person对象变量，但它只能引用非抽象子类的对象</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">以上代码的运行结果为：</span><br><span class="line">抽象类的构造方法执行了</span><br><span class="line">Student.run</span><br><span class="line">说明抽象类可以有构造方法，在new一个抽象类的非子类对象时，JVM会默认先执行抽象</span><br><span class="line">类的构造方法。虽然我们不能new抽象类对象，但我们可以通过子类来操作抽象类中的资源。</span><br></pre></td></tr></table></figure><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="接口的概念及定义"><a href="#接口的概念及定义" class="headerlink" title="接口的概念及定义"></a>接口的概念及定义</h3><p>如果一个类中的全部方法都是抽象方法，全部属性都是全局常量，那么此时就可以将这个类定义成一个接 口。 定义格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> 接口名称</span>&#123; </span><br><span class="line">    全局常量 ; </span><br><span class="line">    抽象方法 ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>面向接口编程思想</strong></p><p>接口是定义（规范，约束）与实现（名实分离的原则）的分离的思想。 </p><p>优点：</p><ol><li>降低程序的耦合性 </li><li>易于程序的扩展 </li><li>有利于程序的维护</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">因为接口本身都是由全局常量和抽象方法组成，所以接口中的成员定义可以简写： </span><br><span class="line"><span class="number">1</span>.全局常量编写时，可以省略 <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> 关键字，例如： </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFO = <span class="string">"内容"</span> ; </span><br><span class="line">简写后：</span><br><span class="line">String INFO = <span class="string">"内容"</span> ; </span><br><span class="line"><span class="number">2</span>.抽象方法编写时，可以省略 <span class="keyword">public</span> <span class="keyword">abstract</span> 关键字，例如： </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>; </span><br><span class="line">简写后：</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure><h3 id="接口的实现-implements"><a href="#接口的实现-implements" class="headerlink" title="接口的实现 implements"></a>接口的实现 implements</h3><p>接口可以多实现，格式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码称为接口的实现。那么如果一个类即要实现接口，又要继承抽象类的话，则按照以下的格式编写 即可： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类 <span class="keyword">extends</span> 父类 <span class="keyword">implements</span> 父接口1,父接口2...</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">如果一个接口要想使用，必须依靠子类。 子类（如果不是抽象类的话）要实现接口中的所有抽象方法。</span></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//int  AGE = 10; //简写全局常量</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;     <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student();<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口的继承"><a href="#接口的继承" class="headerlink" title="接口的继承"></a>接口的继承</h3><p>接口因为都是抽象部分， 不存在具体的实现， 所以允许多继承,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承相当于扩展了接口的方法</p><h3 id="default方法"><a href="#default方法" class="headerlink" title="default方法"></a>default方法</h3><p>JDK1.8之后规定，在接口中，可以定义default方法。例如，把Person中的say()方法改为default方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>; <span class="comment">//简写抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(getName() + <span class="string">"say"</span>);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;<span class="comment">//实现接口</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Student(<span class="string">"Li Ming"</span>);<span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        p.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类可以不必覆写default方法。default方法的目的是，当我们需要给接口新增一个方法时，会涉及到修改全部子类。如果新增的是default方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><ol><li>抽象类要被子类继承，接口要被类实现。 </li><li>接口只能声明抽象方法，抽象类中可以声明抽象方法，也可以写非抽象方法。 </li><li>接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。 </li><li>抽象类使用继承来使用， 无法多继承。 接口使用实现来使用， 可以多实现 </li><li>抽象类中可以包含static方法 ，但是接口中不允许（静态方法不能被子类重写，因此接口中不能声明 静态方法） </li><li>接口不能有构造方法，但是抽象类可以有</li></ol><h2 id="Object-类"><a href="#Object-类" class="headerlink" title="Object 类"></a>Object 类</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>Object类是所有类的父类（基类），如果一个类没有明确的继承某一个具体的类，则将默认继承Object类。例如我们定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><p>其实它被使用时 是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Object</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>使用Object可以接收任意的引用数据类型</strong></p></blockquote><h3 id="Object类中常用的方法"><a href="#Object类中常用的方法" class="headerlink" title="Object类中常用的方法"></a>Object类中常用的方法</h3><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h4><p>建议重写Object中的toString方法。 此方法的作用：返回对象的字符串表示形式。</p><p>Object的toString方法， 返回对象的内存地址</p><p>类<code>Object</code>的<code>toString</code>方法返回一个字符串，该字符串由对象为实例的类的名称，字符“  <code>@</code> ”以及对象的哈希码的无符号十六进制表示形式组成。 换句话说，此方法返回一个等于值的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getClass().getName() + <span class="string">'@'</span> + Integer.toHexString(hashCode())</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;<span class="comment">//唯一标识符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age,<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// getter和setter方法省略，若想放入ide中测试，请自行添加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p.toString());  <span class="comment">//top.oop.demo09.Person@27f674d</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，如果不重写toString()，那打印的结果明显不能体现出我们所创建的对象的特征。所以建议在类中去重写toString()方法。</p><p>我们可以在Person中重写toString()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">"这是一个人，他叫"</span> + <span class="keyword">this</span>.name + <span class="string">","</span> + <span class="keyword">this</span>.age + <span class="string">"岁了"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h4><p>先来看一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java  看上面toString中的Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo09;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"Li Ming"</span>,<span class="number">18</span>);</span><br><span class="line">        System.out.println(p1 == p2); <span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出p1和p2的内容信息是完全一样的，但我们用 <code>==</code>比较时，会返回false。其实这也很好理解，每当我们new一个对象时就会在内存中开辟一块空间，也就是说p1和p2指向的是不同的内存地址，程序当然会判定他们不等。</p><p>但我们总需要对对象的信息进行比较，这时我们可以重写Object中的equals()方法来解决。不能直接用，直接用相当于还是在用<code>==</code> 比较。可以看Object中equals方法的源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议重写Object中的equals(Object obj)方法，此方法的作用：指示某个其他对象是否“等于”此对象。 </p><p>Object的equals方法：实现了对象上最具区别的可能等价关系; 也就是说，对于任何<strong>非空引用</strong>值x和y，当且仅当 x和y引用同一对象（ x == y具有值true ）时，此方法返回true 。 </p><blockquote><p>equals方法重写时的五个特性： </p><ul><li>自反性 ：对于任何非空的参考值x ， x.equals(x)应该返回true 。 </li><li>对称性 ：对于任何非空引用值x和y，x.equals(y)应该返回true当且仅当y.equals(x)回报true 。</li><li>传递性 ：对于任何非空引用值x ，y和z ，如果x.equals(y)返回true且y.equals(z)返回true ，那么 x.equals(z)应该返回true 。 </li><li>一致性 ：对于任何非空引用值x和y ，多次调用x.equals(y)始终返回true或始终返回false ，前提是未修改对象上的equals比较中使用的信息。 </li><li>非空性 ：对于任何非空的参考值x ， x.equals(null)应该返回false 。</li></ul></blockquote><p>equals一般根据我们的业务进行重写，举个例子,我们可以在Person类中重写equals方法，当唯一标识符id相等时，我们就认为这两个对象相等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)<span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span>)&#123;<span class="comment">//如果传入的对象为空，根据非空性，返回false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(o <span class="keyword">instanceof</span> Person)&#123;<span class="comment">//如果传入的对象与当前对像类型相同</span></span><br><span class="line">        Person p2 = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.id == p2.id)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码可以进行简化，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果传入的对象与当前对象内存地址一样，那一定是相同的</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> == obj)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果传入的对象为空或与当前对象类型不同，返回false</span></span><br><span class="line">    <span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Person p = (Person)obj;<span class="comment">//将obj对象强转为Person对象</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span>.id == p.id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>IDEA 快捷键 <code>Alt+Inster</code>可以自动重写equals方法和toString方法</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>在Java中，可以将一个类定义在另一个类里面或者一个方法里面，这样的类称为内部类。 </p><p>广泛意义上的内部类一般来说包括这四种：</p><ol><li>成员内部类</li><li>局部内部类 </li><li>匿名内部类 </li><li>静态内部类</li></ol><p>###成员内部类</p><p><strong>定义：</strong>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">200</span>;<span class="comment">//与外部类同名的变量</span></span><br><span class="line">System.out.println(<span class="string">"x="</span>+ x);<span class="comment">// x = 200.0</span></span><br><span class="line">            System.out.println(<span class="string">"x="</span> + Outer.<span class="keyword">this</span>.x); <span class="comment">//访问外部类的同名成员</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特点：</strong></p><p>成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="keyword">this</span>.成员变量</span><br><span class="line">外部类.<span class="keyword">this</span>.成员方法</span><br></pre></td></tr></table></figure><p><strong>成员内部类的使用：</strong></p><p>以上面定义的Outer类为例，来看如何让使用它里面的内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="number">100</span>);</span><br><span class="line">        Outer.Inner inner = outer.<span class="keyword">new</span> Inner();</span><br><span class="line">        inner.say();    </span><br><span class="line">        <span class="comment">/*结果：</span></span><br><span class="line"><span class="comment">         *x = 200.0</span></span><br><span class="line"><span class="comment">         *  x = 100.0</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###局部内部类 </p><p>局部内部类是<strong>定义在一个方法或者一个作用域里面的类</strong>，它和成员内部类的区别在于<strong>局部内部类的访问仅限</strong><br><strong>于方法内或者该作用域内</strong>。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> People <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123; <span class="comment">//局部内部类 定义在了getPerson方法内</span></span><br><span class="line"><span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意:</strong>局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及<br>static修饰符的。</p></blockquote><p>下面我们使用系统的某个API，来演示局部内部类的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.awt.Frame;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowEvent;</span><br><span class="line"><span class="keyword">import</span> java.awt.event.WindowListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Frame f = <span class="keyword">new</span> Frame(<span class="string">"登录"</span>);<span class="comment">//新建一个窗体</span></span><br><span class="line">        f.setVisible(<span class="keyword">true</span>);     <span class="comment">//设置是否显示</span></span><br><span class="line">        f.setSize(<span class="number">300</span>,<span class="number">200</span>); <span class="comment">//设置大小</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">MyWindowListener</span> <span class="keyword">implements</span> <span class="title">WindowListener</span> </span>&#123;  <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowOpened</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosing</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"关闭窗口"</span>);</span><br><span class="line">                System.exit(<span class="number">0</span>);<span class="comment">//关闭窗口操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowClosed</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowIconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeiconified</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowActivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">windowDeactivated</span><span class="params">(WindowEvent e)</span> </span>&#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        MyWindowListener l = <span class="keyword">new</span> MyWindowListener();</span><br><span class="line">        f.addWindowListener(l);      <span class="comment">//窗口监听器,需要传入一个实现WindowListener接口的类类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类由于没有名字，只能使用一次。创建格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类构造器（参数列表）|实现接口（）</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//匿名内部类的类体部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里我们看到使用匿名内部类我们必须要继承一个父类或者实现一个接口，当然也仅能只继承一个父类或者实现一个接口。同时它也是没有class关键字，这是因为匿名内部类是直接使用new来生成一个对象的引用。这个引用是隐式的。</p><blockquote><p>在使用匿名内部类的过程中，我们需要注意如下几点：</p><ol><li>使用匿名内部类时，我们必须是继承一个类或者实现一个接口，但是两者不可兼得，同时也只能<br> 继承一个类或者实现一个接口。</li><li>匿名内部类中是不能定义构造函数的。</li><li>匿名内部类中不能存在任何的静态成员变量和静态方法。</li><li><strong>匿名内部类为局部内部类</strong>，所以局部内部类的所有限制同样对匿名内部类生效。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li><li>和局部内部类一样，只能访问final型的局部变量，因为内部类会被单独编译成一个字节码文件，为了保障这个单独的文件中用到的内部类外部的变量与内部类外部的变量的值绝对一致，系统从规则上限制这个值不可以被更改。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//匿名内部类演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoNameInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>; <span class="comment">//jdk1.8以后可以省略final</span></span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        b = <span class="number">2</span>;<span class="comment">//明显b不是final型的</span></span><br><span class="line">        Person p = <span class="keyword">new</span> Person() &#123;   <span class="comment">//匿名内部类实现了Person接口</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"匿名内部类中的say方法"</span> + a);</span><br><span class="line">                <span class="comment">//System.out.println(b); //报错，局部内部类和匿名内部类不能访问非final型的局部变量</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ha(p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ha</span><span class="params">(Person p)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。</p><p>静态内部类是不需要依赖于外部类对象的，这点和类的静态成员属性有点类似，并且它<strong>不能使用外部类的非</strong><br><strong>static成员变量或者方法.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticInnerClass.y = <span class="number">100</span>;</span><br><span class="line">Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">        inner.say();<span class="comment">//100.0</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> y = <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> x,<span class="keyword">double</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.x = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; <span class="comment">//成员内部类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//System.out.println(x); //报错,静态内部类不能访问外部类的非静态成员和方法</span></span><br><span class="line">            System.out.println(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><p>在Java中有一个设计的原则“一切皆对象”，那么这样一来Java中的一些基本的数据类型，就完全不符合于这种设计思想，因为Java中的八种基本数据类型并不是引用数据类型，所以Java中为了解决这样的问题，引入了八种基本数据类型的包装类。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>int</td><td>Integer</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>long</td><td>Long</td></tr></tbody></table><p>以上的八种包装类，可以将基本数据类型按照类的形式进行操作。</p><p>以上的八种包装类也分为两种大的类型：</p><ul><li>Number：Integer、Short、Long、Double、Float、Byte都是Number的子类表示是一个<br>  数字。</li><li>Object：Character、Boolean都是Object的直接子类。</li></ul><h3 id="装箱和拆箱操作"><a href="#装箱和拆箱操作" class="headerlink" title="装箱和拆箱操作"></a>装箱和拆箱操作</h3><p>以下以<code>Integer</code>和<code>Float</code>为例进行操作</p><p>将一个<strong>基本数据类型变为包装类，那么这样的操作称为装箱操作</strong>。</p><p>将一个<strong>包装类变为一个基本数据类型，这样的操作称为拆箱操作</strong>，</p><p>因为所有的数值型的包装类都是Number的子类，Number的类中定义了如下的操作方法，以下的全部方法都<br>是进行拆箱的操作。</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>public byte byteValue()</td><td>用于Byte-&gt;byte</td></tr><tr><td>public abstract double doubleValue()</td><td>用于Double-&gt;double</td></tr><tr><td>public abstract float floatValue()</td><td>用于Float-&gt;float</td></tr><tr><td>public abstract int intValue()</td><td>用于Integer-&gt;int</td></tr><tr><td>public abstract long longValue()</td><td>用于Long-&gt;long</td></tr><tr><td>public short shortValue()</td><td>用于Short-&gt;short</td></tr></tbody></table><p><strong>装箱操作：</strong></p><p>在JDK1.4之前 ，如果要想装箱，直接使用各个包装类的构造方法即可，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = <span class="number">10</span> ; <span class="comment">// 基本数据类型</span></span><br><span class="line">Integer x = <span class="keyword">new</span> Integer(temp) ; <span class="comment">// 将基本数据类型变为包装类</span></span><br></pre></td></tr></table></figure><p>在JDK1.5，Java新增了自动装箱和自动拆箱，而且可以直接通过包装类进行四则运算和自增自减操作。例<br>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Float f = <span class="number">10.3f</span> ; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">float</span> x = f ; <span class="comment">// 自动拆箱</span></span><br><span class="line">System.out.println(f * f) ; <span class="comment">// 直接利用包装类完成</span></span><br><span class="line">System.out.println(x * x) ; <span class="comment">// 直接利用包装类完成</span></span><br></pre></td></tr></table></figure><h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>使用包装类还有一个很优秀的地方在于：可以将一个字符串变为指定的基本数据类型，此点一般在接收输入<br>数据上使用较多。<br>在<code>Integer</code>类中提供了以下的操作方法：<br>        <code>public static int parseInt(String s)</code> ：将String变为int型数据<br>在<code>Float</code>类中提供了以下的操作方法：<br>        <code>public static float parseFloat(String s)</code>：将String变为Float<br>在<code>Boolean</code> 类中提供了以下操作方法：<br>        <code>public static boolean parseBoolean(String s)</code>：将String变为boolean<br>……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String text = input.nextLine();</span><br><span class="line">        <span class="keyword">int</span> x = Integer.parseInt(text);     <span class="comment">//转为int类型,便于运算</span></span><br><span class="line">        System.out.println(x+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;有时候我们需要这样一个类，它不需要被实例化，也不需要实现完整的方法，它只是用来被继承的，用来限制子类的一个“规范”。这样的类我们就可以将它定义为&lt;strong&gt;抽象类&lt;/strong&gt;，抽象类内的方法可以定义为&lt;strong&gt;抽象方法&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象进阶</title>
    <link href="https://www.pengspace.top/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/"/>
    <id>https://www.pengspace.top/2020/10/04/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6/</id>
    <published>2020-10-04T06:12:29.000Z</published>
    <updated>2020-10-13T05:39:52.371Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>static关键字</strong></p><p>static表示“静态”的意思，可以用来修饰成员变量和成员方法。</p><p>static的主要作用在于创建独立于具体对象的域变量或者方法 </p><a id="more"></a><p>简单理解： </p><p>​        被static关键字修饰的方法或者变量不需要依赖于对象来进行访问，只要类被加载了，就可以通过类名去进行访问。 并且不会因为对象的多次创建而在内存中建立多份数据</p><p><strong>注意</strong></p><ol><li><span style="color:red">静态成员在类加载时加载并初始化。</span> </li><li><span style="color:red">无论一个类存在多少个对象 , 静态的属性, 永远在内存中只有一份(可以理解为所有对象公用 ) </span></li><li><span style="color:red">在访问时：静态不能访问非静态 , 非静态可以访问静态 ! 静态资源的执行时机可能早于非静态资源,一定不会晚于非静态资源</span> </li></ol></blockquote><blockquote><p><strong>final关键字</strong></p><p>final表示“最终”的意思，可以用来修饰属性、变量、类和方法</p><p>final修饰的属性、变量就成为了常量，无法对其再次进行赋值。final 修饰的局部变量，只能赋值一次（可以先声明后赋值）；final修饰的成员属性，必须在声明时赋值！</p><p>全局常量：<code>public static final 数据类型 变量名</code></p><p>final修饰的类不可以被继承</p><p>final修饰的方法不能被子类重写</p></blockquote><blockquote><p><strong>代码块</strong></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">普通代码块 </span><br><span class="line">在执行的流程中出现的代码块，我们称其为普通代码块。 </span><br><span class="line">构造代码块 </span><br><span class="line">在类中的成员代码块，我们称其为构造代码块，在每次对象创建时执行，执行在构造方法之前。 </span><br><span class="line">静态代码块</span><br><span class="line">在类中使用<span class="keyword">static</span>修饰的成员代码块，我们称其为静态代码块，在类加载时执行。 每次程序启动到关闭，只会执行一次的代码块。 </span><br><span class="line">同步代码块 </span><br><span class="line">在后续多线程技术中学习。 </span><br><span class="line"></span><br><span class="line">面试题： </span><br><span class="line">构造方法与构造代码块以及静态代码块的执行顺序：</span><br><span class="line">静态代码块 --&gt; 构造代码块 --&gt; 构造方法</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>mian()方法详解</strong></p><p><code>public static void main(String args[])</code> </p><p>以上的各个参数的含义如下： </p><p>​        public：表示公共的内容，可以被所有操作所调用 </p><p>​        static：表示方法是静态的，可以由类名称直接调用。</p><p>​        void：表示没有任何的返回值操作 </p><p>​        main：系统规定好的方法名称。如果main写错了或没有，会报错：NoSuchMethodError: main </p><p>​        String[] args：字符串数组，接收参数的</p></blockquote><h2 id="面向对象的三大特征（抽象）"><a href="#面向对象的三大特征（抽象）" class="headerlink" title="面向对象的三大特征（抽象）"></a>面向对象的三大特征（抽象）</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>该露的露，该藏的藏。我们程序设计要追求<span style="color:red">“高内聚，低耦合”</span>。高内聚就是类的内部数据操作细节自己完成，不允许外部干涉，低耦合就是仅暴漏少量的方法给外部使用。</p><p>封装(数据的隐藏)。通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称之为信息隐藏。</p><p>总之就是：<span style="color:red"><strong>属性私有，get/set</strong></span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//属性：私有 private</span></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//名字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> idNum;<span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> sex;<span class="comment">//性别</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一些可以操纵私有属性的方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//set 设置值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;<span class="comment">//this关键字：this指当前对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//get 获取值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdNum</span><span class="params">(<span class="keyword">int</span> id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idNum = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIdNum</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.idNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSex</span><span class="params">(<span class="keyword">char</span> sex)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.sex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(age&gt;<span class="number">120</span> || age &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = <span class="number">3</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu1 = <span class="keyword">new</span> Student();</span><br><span class="line">        </span><br><span class="line">        stu1.setName(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(stu1.getName());</span><br><span class="line">        stu1.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(stu1.getAge());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Idea快捷方式   <kbd>Alt</kbd>+<kbd>Insert</kbd> : 自动生成get/set方法</p></blockquote><blockquote><p>在Java基础中，this关键字是一个最重要的概念。使用this关键字可以完成以下的操作：</p><ul><li>调用类中的属性 </li><li>调用类中的方法或构造方法</li><li>表示当前对象</li></ul></blockquote><blockquote><p><strong>权限修饰符</strong></p><table><thead><tr><th>修饰符</th><th>类</th><th>包</th><th>子类</th><th>其他包</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>default</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>如上表所示，public修饰的资源可以被其所在类，所在包，所在类的子类和其他包访问，protecte修饰的资源不可以被其他包访问，default修饰的资源只能被其所在类，所在包访问，而private修饰的资源只能被其所在类访问</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承的本质是对某一批类的抽象，从而实现对现实世界更好的建模。</p><p><span style="color:red">Java中类只有单继承，多重继承，没有多继承！</span></p><p>继承关系的两个类，一个为子类（派生类），一个为父类（基类）。子类继承父类，使用关键字extends来表示。</p><p>private 类型的属性和方法不可被继承，也就是说子类不能调用父类私有的属性和方法。</p><p><strong>object</strong>类：在Java类，所有的类都默认直接或者间接继承Object类</p><p><strong>super</strong>：类似this,this指示的是当前对象，super指示的是其父类对象。通过supe，可以访问父类的构造方法、父类的属性和父类的方法。<span style="color:red">使用super调用了父类构造方法时，必须要在子类构造器的第一行</span></p><p>在我们创建子类对象时，内存中会先创建父类对象，再创建子类对象，子类会通过super关键字拥有父类的地址，来调用父类中可使用的属性和方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name = <span class="string">"Brian"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person父类的无参构造执行了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Person"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//隐藏代码：调用了父类的无参构造。若要写，必须要在子类构造器的第一行。如果父类没有无参构造，则super(参数...)不可被省略。</span></span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        System.out.println(<span class="string">"Student子类的无参构造执行了"</span>);</span><br><span class="line">        <span class="comment">//super(); 错误。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"ZhangSan"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.name);<span class="comment">//ZhangSan</span></span><br><span class="line">        System.out.println(<span class="keyword">super</span>.name);<span class="comment">//Brian</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        print();</span><br><span class="line">        <span class="keyword">this</span>.print();</span><br><span class="line">        <span class="keyword">super</span>.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Person父类的无参构造执行了</span></span><br><span class="line"><span class="comment">Student子类的无参构造执行了</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test(<span class="string">"张三"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        张三</span></span><br><span class="line"><span class="comment">ZhangSan</span></span><br><span class="line"><span class="comment">Brian</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        stu.test1();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        *结果：</span></span><br><span class="line"><span class="comment">        Student</span></span><br><span class="line"><span class="comment">Student</span></span><br><span class="line"><span class="comment">Person</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><span style="color:red">注意：</span></p><ol><li>super调用父类的构造方法，必须在子类构造方法的第一个！</li><li>super必须只能出现在子类的方法或者构造方法中！</li><li>super和this不能同时调用构造方法！</li></ol><p>super VS this</p><ul><li>代表的对象不同：<ul><li>this : 本身调用者这个对象</li><li>super : 代表父类对象的应用</li></ul></li><li>前提：<ul><li>this 没有继承也可以使用</li><li>super : 只能在继承条件下才能使用</li></ul></li><li>构造方法：<ul><li>this() : 本类的构造</li><li>super() :  父类的构造</li></ul></li></ul></blockquote><h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写:"></a>方法重写:</h4><p>规则：</p><ul><li><strong>参数列表必须完全与被重写方法的相同。</strong></li><li>一般情况下，<strong>返回值类型必须完全与被重写方法的返回值类型相同</strong>；当返回值为<strong>类类型</strong>时，重写的方法返回值可以不同，但<strong>必须是父类方法返回值的子类</strong>。</li><li><strong>访问权限不能比父类中被重写的方法的访问权限更低</strong>。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为 final 的方法不能被重写。</li><li>声明为 static 和 private 的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//B.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//A.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo05;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span><span class="comment">//重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A-&gt;test()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.A;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo05.B;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法:方法的调用只和左边定义的数据类型有关</span></span><br><span class="line">    <span class="comment">//非静态方法:重写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.test();<span class="comment">//结果：A-&gt;test()</span></span><br><span class="line">        <span class="comment">//父类的引用指向子类</span></span><br><span class="line">        B b = <span class="keyword">new</span> A();</span><br><span class="line">        b.test(); <span class="comment">//子类重写了父类的方法结果：A-&gt;test()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>为什么需要重写？</strong></p><ol><li>父类的功能，子类不一定需要，或者不一定满足。</li></ol></blockquote><blockquote><p>Idea快捷方式   <kbd>Ctrl</kbd>+<kbd>H</kbd> : 显示继承关系</p></blockquote><blockquote><p><strong>重写（override）与重载（overload）的区别</strong></p><ol><li>重载发生在一个类中，重写发生在子父类中</li><li>重载参数列表必须不同，重写的参数列表必须相同</li><li>重载与返回值类型无关，重写的返回值类型必须一致或是父类的子类</li><li>重载与访问权限无关，重写中，子类的方法的访问权限不能小于父类中被重写方法的权限</li><li>重载与异常无关，重写的方法不能抛出新的异常，或者比被重写方法声明的更广泛的异常</li></ol></blockquote><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式。一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p><p>多态存在的条件：</p><ul><li>有继承关系</li><li>子类重写父类方法</li><li>父类引用指向子类对象  <code>Father f1 = new Son();</code></li></ul><blockquote><p><strong>注意：</strong></p><ol><li>多态是方法的多态，属性没有多态性</li><li>父类和子类，有联系，若无，则会报异常(类型转换异常:ClassCastException)</li></ol></blockquote><blockquote><p>有些方法无法重写：</p><ol><li>static 方法  属于类，不属于实例对象</li><li>final </li><li>private 方法</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java 父类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java 子类</span></span><br><span class="line"><span class="keyword">package</span> top.oop.demo06;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java 测试类</span></span><br><span class="line"><span class="keyword">package</span> top.oop;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Person;</span><br><span class="line"><span class="keyword">import</span> top.oop.demo06.Student;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//一个对象的实际类型是确定的，可以指向的引用类型就不确定了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Person 父类，可以指向子类，但不能调用子类独有的方法</span></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person();<span class="comment">//Person对象 </span></span><br><span class="line">        Person s2 = <span class="keyword">new</span> Student();  <span class="comment">//Student对象 父类的引用指向子类</span></span><br><span class="line">        <span class="comment">// Student 能调用的方法都是自己的或者继承父类的！</span></span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student();<span class="comment">//Student对象</span></span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">p1.run();<span class="comment">//run 执行Person类的方法</span></span><br><span class="line">        s2.run();<span class="comment">//son  子类重写了父类的方法，执行子类Student类的方法</span></span><br><span class="line">        s1.run();<span class="comment">//son</span></span><br><span class="line">        <span class="comment">//s2.eat(); 错误:s2的引用类型为Person类型 它不能调用子类独有的方法</span></span><br><span class="line">        s1.eat();<span class="comment">//eat 执行Student类的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>扩展： <code>instanceof</code>和类型转换</strong></p><p><strong><code>instanceof</code></strong></p><p>关键字  <code>instanceof</code> ： Java 的一个二元操作符，类似于 ==，&gt;，&lt; 等操作符。</p><p>它的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> result = obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure><p>其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p><p>注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定。</p><p><strong>1. obj必须为引用类型，不能是基本类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Integer);<span class="comment">//编译不通过</span></span><br><span class="line">System.out.println(i <span class="keyword">instanceof</span> Object);<span class="comment">//编译不通过</span></span><br></pre></td></tr></table></figure><p>instanceof运算符只能用作对象的判断。</p><p><strong>2. obj 为 null</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">null</span> <span class="keyword">instanceof</span> Object);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>关于 null 类型的描述在官方文档：<a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.1</a> 有一些介绍。一般我们知道Java分为两种数据类型，一种是基本数据类型，有八个分别是 byte short int long float double char boolean,一种是引用类型，包括类、接口、数组等等。而Java中还有一种特殊的 null 类型，该类型没有名字，所以不可能声明为 null 类型的变量或者转换为 null 类型，null 引用是 null 类型表达式唯一可能的值，null 引用也可以转换为任意引用类型。我们不需要对 null 类型有多深刻的了解，我们只需要知道 null 是可以成为任意引用类型的<strong>特殊符号</strong>。</p><p>在 <a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-15.html#jls-15.20.2" target="_blank" rel="noopener">JavaSE规范</a> 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返回 false。</p><p><strong>3. obj为class类的实例对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer integer = <span class="keyword">new</span> Integer(<span class="number">1</span>);</span><br><span class="line">System.out.println(integer <span class="keyword">instanceof</span> Integer);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>4. obj为class接口的实现类</strong></p><p>集合中有个上层接口 List，其有个典型实现类 ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;    </span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;,<span class="title">RandomAccess</span>,<span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>所以我们可以用 instanceof 运算符判断 某个对象是否是 List 接口的实现类，如果是返回 true，否则返回 false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(arrayList <span class="keyword">instanceof</span> List);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>或者反过来也是返回 true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(list <span class="keyword">instanceof</span> ArrayList);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><strong>5. obj为class类的直接或间接子类</strong></p><p>新建一个父类 Person，然后在创建它的一个子类 Man</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Person p2 = <span class="keyword">new</span> Man();</span><br><span class="line">Man m1 = <span class="keyword">new</span> Man();</span><br><span class="line">System.out.println(p1 <span class="keyword">instanceof</span> Man);<span class="comment">//false</span></span><br><span class="line">System.out.println(p2 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br><span class="line">System.out.println(m1 <span class="keyword">instanceof</span> Man);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>注意第一种情况， <code>p1 instanceof Man</code> ，Man 是 Person 的子类，Person 不是 Man 的子类，所以返回结果为 false。</p><h6 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h6><p>java的引用类型转换分为两种：</p><ol><li><p>向上类型转换，是小类型到大类型的转换 ，子类转换为父类，可能会丢失自己本来的一些方法</p></li><li><p>向下类型转换，是大类型到小类型的转换 (强制转换)  父类转化为子类</p><p> <strong>引用类型的强转条件</strong> : 把父类类型(直接父类+间接父类)  —&gt; 子类类型</p><p>  A x = (A)B;  只要B是A的父类,此句代码编译通过</p><p> <strong>强转的意义</strong>：把父类类型强转为子类类型，在编译期可以调用子类的字段与方法(父类的字段与方法子类都能直接继承，但是子类有的父类有可能没有)==&gt;强转之后，父类与子类的字段与方法都可以使用</p></li></ol><p>现存在一个Person类，Student子类和Teacher子类继承于Person父类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"father class:run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">go</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"son Student class:go"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化一个student对象，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();   <span class="comment">//使用子类引用实例化子类对象</span></span><br><span class="line"><span class="comment">//Teacher t = (Teacher)s;//不能转，因为Student 与 Teacher没有继承关系</span></span><br><span class="line">Person p = s; <span class="comment">//此时为向上引用转换，小类型转换为大类型，自动转换，并没有风险</span></span><br><span class="line"><span class="comment">//p.go(); //错误，Person引用类型不能调用子类独有的方法</span></span><br><span class="line">Person ps = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//Student s2 = (Student)ps;//引用类型的大转小，强制转换.</span></span><br></pre></td></tr></table></figure><p>向下引用转换应该先判断类型是否一致，利用java的instanceof关键字判断。instanceof运算符用法：判断是一个实例对象是否属于一个类，是返回true，否则返回false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Person p2 = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Teacher) &#123;<span class="comment">//判断p2是否是Teacher类型的对象</span></span><br><span class="line">    Teacher tea = (Teacher)p2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(p2 <span class="keyword">instanceof</span> Student) &#123;<span class="comment">//判断p2是否是Student类型的对象</span></span><br><span class="line">    Student stu = (Student)p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在实际项目中,p2的值可能是new Student()|new Teacher()|new Person(). 如果值是new Teacher()则把该对象p2强转为Teacher类型</span></span><br><span class="line"><span class="comment">问题：如何判断p2的值到底是new的哪个类对象？</span></span><br><span class="line"><span class="comment">方案：使用instanceof.       instanceof:判断指定变量是否是指定类型的对象。</span></span><br><span class="line"><span class="comment">当前场景：判断 p2 是否是 Teacher类型 的对象。</span></span><br><span class="line"><span class="comment">语法：指定变量 instanceof 指定类型。   返回false:不是指定类型的对象 ， 反之则反</span></span><br><span class="line"><span class="comment">在运行期有效。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>但是当子类实例对象统一放进父类引用对象数组时，若要使用子类中的方法，必须先向下转换类型为子类引用，不然编译器会报错</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person[] people = &#123;</span><br><span class="line">    <span class="keyword">new</span> Student(),</span><br><span class="line">    <span class="keyword">new</span> Teacher()</span><br><span class="line">&#125;;  </span><br><span class="line"><span class="comment">//people[0].go();   //报错</span></span><br><span class="line"><span class="keyword">if</span>(people[<span class="number">0</span>] <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    ((Student)people[<span class="number">0</span>]).go();<span class="comment">//son Student class:go</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;static关键字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;static表示“静态”的意思，可以用来修饰成员变量和成员方法。&lt;/p&gt;
&lt;p&gt;static的主要作用在于创建独立于具体对象的域变量或者方法 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java面向对象基础</title>
    <link href="https://www.pengspace.top/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>https://www.pengspace.top/2020/09/30/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2020-09-30T04:17:29.000Z</published>
    <updated>2020-09-30T04:58:42.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初识面向对象"><a href="#初识面向对象" class="headerlink" title="初识面向对象"></a>初识面向对象</h2><h3 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h3><p><strong>面向过程思想：</strong></p><ul><li>是把模型分解成一步一步的过程。步骤清晰简单，第一步做什么，第二步做什么……</li><li>面向过程适合处理一些较为简单的问题</li></ul><a id="more"></a><p><strong>面向对象思想：</strong></p><ul><li>物以类聚，<span style="color:red">分类</span>的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索。</li><li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题！</li></ul><p><span style="color:red">对于描述复杂的事物，为了从宏观上把握、从整体上合理分析，我们需要使用面向对象的思路、来分析整个系统。但是，具体到微观操作，仍然需要面向过程的思路去处理。</span></p><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><p>面向对象编程(Object-Oriented Progrsmming,OOP)是一种通过对象的方式，把现实世界映射到计算机模型的一种编程方法。</p><p><strong>面向对象编程的本质就是：</strong><span style="color:red">以类的方式组织代码，以对象的形式封装数据。</span></p><p><strong>面向对象的核心思想：</strong></p><ul><li><p><strong>三大思想：</strong>面向对象思想从概念上讲分为以下三种OOA、OOD、OOP</p><ul><li>OOA：面向对象分析（Object Oriented Analysis） </li><li>OOD：面向对象设计（Object Oriented Design） </li><li>OOP：面向对象程序（Object Oriented Programming）</li></ul></li><li><p><strong>抽象</strong></p></li><li><p><strong>三大特性</strong></p><ul><li>封装性：所有的内容对外部不可见</li><li>继承性：将其他的功能继承下来继续发展</li><li>多态性：方法的重载本身就是一个多态性的体现</li></ul></li></ul><p>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象。</p><p>从代码运行角度考虑是先有类后有对象。类是对象的模板。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>具体可参考 <a href="http://pengspace.top/2020/05/30/Java方法/#more">java方法</a>，此处只做一些补充说明</p><h4 id="方法的定义"><a href="#方法的定义" class="headerlink" title="方法的定义"></a>方法的定义</h4><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><h5 id="返回类型"><a href="#返回类型" class="headerlink" title="返回类型"></a>返回类型</h5><h5 id="break和return的区别"><a href="#break和return的区别" class="headerlink" title="break和return的区别"></a>break和return的区别</h5><p><code>break</code>:结束整个循环</p><p><code>continue</code>:结束本次循环</p><p><code>return</code>: 结束方法，返回一个结果</p><h5 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h5><p>注意规范，首字母小写和驼峰原则。见名知意</p><h5 id="参数列表"><a href="#参数列表" class="headerlink" title="参数列表"></a>参数列表</h5><p>（参数类型，参数名）…</p><h5 id="异常抛出"><a href="#异常抛出" class="headerlink" title="异常抛出"></a>异常抛出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名) <span class="keyword">throws</span> 异常类型(如 IOException) &#123;  </span><br><span class="line">...</span><br><span class="line">方法体</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法的调用"><a href="#方法的调用" class="headerlink" title="方法的调用"></a>方法的调用</h4><h5 id="静态方法和非静态方法"><a href="#静态方法和非静态方法" class="headerlink" title="静态方法和非静态方法"></a>静态方法和非静态方法</h5><p><span style="color:red">非静态方法不能通过类名直接调用，若要调用非静态方法，必须先实例化该方法所在类的对象，通过对象来调用。</span></p><p><span style="color:red">静态方法可以通过类名直接调用，也可以通过对象调用。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Demo.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student.say1();</span><br><span class="line">        <span class="comment">//Student.say2();错误，非静态方法不能通过类名直接调用</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();<span class="comment">//实例化对象</span></span><br><span class="line">        stu.say1();</span><br><span class="line">        stu.say2();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Student.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//非静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"非静态方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span style="color:red">静态方法是和类一起加载的，而非静态方法是在类实例化后才会起作用的</span>，所以在类中，也不能在静态方法中去调用非静态方法</p><h5 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h5><blockquote><p>形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。</p><p>实际参数：在调用有参函数时，主调函数和被调函数有数据传递关系。在主调函数中调用一个函数时，函数后面括号中的参数称为“实际参数”。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">        <span class="comment">//实际参数和形式参数的类型要对应</span></span><br><span class="line">        <span class="keyword">int</span> add = demo.add(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">//1和2是实参</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    <span class="comment">//a和b是形参</span></span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际参数是调用有参方法时真正传递的内容，而形式参数是用于接收实参内容的参数。</p><h5 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h5><p><span style="color:red">Java中都是值传递。</span></p><p>后续会专门写一篇来讲述Java为什么都是值传递。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><h3 id="类与对象的关系"><a href="#类与对象的关系" class="headerlink" title="类与对象的关系"></a>类与对象的关系</h3><p><span style="color:red">类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物。</span>比如Person类、Pet类、Car类等，这些类都是<span style="color:red">用来描述/定义某一类具体事物应该具备的特点和行为。</span></p><p><span style="color:red">对象是抽象概念的具体实例。</span>比如 你就是个人的具体实例，你家的旺财就是狗的一个具体实例。<span style="color:red">能够体现出特点、展现出功能的是具体的实例，而不是一个抽象的概念。</span></p><h3 id="类的定义格式"><a href="#类的定义格式" class="headerlink" title="类的定义格式"></a>类的定义格式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称</span>&#123;</span><br><span class="line">成员属性</span><br><span class="line">成员方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">属性定义格式：</span><br><span class="line">数据类型 属性名;</span><br><span class="line">属性定义并赋值的格式：</span><br><span class="line">数据类型 属性名 = 初始化值;</span><br><span class="line">方法定义格式：</span><br><span class="line">权限修饰符 返回值类型 方法名(形式参数列表)&#123;</span><br><span class="line"><span class="comment">//方法体</span></span><br><span class="line"><span class="keyword">return</span> 返回值；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>使用<code>new</code>关键字创建对象。</p><p>使用<code>new</code>关键字创建对象的时候，除了为对象分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一个类要想真正的进行操作，则必须依靠对象，对象的定义格式如下:</span><br><span class="line">类名称 对象名称 = <span class="keyword">new</span> 类名称();</span><br><span class="line"></span><br><span class="line">如果要想访问类中的属性或方法（方法的定义），则可以依靠以下的语法形式：</span><br><span class="line">访问类中的属性： 对象.属性 ;</span><br><span class="line">调用类中的方法： 对象.方法(实际参数列表) ;</span><br></pre></td></tr></table></figure><h3 id="构造方法（构造器）详解"><a href="#构造方法（构造器）详解" class="headerlink" title="构造方法（构造器）详解"></a>构造方法（构造器）详解</h3><p>一个类中即使什么都不写，也可以实例化该类的对象，那是因为，类中默认存在一个方法，就是<span style="color:red"><strong>构造器</strong></span>。</p><p>类中的<span style="color:red"><strong>构造器</strong></span>也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下两个特点：</p><ul><li>必须和类的名字相同</li><li>必须没有返回类型，也不能写void</li></ul><p>我们在使用<code>new</code>关键字实例化对象时,本质是在调用构造器,来初始化值。</p><p>构造器可以重载，但注意，<span style="color:red">一旦你定义了有参构造器，如果还想使用无参构造，无参构造器就必须也显式定义。</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Person.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">//一个类即使什么都不写，它也会存在一个方法</span></span><br><span class="line">    <span class="comment">//默认构造器 public  Person()&#123;&#125;</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">//无参构造器 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//有参构造器：一旦定义了有参构造，无参构造器就必须显式定义</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Application.java</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//new 实例化对象</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">"brian"</span>);</span><br><span class="line">        System.out.println(person.name);    <span class="comment">//null</span></span><br><span class="line">        System.out.println(person1.name);   <span class="comment">//brian</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">没有对象名称的对象 就是匿名对象。 </span><br><span class="line">匿名对象只能使用一次，因为没有任何的对象引用，所以将称为垃圾，等待被GC回收。 </span><br><span class="line">只使用一次的对象可以通过匿名对象的方式完成，这一点在以后的开发中将经常使用到。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="keyword">new</span> Math().sum(<span class="number">100</span>,<span class="number">20</span>);<span class="comment">//匿名对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建对象内存分析"><a href="#创建对象内存分析" class="headerlink" title="创建对象内存分析"></a>创建对象内存分析</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><blockquote><p>Java栈的区域很小 , 大概2m左右 , 特点是存取的速度特别快 </p><p>栈存储的特点是, 先进后出</p><p>存储速度快的原因: </p><p>栈内存, 通过 ‘栈指针’ 来创建空间与释放空间 ! </p><p>指针向下移动, 会创建新的内存, 向上移动, 会释放这些内存 ! </p><p>这种方式速度特别快 , 仅次于PC寄存器 ! </p><p>但是这种移动的方式, 必须要明确移动的大小与范围 , 明确大小与范围是为了方便指针的移动 , 这是一个对于数据存储的限制, 存储的数据大小是固定的 , 影响了程序 的灵活性 ~</p><p>所以我们把更大部分的数据 存储到了堆内存中 </p><p>存储的是: </p><p>​        基本数据类型的数据 以及 引用数据类型的引用! </p><p>​        例如: </p><p>​        int a =10;</p><p>​        Person p = new Person(); </p><p>​        10存储在栈内存中 , 第二句代码创建的对象的引用(p)存在栈内存中</p></blockquote><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><blockquote><p>存放的是类的对象 . </p><p>Java是一个纯面向对象语言, 限制了对象的创建方式: </p><p>​        <span style="color:red">所有类的对象都是通过new关键字创建 </span></p><p>new关键字, 是指告诉JVM , 需要明确的去创建一个新的对象 , 去开辟一块新的堆内存空间: </p><p>堆内存与栈内存不同, 优点在于我们创建对象时 , 不必关注堆内存中需要开辟多少存储空间 , 也不需要关注内存占用 时长 ! </p><p>堆内存中内存的释放是由GC(垃圾回收器)完成的 </p><p>垃圾回收器 回收堆内存的规则: </p><p>​        当栈内存中不存在此对象的引用时,则视其为垃圾 , 等待垃圾回收器回收 !</p></blockquote><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote><p>存放的是 </p><ul><li>类信息 </li><li>静态的变量 </li><li>常量</li><li>成员方法 </li></ul><p>方法区中包含了一个特殊的区域 ( 常量池 )(存储的是使用static修饰的成员)</p></blockquote><h3 id="PC寄存器"><a href="#PC寄存器" class="headerlink" title="PC寄存器"></a>PC寄存器</h3><blockquote><p>PC寄存器保存的是 当前正在执行的 JVM指令的 地址 ! </p><p>在Java程序中, 每个线程启动时, 都会创建一个PC寄存器 !</p></blockquote><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>保存本地(native)方法的地址 !</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;初识面向对象&quot;&gt;&lt;a href=&quot;#初识面向对象&quot; class=&quot;headerlink&quot; title=&quot;初识面向对象&quot;&gt;&lt;/a&gt;初识面向对象&lt;/h2&gt;&lt;h3 id=&quot;面向过程和面向对象&quot;&gt;&lt;a href=&quot;#面向过程和面向对象&quot; class=&quot;headerlink&quot; title=&quot;面向过程和面向对象&quot;&gt;&lt;/a&gt;面向过程和面向对象&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;面向过程思想：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是把模型分解成一步一步的过程。步骤清晰简单，第一步做什么，第二步做什么……&lt;/li&gt;
&lt;li&gt;面向过程适合处理一些较为简单的问题&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="https://www.pengspace.top/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="面向对象" scheme="https://www.pengspace.top/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>简单的Java加减乘除计算器(适合新手)</title>
    <link href="https://www.pengspace.top/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/"/>
    <id>https://www.pengspace.top/2020/05/30/%E7%AE%80%E5%8D%95%E7%9A%84Java%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E8%AE%A1%E7%AE%97%E5%99%A8-%E9%80%82%E5%90%88%E6%96%B0%E6%89%8B/</id>
    <published>2020-05-30T14:59:13.000Z</published>
    <updated>2020-09-30T04:24:41.405Z</updated>
    
    <content type="html"><![CDATA[<p>本人Java新手一枚，刚学完Java数据类型、流程控制、数组、方法等基础语法知识。</p><p>尝试写了一个简单的计算器，实现了加减乘除功能，并可以循环接收数据。</p><p>代码有待改进，希望各位大佬多多指点 :beers:</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">calculator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第一个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> a = in.nextDouble();</span><br><span class="line">            System.out.println(<span class="string">"请输入需要计算的第二个数字"</span>);</span><br><span class="line">            <span class="keyword">double</span> b = in.nextDouble();</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入运算方式(+ - * /)"</span>);</span><br><span class="line">                String operation = in.next();</span><br><span class="line">                <span class="keyword">switch</span> (operation) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">                        System.out.println(add(a,b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">                        System.out.println(subtraction(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">                        System.out.println(multiply(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">                        System.out.println(division(a, b));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"是否继续使用? "</span> + <span class="string">"YES/NO"</span>);</span><br><span class="line">                String choose = in.next();</span><br><span class="line">                <span class="keyword">if</span> (choose.equals(<span class="string">"YES"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (choose.equals(<span class="string">"NO"</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"欢迎下次使用，再见"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"输入不正确，请重新输入"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//减</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">subtraction</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//乘</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">multiply</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//除</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">division</span><span class="params">(<span class="keyword">double</span> a,<span class="keyword">double</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"被除数不能为0"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a/b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本人Java新手一枚，刚学完Java数据类型、流程控制、数组、方法等基础语法知识。&lt;/p&gt;
&lt;p&gt;尝试写了一个简单的计算器，实现了加减乘除功能，并可以循环接收数据。&lt;/p&gt;
&lt;p&gt;代码有待改进，希望各位大佬多多指点 :beers:&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java练习" scheme="https://www.pengspace.top/categories/Java%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Java" scheme="https://www.pengspace.top/tags/Java/"/>
    
      <category term="代码" scheme="https://www.pengspace.top/tags/%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
</feed>
